var tc = Object.defineProperty, ec = Object.defineProperties; var nc = Object.getOwnPropertyDescriptors; var Vn = Object.getOwnPropertySymbols; var is = Object.prototype.hasOwnProperty, rs = Object.prototype.propertyIsEnumerable; var ss = Math.pow, Ai = (e, t, a) => t in e ? tc(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Et = (e, t) => { for (var a in t || (t = {})) is.call(t, a) && Ai(e, a, t[a]); if (Vn) for (var a of Vn(t)) rs.call(t, a) && Ai(e, a, t[a]); return e }, Ut = (e, t) => ec(e, nc(t)); var os = (e, t) => { var a = {}; for (var p in e) is.call(e, p) && t.indexOf(p) < 0 && (a[p] = e[p]); if (e != null && Vn) for (var p of Vn(e)) t.indexOf(p) < 0 && rs.call(e, p) && (a[p] = e[p]); return a }; var Z = (e, t, a) => (Ai(e, typeof t != "symbol" ? t + "" : t, a), a); var ie = (e, t, a) => new Promise((p, v) => { var _ = r => { try { f(a.next(r)) } catch (c) { v(c) } }, b = r => { try { f(a.throw(r)) } catch (c) { v(c) } }, f = r => r.done ? p(r.value) : Promise.resolve(r.value).then(_, b); f((a = a.apply(e, t)).next()) }); import { r as ee, i as Ue, o as ue, a as ic, b as ut, c as lt, d as mt, e as I, w as G, f as xt, t as yt, g as Dt, h as Vo, j as Wt, u as j, k as dt, l as ze, m as de, n as rc, p as sc, q as oc, s as ac, v as lc, x as Pt, y as di, z as qt, _ as Yt, A as S, B as Ke, C as pi, F as te, D as ce, E as Ct, G as Or, H as me, I as ve, J as cc, K as Rt, L as At, M as In, N as pe, O as No, P as he, Q as Mt, R as Sn, S as uc, T as ai, U as as, V as ls, W as Nn, X as cs, Y as us } from "./index.414766e6.js"; var Se = (e => (e.EMPTY = "", e.ONE = "one", e.MULTI = "multiple", e))(Se || {}), Ji = (e => (e.EMPTY = "", e.GROUP = "group", e.POLYGON = "polygon", e))(Ji || {}), fe = (e => (e.ONE = "selectOne", e.MULTI = "selectMultiple", e.CANCEL = "selectCancel", e))(fe || {}); function zt() { const e = ee({ mSelectMode: Se.EMPTY, mSelectOneType: Ji.EMPTY, mSelectId: "", mSelectIds: [], mSelectActive: [] }), t = Ue("fabric"), a = Ue("canvasEditor"), p = Ue("event"), v = f => { e.mSelectMode = Se.ONE, e.mSelectId = f[0].id, e.mSelectOneType = f[0].type, e.mSelectIds = f.map(r => r.id) }, _ = f => { e.mSelectMode = Se.MULTI, e.mSelectId = "", e.mSelectIds = f.map(r => r.id) }, b = () => { e.mSelectId = "", e.mSelectIds = [], e.mSelectMode = Se.EMPTY, e.mSelectOneType = Ji.EMPTY }; return ue(() => { p.on(fe.ONE, v), p.on(fe.MULTI, _), p.on(fe.CANCEL, b) }), ic(() => { p.off(fe.ONE, v), p.off(fe.MULTI, _), p.off(fe.CANCEL, b) }), { fabric: t, canvasEditor: a, mixinState: e } } const hc = { style: { display: "inline-block" } }, fc = Dt({ name: "ImportJson" }), dc = Object.assign(fc, { setup(e) { const { canvasEditor: t } = zt(), a = () => { t.insert() }; return (p, v) => { const _ = ut("Button"); return lt(), mt("div", hc, [I(_, { onClick: a, type: "text", size: "small" }, { default: G(() => [xt(yt(p.$t("import_files")), 1)]), _: 1 })]) } } }); var Wo = { exports: {} }; (function (e) { (function () { function t(u, l) { document.addEventListener ? u.addEventListener("scroll", l, !1) : u.attachEvent("scroll", l) } function a(u) { document.body ? u() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function l() { document.removeEventListener("DOMContentLoaded", l), u() }) : document.attachEvent("onreadystatechange", function l() { (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", l), u()) }) } function p(u) { this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(u)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i) } function v(u, l) { u.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + l + ";" } function _(u) { var l = u.g.offsetWidth, d = l + 100; return u.j.style.width = d + "px", u.i.scrollLeft = d, u.h.scrollLeft = u.h.scrollWidth + 100, u.l !== l ? (u.l = l, !0) : !1 } function b(u, l) { function d() { var m = g; _(m) && m.g.parentNode !== null && l(m.l) } var g = u; t(u.h, d), t(u.i, d), _(u) } function f(u, l, d) { l = l || {}, d = d || window, this.family = u, this.style = l.style || "normal", this.weight = l.weight || "normal", this.stretch = l.stretch || "normal", this.context = d } var r = null, c = null, h = null, n = null; function o(u) { return c === null && (i(u) && /Apple/.test(window.navigator.vendor) ? (u = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), c = !!u && 603 > parseInt(u[1], 10)) : c = !1), c } function i(u) { return n === null && (n = !!u.document.fonts), n } function s(u, l) { var d = u.style, g = u.weight; if (h === null) { var m = document.createElement("div"); try { m.style.font = "condensed 100px sans-serif" } catch (y) { } h = m.style.font !== "" } return [d, g, h ? u.stretch : "", "100px", l].join(" ") } f.prototype.load = function (u, l) { var d = this, g = u || "BESbswy", m = 0, y = l || 3e3, w = new Date().getTime(); return new Promise(function (C, T) { if (i(d.context) && !o(d.context)) { var A = new Promise(function (R, $) { function L() { new Date().getTime() - w >= y ? $(Error("" + y + "ms timeout exceeded")) : d.context.document.fonts.load(s(d, '"' + d.family + '"'), g).then(function (B) { 1 <= B.length ? R() : setTimeout(L, 25) }, $) } L() }), U = new Promise(function (R, $) { m = setTimeout(function () { $(Error("" + y + "ms timeout exceeded")) }, y) }); Promise.race([U, A]).then(function () { clearTimeout(m), C(d) }, T) } else a(function () { function R() { var P; (P = K != -1 && st != -1 || K != -1 && ft != -1 || st != -1 && ft != -1) && ((P = K != st && K != ft && st != ft) || (r === null && (P = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), r = !!P && (536 > parseInt(P[1], 10) || parseInt(P[1], 10) === 536 && 11 >= parseInt(P[2], 10))), P = r && (K == ht && st == ht && ft == ht || K == k && st == k && ft == k || K == M && st == M && ft == M)), P = !P), P && (E.parentNode !== null && E.parentNode.removeChild(E), clearTimeout(m), C(d)) } function $() { if (new Date().getTime() - w >= y) E.parentNode !== null && E.parentNode.removeChild(E), T(Error("" + y + "ms timeout exceeded")); else { var P = d.context.document.hidden; (P === !0 || P === void 0) && (K = L.g.offsetWidth, st = B.g.offsetWidth, ft = N.g.offsetWidth, R()), m = setTimeout($, 50) } } var L = new p(g), B = new p(g), N = new p(g), K = -1, st = -1, ft = -1, ht = -1, k = -1, M = -1, E = document.createElement("div"); E.dir = "ltr", v(L, s(d, "sans-serif")), v(B, s(d, "serif")), v(N, s(d, "monospace")), E.appendChild(L.g), E.appendChild(B.g), E.appendChild(N.g), d.context.document.body.appendChild(E), ht = L.g.offsetWidth, k = B.g.offsetWidth, M = N.g.offsetWidth, $(), b(L, function (P) { K = P, R() }), v(L, s(d, '"' + d.family + '",sans-serif')), b(B, function (P) { st = P, R() }), v(B, s(d, '"' + d.family + '",serif')), b(N, function (P) { ft = P, R() }), v(N, s(d, '"' + d.family + '",monospace')) }) }) }, e.exports = f })() })(Wo); var pc = Wo.exports; const Yo = Vo(pc); function kr(e) { return rc() ? (sc(e), !0) : !1 } function gc() { const e = new Set, t = v => { e.delete(v) }; return { on: v => { e.add(v); const _ = () => t(v); return kr(_), { off: _ } }, off: t, trigger: v => Promise.all(Array.from(e).map(_ => v ? _(v) : _())) } } function Ye(e) { return typeof e == "function" ? e() : j(e) } const Rn = typeof window != "undefined" && typeof document != "undefined"; typeof WorkerGlobalScope != "undefined" && globalThis instanceof WorkerGlobalScope; const mc = Object.prototype.toString, vc = e => mc.call(e) === "[object Object]", _c = () => +Date.now(), Go = () => { }, yc = (e, t) => Object.prototype.hasOwnProperty.call(e, t); function bc(e, t) { function a(...p) { return new Promise((v, _) => { Promise.resolve(e(() => t.apply(this, p), { fn: t, thisArg: this, args: p })).then(v).catch(_) }) } return a } const Xo = e => e(); function wc(e = Xo) { const t = dt(!0); function a() { t.value = !1 } function p() { t.value = !0 } const v = (..._) => { t.value && e(..._) }; return { isActive: ze(t), pause: a, resume: p, eventFilter: v } } function Cc(e) { let t; function a() { return t || (t = e()), t } return a.reset = () => ie(this, null, function* () { const p = t; t = void 0, p && (yield p) }), a } function Sc(...e) { if (e.length !== 1) return oc(...e); const t = e[0]; return typeof t == "function" ? ze(ac(() => ({ get: t, set: Go }))) : dt(t) } const xc = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, Tc = /[YMDHhms]o|\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g; function Oc(e, t, a, p) { let v = e < 12 ? "AM" : "PM"; return p && (v = v.split("").reduce((_, b) => _ += `${b}.`, "")), a ? v.toLowerCase() : v } function Ve(e) { const t = ["th", "st", "nd", "rd"], a = e % 100; return e + (t[(a - 20) % 10] || t[a] || t[0]) } function kc(e, t, a = {}) { var p; const v = e.getFullYear(), _ = e.getMonth(), b = e.getDate(), f = e.getHours(), r = e.getMinutes(), c = e.getSeconds(), h = e.getMilliseconds(), n = e.getDay(), o = (p = a.customMeridiem) != null ? p : Oc, i = { Yo: () => Ve(v), YY: () => String(v).slice(-2), YYYY: () => v, M: () => _ + 1, Mo: () => Ve(_ + 1), MM: () => `${_ + 1}`.padStart(2, "0"), MMM: () => e.toLocaleDateString(a.locales, { month: "short" }), MMMM: () => e.toLocaleDateString(a.locales, { month: "long" }), D: () => String(b), Do: () => Ve(b), DD: () => `${b}`.padStart(2, "0"), H: () => String(f), Ho: () => Ve(f), HH: () => `${f}`.padStart(2, "0"), h: () => `${f % 12 || 12}`.padStart(1, "0"), ho: () => Ve(f % 12 || 12), hh: () => `${f % 12 || 12}`.padStart(2, "0"), m: () => String(r), mo: () => Ve(r), mm: () => `${r}`.padStart(2, "0"), s: () => String(c), so: () => Ve(c), ss: () => `${c}`.padStart(2, "0"), SSS: () => `${h}`.padStart(3, "0"), d: () => n, dd: () => e.toLocaleDateString(a.locales, { weekday: "narrow" }), ddd: () => e.toLocaleDateString(a.locales, { weekday: "short" }), dddd: () => e.toLocaleDateString(a.locales, { weekday: "long" }), A: () => o(f, r), AA: () => o(f, r, !1, !0), a: () => o(f, r, !0), aa: () => o(f, r, !0, !0) }; return t.replace(Tc, (s, u) => { var l, d; return (d = u != null ? u : (l = i[s]) == null ? void 0 : l.call(i)) != null ? d : s }) } function Ac(e) { if (e === null) return new Date(Number.NaN); if (e === void 0) return new Date; if (e instanceof Date) return new Date(e); if (typeof e == "string" && !/Z$/i.test(e)) { const t = e.match(xc); if (t) { const a = t[2] - 1 || 0, p = (t[7] || "0").substring(0, 3); return new Date(t[1], a, t[3] || 1, t[4] || 0, t[5] || 0, t[6] || 0, p) } } return new Date(e) } function Ec(e, t = "HH:mm:ss", a = {}) { return Wt(() => kc(Ac(Ye(e)), Ye(t), a)) } function Pc(e, t, a = {}) { const { immediate: p = !0 } = a, v = dt(!1); let _ = null; function b() { _ && (clearTimeout(_), _ = null) } function f() { v.value = !1, b() } function r(...c) { b(), v.value = !0, _ = setTimeout(() => { v.value = !1, _ = null, e(...c) }, Ye(t)) } return p && (v.value = !0, Rn && r()), kr(f), { isPending: ze(v), start: r, stop: f } } function Mc(e, t, a = {}) { const c = a, { eventFilter: p = Xo } = c, v = os(c, ["eventFilter"]), _ = bc(p, t); let b, f, r; if (v.flush === "sync") { const h = dt(!1); f = () => { }, b = n => { h.value = !0, n(), h.value = !1 }, r = de(e, (...n) => { h.value || _(...n) }, v) } else { const h = [], n = dt(0), o = dt(0); f = () => { n.value = o.value }, h.push(de(e, () => { o.value++ }, Ut(Et({}, v), { flush: "sync" }))), b = i => { const s = o.value; i(), n.value += o.value - s }, h.push(de(e, (...i) => { const s = n.value > 0 && n.value === o.value; n.value = 0, o.value = 0, !s && _(...i) }, v)), r = () => { h.forEach(i => i()) } } return { stop: r, ignoreUpdates: b, ignorePrevAsyncUpdates: f } } function jc(e) { var t; const a = Ye(e); return (t = a == null ? void 0 : a.$el) != null ? t : a } const Dc = Rn ? window : void 0, Lc = Rn ? window.document : void 0, Ko = Rn ? window.navigator : void 0; function xn(...e) { let t, a, p, v; if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([a, p, v] = e, t = Dc) : [t, a, p, v] = e, !t) return Go; Array.isArray(a) || (a = [a]), Array.isArray(p) || (p = [p]); const _ = [], b = () => { _.forEach(h => h()), _.length = 0 }, f = (h, n, o, i) => (h.addEventListener(n, o, i), () => h.removeEventListener(n, o, i)), r = de(() => [jc(t), Ye(v)], ([h, n]) => { if (b(), !h) return; const o = vc(n) ? Et({}, n) : n; _.push(...a.flatMap(i => p.map(s => f(h, i, s, o)))) }, { immediate: !0, flush: "post" }), c = () => { r(), b() }; return kr(c), c } function Fc() { const e = dt(!1); return di() && ue(() => { e.value = !0 }), e } function qo(e) { const t = Fc(); return Wt(() => (t.value, !!e())) } const yn = { array: e => JSON.stringify(e), object: e => JSON.stringify(e), set: e => JSON.stringify(Array.from(e)), map: e => JSON.stringify(Object.fromEntries(e)), null: () => "" }; function $c(e) { return e ? e instanceof Map ? yn.map : e instanceof Set ? yn.set : Array.isArray(e) ? yn.array : yn.object : yn.null } function Ic(e, t) { const a = dt(""), p = dt(); function v() { if (Rn) return p.value = new Promise((_, b) => { try { const f = Ye(e); if (f == null) _(""); else if (typeof f == "string") _(Ei(new Blob([f], { type: "text/plain" }))); else if (f instanceof Blob) _(Ei(f)); else if (f instanceof ArrayBuffer) _(window.btoa(String.fromCharCode(...new Uint8Array(f)))); else if (f instanceof HTMLCanvasElement) _(f.toDataURL(t == null ? void 0 : t.type, t == null ? void 0 : t.quality)); else if (f instanceof HTMLImageElement) { const r = f.cloneNode(!1); r.crossOrigin = "Anonymous", Rc(r).then(() => { const c = document.createElement("canvas"), h = c.getContext("2d"); c.width = r.width, c.height = r.height, h.drawImage(r, 0, 0, c.width, c.height), _(c.toDataURL(t == null ? void 0 : t.type, t == null ? void 0 : t.quality)) }).catch(b) } else if (typeof f == "object") { const c = ((t == null ? void 0 : t.serializer) || $c(f))(f); return _(Ei(new Blob([c], { type: "application/json" }))) } else b(new Error("target is unsupported types")) } catch (f) { b(f) } }), p.value.then(_ => a.value = _), p.value } return Pt(e) || typeof e == "function" ? de(e, v, { immediate: !0 }) : v(), { base64: a, promise: p, execute: v } } function Rc(e) { return new Promise((t, a) => { e.complete ? t() : (e.onload = () => { t() }, e.onerror = a) }) } function Ei(e) { return new Promise((t, a) => { const p = new FileReader; p.onload = v => { t(v.target.result) }, p.onerror = a, p.readAsDataURL(e) }) } function hs(e, t = {}) { const { controls: a = !1, navigator: p = Ko } = t, v = qo(() => p && "permissions" in p); let _; const b = typeof e == "string" ? { name: e } : e, f = dt(), r = () => { _ && (f.value = _.state) }, c = Cc(() => ie(this, null, function* () { if (v.value) { if (!_) try { _ = yield p.permissions.query(b), xn(_, "change", r), r() } catch (h) { f.value = "prompt" } return _ } })); return c(), a ? { state: f, isSupported: v, query: c } : f } function Bc(e = {}) { const { navigator: t = Ko, read: a = !1, source: p, copiedDuring: v = 1500, legacy: _ = !1 } = e, b = qo(() => t && "clipboard" in t), f = hs("clipboard-read"), r = hs("clipboard-write"), c = Wt(() => b.value || _), h = dt(""), n = dt(!1), o = Pc(() => n.value = !1, v); function i() { b.value && f.value !== "denied" ? t.clipboard.readText().then(d => { h.value = d }) : h.value = l() } c.value && a && xn(["copy", "cut"], i); function s() { return ie(this, arguments, function* (d = Ye(p)) { c.value && d != null && (b.value && r.value !== "denied" ? yield t.clipboard.writeText(d) : u(d), h.value = d, n.value = !0, o.start()) }) } function u(d) { const g = document.createElement("textarea"); g.value = d != null ? d : "", g.style.position = "absolute", g.style.opacity = "0", document.body.appendChild(g), g.select(), document.execCommand("copy"), g.remove() } function l() { var d, g, m; return (m = (g = (d = document == null ? void 0 : document.getSelection) == null ? void 0 : d.call(document)) == null ? void 0 : g.toString()) != null ? m : "" } return { isSupported: c, text: h, copied: n, copy: s } } function Jo(e) { return JSON.parse(JSON.stringify(e)) } function Zo(e) { return e } function zc(e, t) { return e.value = t } function Uc(e) { return e ? typeof e == "function" ? e : Jo : Zo } function Hc(e) { return e ? typeof e == "function" ? e : Jo : Zo } function Vc(e, t = {}) { const { clone: a = !1, dump: p = Uc(a), parse: v = Hc(a), setSource: _ = zc } = t; function b() { return lc({ snapshot: p(e.value), timestamp: _c() }) } const f = dt(b()), r = dt([]), c = dt([]), h = m => { _(e, v(m.snapshot)), f.value = m }, n = () => { r.value.unshift(f.value), f.value = b(), t.capacity && r.value.length > t.capacity && r.value.splice(t.capacity, Number.POSITIVE_INFINITY), c.value.length && c.value.splice(0, c.value.length) }, o = () => { r.value.splice(0, r.value.length), c.value.splice(0, c.value.length) }, i = () => { const m = r.value.shift(); m && (c.value.unshift(f.value), h(m)) }, s = () => { const m = c.value.shift(); m && (r.value.unshift(f.value), h(m)) }, u = () => { h(f.value) }, l = Wt(() => [f.value, ...r.value]), d = Wt(() => r.value.length > 0), g = Wt(() => c.value.length > 0); return { source: e, undoStack: r, redoStack: c, last: f, history: l, canUndo: d, canRedo: g, clear: o, commit: n, reset: u, undo: i, redo: s } } function Nc(e, t = {}) { const { deep: a = !1, flush: p = "pre", eventFilter: v } = t, { eventFilter: _, pause: b, resume: f, isActive: r } = wc(v), { ignoreUpdates: c, ignorePrevAsyncUpdates: h, stop: n } = Mc(e, l, { deep: a, flush: p, eventFilter: _ }); function o(y, w) { h(), c(() => { y.value = w }) } const i = Vc(e, Ut(Et({}, t), { clone: t.clone || a, setSource: o })), { clear: s, commit: u } = i; function l() { h(), u() } function d(y) { f(), y && l() } function g(y) { let w = !1; const C = () => w = !0; c(() => { y(C) }), w || l() } function m() { n(), s() } return Ut(Et({}, i), { isTracking: r, pause: b, resume: d, commit: l, batch: g, dispose: m }) } const Wc = { multiple: !0, accept: "*", reset: !1, directory: !1 }; function Yc(e = {}) { const { document: t = Lc } = e, a = dt(null), { on: p, trigger: v } = gc(); let _; t && (_ = t.createElement("input"), _.type = "file", _.onchange = r => { const c = r.target; a.value = c.files, v(a.value) }); const b = () => { a.value = null, _ && (_.value = "") }, f = r => { if (!_) return; const c = Et(Et(Et({}, Wc), e), r); _.multiple = c.multiple, _.accept = c.accept, _.webkitdirectory = c.directory, yc(c, "capture") && (_.capture = c.capture), c.reset && b(), _.click() }; return { files: ze(a), open: f, reset: b, onChange: p } } function Gc(e, t = {}) { const a = Sc(e), { threshold: p = 50, onSwipe: v, onSwipeEnd: _, onSwipeStart: b } = t, f = ee({ x: 0, y: 0 }), r = (C, T) => { f.x = C, f.y = T }, c = ee({ x: 0, y: 0 }), h = (C, T) => { c.x = C, c.y = T }, n = Wt(() => f.x - c.x), o = Wt(() => f.y - c.y), { max: i, abs: s } = Math, u = Wt(() => i(s(n.value), s(o.value)) >= p), l = dt(!1), d = dt(!1), g = Wt(() => u.value ? s(n.value) > s(o.value) ? n.value > 0 ? "left" : "right" : o.value > 0 ? "up" : "down" : "none"), m = C => { var T, A, U; const R = C.buttons === 0, $ = C.buttons === 1; return (U = (A = (T = t.pointerTypes) == null ? void 0 : T.includes(C.pointerType)) != null ? A : R || $) != null ? U : !0 }, y = [xn(e, "pointerdown", C => { var T, A; if (!m(C)) return; d.value = !0, (A = (T = a.value) == null ? void 0 : T.style) == null || A.setProperty("touch-action", "none"); const U = C.target; U == null || U.setPointerCapture(C.pointerId); const { clientX: R, clientY: $ } = C; r(R, $), h(R, $), b == null || b(C) }), xn(e, "pointermove", C => { if (!m(C) || !d.value) return; const { clientX: T, clientY: A } = C; h(T, A), !l.value && u.value && (l.value = !0), l.value && (v == null || v(C)) }), xn(e, "pointerup", C => { var T, A; m(C) && (l.value && (_ == null || _(C, g.value)), d.value = !1, l.value = !1, (A = (T = a.value) == null ? void 0 : T.style) == null || A.setProperty("touch-action", "initial")) })], w = () => y.forEach(C => C()); return { isSwiping: ze(l), direction: ze(g), posStart: ze(f), posEnd: ze(c), distanceX: n, distanceY: o, stop: w } } function li(e) { return Ic(e).promise.value } function Xc(e) { const t = ["arial", "Microsoft YaHei"], p = JSON.parse(e).objects.filter(v => v.type.includes("text") && !t.includes(v.fontFamily)).map(v => v.fontFamily).map(v => new Yo(v).load(null, 15e4)); return Promise.all(p) } function kn(e) { return new Promise(t => { const { onChange: a, open: p } = Yc(e); a(v => { t(v) }), p() }) } function Kc(e) { return new Promise(t => { const a = document.createElement("img"); a.src = e, document.body.appendChild(a), a.onload = () => { t(a) } }) } const qc = (e, t) => ie(void 0, null, function* () { try { yield Bc(Et({ source: e }, t)).copy(), qt.Message.success("Copied successfully") } catch (a) { throw qt.Message.error("Copy failed"), a } }); var Wn, Jc = new Uint8Array(16); function Zc() { if (!Wn && (Wn = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Wn)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return Wn(Jc) } const Qc = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; function tu(e) { return typeof e == "string" && Qc.test(e) } var re = []; for (var Pi = 0; Pi < 256; ++Pi)re.push((Pi + 256).toString(16).substr(1)); function eu(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a = (re[e[t + 0]] + re[e[t + 1]] + re[e[t + 2]] + re[e[t + 3]] + "-" + re[e[t + 4]] + re[e[t + 5]] + "-" + re[e[t + 6]] + re[e[t + 7]] + "-" + re[e[t + 8]] + re[e[t + 9]] + "-" + re[e[t + 10]] + re[e[t + 11]] + re[e[t + 12]] + re[e[t + 13]] + re[e[t + 14]] + re[e[t + 15]]).toLowerCase(); if (!tu(a)) throw TypeError("Stringified UUID is invalid"); return a } function Jt(e, t, a) { e = e || {}; var p = e.random || (e.rng || Zc)(); if (p[6] = p[6] & 15 | 64, p[8] = p[8] & 63 | 128, t) { a = a || 0; for (var v = 0; v < 16; ++v)t[a + v] = p[v]; return t } return eu(p) } const nu = { style: { display: "inline-block" } }, iu = { href: "javascript:void(0)" }, ru = Dt({ name: "ImportFile" }), su = Object.assign(ru, { setup(e) { const { fabric: t, canvasEditor: a } = zt(), p = ee({ showModal: !1, svgStr: "" }), v = { insertImg: function () { kn({ accept: "image/*", multiple: !0 }).then(r => { Array.from(r).forEach(c => { li(c).then(h => { b(h) }) }) }) }, insertSvg: function () { kn({ accept: ".svg", multiple: !0 }).then(r => { Array.from(r).forEach(c => { li(c).then(h => { f(h) }) }) }) }, insertSvgStrModal: function () { p.svgStr = "", p.showModal = !0 }, insertSvgStr: function () { t.loadSVGFromString(p.svgStr, (r, c) => { const h = t.util.groupSVGElements(r, Ut(Et({}, c), { name: "defaultSVG", id: Jt() })); a.canvas.add(h).centerObject(h).renderAll() }) } }, _ = r => { const c = v[r]; c && typeof c == "function" && c() }; function b(r) { if (!r) throw new Error("file is undefined"); const c = document.createElement("img"); c.src = r, document.body.appendChild(c), c.onload = () => { const h = new t.Image(c, { id: Jt(), name: "图片1", left: 100, top: 100 }); a.canvas.add(h), a.canvas.setActiveObject(h), a.canvas.renderAll(), c.remove() } } function f(r) { if (!r) throw new Error("file is undefined"); t.loadSVGFromURL(r, (c, h) => { const n = t.util.groupSVGElements(c, Ut(Et({}, h), { name: "defaultSVG", id: Jt() })); a.canvas.add(n).centerObject(n).renderAll() }) } return (r, c) => { const h = ut("Icon"), n = ut("DropdownItem"), o = ut("DropdownMenu"), i = ut("Dropdown"), s = ut("Input"), u = ut("Modal"); return lt(), mt("div", nu, [I(i, { "transfer-class-name": "fix", onOnClick: _ }, { list: G(() => [I(o, null, { default: G(() => [I(n, { name: "insertImg" }, { default: G(() => [xt(yt(r.$t("insertFile.upload_image")), 1)]), _: 1 }), I(n, { name: "insertSvg" }, { default: G(() => [xt(yt(r.$t("insertFile.insert_SVG")), 1)]), _: 1 }), I(n, { name: "insertSvgStrModal" }, { default: G(() => [xt(yt(r.$t("insertFile.insert_SVGStr")), 1)]), _: 1 })]), _: 1 })]), default: G(() => [S("a", iu, [xt(yt(r.$t("insertFile.insert")) + " ", 1), I(h, { type: "ios-arrow-down" })])]), _: 1 }), I(u, { modelValue: j(p).showModal, "onUpdate:modelValue": c[1] || (c[1] = l => j(p).showModal = l), title: r.$t("insertFile.modal_tittle"), onOnOk: c[2] || (c[2] = l => _("insertSvgStr")), onOnCancel: c[3] || (c[3] = l => r.showModal = !1) }, { default: G(() => [I(s, { modelValue: j(p).svgStr, "onUpdate:modelValue": c[0] || (c[0] = l => j(p).svgStr = l), "show-word-limit": "", type: "textarea", placeholder: r.$t("insertFile.insert_SVGStr_placeholder") }, null, 8, ["modelValue", "placeholder"])]), _: 1 }, 8, ["modelValue", "title"])]) } } }), ou = Yt(su, [["__scopeId", "data-v-b9ba45ec"]]); function Qo(e, t) { return function () { return e.apply(t, arguments) } } const { toString: au } = Object.prototype, { getPrototypeOf: Ar } = Object, gi = (e => t => { const a = au.call(t); return e[a] || (e[a] = a.slice(8, -1).toLowerCase()) })(Object.create(null)), Ae = e => (e = e.toLowerCase(), t => gi(t) === e), mi = e => t => typeof t === e, { isArray: hn } = Array, An = mi("undefined"); function lu(e) { return e !== null && !An(e) && e.constructor !== null && !An(e.constructor) && ge(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const ta = Ae("ArrayBuffer"); function cu(e) { let t; return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && ta(e.buffer), t } const uu = mi("string"), ge = mi("function"), ea = mi("number"), vi = e => e !== null && typeof e == "object", hu = e => e === !0 || e === !1, Jn = e => { if (gi(e) !== "object") return !1; const t = Ar(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }, fu = Ae("Date"), du = Ae("File"), pu = Ae("Blob"), gu = Ae("FileList"), mu = e => vi(e) && ge(e.pipe), vu = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || ge(e.append) && ((t = gi(e)) === "formdata" || t === "object" && ge(e.toString) && e.toString() === "[object FormData]")) }, _u = Ae("URLSearchParams"), yu = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Bn(e, t, { allOwnKeys: a = !1 } = {}) { if (e === null || typeof e == "undefined") return; let p, v; if (typeof e != "object" && (e = [e]), hn(e)) for (p = 0, v = e.length; p < v; p++)t.call(null, e[p], p, e); else { const _ = a ? Object.getOwnPropertyNames(e) : Object.keys(e), b = _.length; let f; for (p = 0; p < b; p++)f = _[p], t.call(null, e[f], f, e) } } function na(e, t) { t = t.toLowerCase(); const a = Object.keys(e); let p = a.length, v; for (; p-- > 0;)if (v = a[p], t === v.toLowerCase()) return v; return null } const ia = (() => typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : global)(), ra = e => !An(e) && e !== ia; function Zi() { const { caseless: e } = ra(this) && this || {}, t = {}, a = (p, v) => { const _ = e && na(t, v) || v; Jn(t[_]) && Jn(p) ? t[_] = Zi(t[_], p) : Jn(p) ? t[_] = Zi({}, p) : hn(p) ? t[_] = p.slice() : t[_] = p }; for (let p = 0, v = arguments.length; p < v; p++)arguments[p] && Bn(arguments[p], a); return t } const bu = (e, t, a, { allOwnKeys: p } = {}) => (Bn(t, (v, _) => { a && ge(v) ? e[_] = Qo(v, a) : e[_] = v }, { allOwnKeys: p }), e), wu = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Cu = (e, t, a, p) => { e.prototype = Object.create(t.prototype, p), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), a && Object.assign(e.prototype, a) }, Su = (e, t, a, p) => { let v, _, b; const f = {}; if (t = t || {}, e == null) return t; do { for (v = Object.getOwnPropertyNames(e), _ = v.length; _-- > 0;)b = v[_], (!p || p(b, e, t)) && !f[b] && (t[b] = e[b], f[b] = !0); e = a !== !1 && Ar(e) } while (e && (!a || a(e, t)) && e !== Object.prototype); return t }, xu = (e, t, a) => { e = String(e), (a === void 0 || a > e.length) && (a = e.length), a -= t.length; const p = e.indexOf(t, a); return p !== -1 && p === a }, Tu = e => { if (!e) return null; if (hn(e)) return e; let t = e.length; if (!ea(t)) return null; const a = new Array(t); for (; t-- > 0;)a[t] = e[t]; return a }, Ou = (e => t => e && t instanceof e)(typeof Uint8Array != "undefined" && Ar(Uint8Array)), ku = (e, t) => { const p = (e && e[Symbol.iterator]).call(e); let v; for (; (v = p.next()) && !v.done;) { const _ = v.value; t.call(e, _[0], _[1]) } }, Au = (e, t) => { let a; const p = []; for (; (a = e.exec(t)) !== null;)p.push(a); return p }, Eu = Ae("HTMLFormElement"), Pu = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (a, p, v) { return p.toUpperCase() + v }), fs = (({ hasOwnProperty: e }) => (t, a) => e.call(t, a))(Object.prototype), Mu = Ae("RegExp"), sa = (e, t) => { const a = Object.getOwnPropertyDescriptors(e), p = {}; Bn(a, (v, _) => { let b; (b = t(v, _, e)) !== !1 && (p[_] = b || v) }), Object.defineProperties(e, p) }, ju = e => { sa(e, (t, a) => { if (ge(e) && ["arguments", "caller", "callee"].indexOf(a) !== -1) return !1; const p = e[a]; if (ge(p)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + a + "'") }) } }) }, Du = (e, t) => { const a = {}, p = v => { v.forEach(_ => { a[_] = !0 }) }; return hn(e) ? p(e) : p(String(e).split(t)), a }, Lu = () => { }, Fu = (e, t) => (e = +e, Number.isFinite(e) ? e : t), Mi = "abcdefghijklmnopqrstuvwxyz", ds = "0123456789", oa = { DIGIT: ds, ALPHA: Mi, ALPHA_DIGIT: Mi + Mi.toUpperCase() + ds }, $u = (e = 16, t = oa.ALPHA_DIGIT) => { let a = ""; const { length: p } = t; for (; e--;)a += t[Math.random() * p | 0]; return a }; function Iu(e) { return !!(e && ge(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]) } const Ru = e => { const t = new Array(10), a = (p, v) => { if (vi(p)) { if (t.indexOf(p) >= 0) return; if (!("toJSON" in p)) { t[v] = p; const _ = hn(p) ? [] : {}; return Bn(p, (b, f) => { const r = a(b, v + 1); !An(r) && (_[f] = r) }), t[v] = void 0, _ } } return p }; return a(e, 0) }, Bu = Ae("AsyncFunction"), zu = e => e && (vi(e) || ge(e)) && ge(e.then) && ge(e.catch), rt = { isArray: hn, isArrayBuffer: ta, isBuffer: lu, isFormData: vu, isArrayBufferView: cu, isString: uu, isNumber: ea, isBoolean: hu, isObject: vi, isPlainObject: Jn, isUndefined: An, isDate: fu, isFile: du, isBlob: pu, isRegExp: Mu, isFunction: ge, isStream: mu, isURLSearchParams: _u, isTypedArray: Ou, isFileList: gu, forEach: Bn, merge: Zi, extend: bu, trim: yu, stripBOM: wu, inherits: Cu, toFlatObject: Su, kindOf: gi, kindOfTest: Ae, endsWith: xu, toArray: Tu, forEachEntry: ku, matchAll: Au, isHTMLForm: Eu, hasOwnProperty: fs, hasOwnProp: fs, reduceDescriptors: sa, freezeMethods: ju, toObjectSet: Du, toCamelCase: Pu, noop: Lu, toFiniteNumber: Fu, findKey: na, global: ia, isContextDefined: ra, ALPHABET: oa, generateString: $u, isSpecCompliantForm: Iu, toJSONObject: Ru, isAsyncFn: Bu, isThenable: zu }; function Lt(e, t, a, p, v) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), a && (this.config = a), p && (this.request = p), v && (this.response = v) } rt.inherits(Lt, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: rt.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const aa = Lt.prototype, la = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { la[e] = { value: e } }); Object.defineProperties(Lt, la); Object.defineProperty(aa, "isAxiosError", { value: !0 }); Lt.from = (e, t, a, p, v, _) => { const b = Object.create(aa); return rt.toFlatObject(e, b, function (r) { return r !== Error.prototype }, f => f !== "isAxiosError"), Lt.call(b, e.message, t, a, p, v), b.cause = e, b.name = e.name, _ && Object.assign(b, _), b }; const Uu = null; function Qi(e) { return rt.isPlainObject(e) || rt.isArray(e) } function ca(e) { return rt.endsWith(e, "[]") ? e.slice(0, -2) : e } function ps(e, t, a) { return e ? e.concat(t).map(function (v, _) { return v = ca(v), !a && _ ? "[" + v + "]" : v }).join(a ? "." : "") : t } function Hu(e) { return rt.isArray(e) && !e.some(Qi) } const Vu = rt.toFlatObject(rt, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function _i(e, t, a) { if (!rt.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, a = rt.toFlatObject(a, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (u, l) { return !rt.isUndefined(l[u]) }); const p = a.metaTokens, v = a.visitor || h, _ = a.dots, b = a.indexes, r = (a.Blob || typeof Blob != "undefined" && Blob) && rt.isSpecCompliantForm(t); if (!rt.isFunction(v)) throw new TypeError("visitor must be a function"); function c(s) { if (s === null) return ""; if (rt.isDate(s)) return s.toISOString(); if (!r && rt.isBlob(s)) throw new Lt("Blob is not supported. Use a Buffer instead."); return rt.isArrayBuffer(s) || rt.isTypedArray(s) ? r && typeof Blob == "function" ? new Blob([s]) : Buffer.from(s) : s } function h(s, u, l) { let d = s; if (s && !l && typeof s == "object") { if (rt.endsWith(u, "{}")) u = p ? u : u.slice(0, -2), s = JSON.stringify(s); else if (rt.isArray(s) && Hu(s) || (rt.isFileList(s) || rt.endsWith(u, "[]")) && (d = rt.toArray(s))) return u = ca(u), d.forEach(function (m, y) { !(rt.isUndefined(m) || m === null) && t.append(b === !0 ? ps([u], y, _) : b === null ? u : u + "[]", c(m)) }), !1 } return Qi(s) ? !0 : (t.append(ps(l, u, _), c(s)), !1) } const n = [], o = Object.assign(Vu, { defaultVisitor: h, convertValue: c, isVisitable: Qi }); function i(s, u) { if (!rt.isUndefined(s)) { if (n.indexOf(s) !== -1) throw Error("Circular reference detected in " + u.join(".")); n.push(s), rt.forEach(s, function (d, g) { (!(rt.isUndefined(d) || d === null) && v.call(t, d, rt.isString(g) ? g.trim() : g, u, o)) === !0 && i(d, u ? u.concat(g) : [g]) }), n.pop() } } if (!rt.isObject(e)) throw new TypeError("data must be an object"); return i(e), t } function gs(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (p) { return t[p] }) } function Er(e, t) { this._pairs = [], e && _i(e, this, t) } const ua = Er.prototype; ua.append = function (t, a) { this._pairs.push([t, a]) }; ua.toString = function (t) { const a = t ? function (p) { return t.call(this, p, gs) } : gs; return this._pairs.map(function (v) { return a(v[0]) + "=" + a(v[1]) }, "").join("&") }; function Nu(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function ha(e, t, a) { if (!t) return e; const p = a && a.encode || Nu, v = a && a.serialize; let _; if (v ? _ = v(t, a) : _ = rt.isURLSearchParams(t) ? t.toString() : new Er(t, a).toString(p), _) { const b = e.indexOf("#"); b !== -1 && (e = e.slice(0, b)), e += (e.indexOf("?") === -1 ? "?" : "&") + _ } return e } class Wu { constructor() { this.handlers = [] } use(t, a, p) { return this.handlers.push({ fulfilled: t, rejected: a, synchronous: p ? p.synchronous : !1, runWhen: p ? p.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { rt.forEach(this.handlers, function (p) { p !== null && t(p) }) } } const ms = Wu, fa = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Yu = typeof URLSearchParams != "undefined" ? URLSearchParams : Er, Gu = typeof FormData != "undefined" ? FormData : null, Xu = typeof Blob != "undefined" ? Blob : null, Ku = { isBrowser: !0, classes: { URLSearchParams: Yu, FormData: Gu, Blob: Xu }, protocols: ["http", "https", "file", "blob", "url", "data"] }, da = typeof window != "undefined" && typeof document != "undefined", qu = (e => da && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator != "undefined" && navigator.product), Ju = (() => typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Zu = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: da, hasStandardBrowserEnv: qu, hasStandardBrowserWebWorkerEnv: Ju }, Symbol.toStringTag, { value: "Module" })), xe = Et(Et({}, Zu), Ku); function Qu(e, t) { return _i(e, new xe.classes.URLSearchParams, Object.assign({ visitor: function (a, p, v, _) { return xe.isNode && rt.isBuffer(a) ? (this.append(p, a.toString("base64")), !1) : _.defaultVisitor.apply(this, arguments) } }, t)) } function th(e) { return rt.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function eh(e) { const t = {}, a = Object.keys(e); let p; const v = a.length; let _; for (p = 0; p < v; p++)_ = a[p], t[_] = e[_]; return t } function pa(e) { function t(a, p, v, _) { let b = a[_++]; const f = Number.isFinite(+b), r = _ >= a.length; return b = !b && rt.isArray(v) ? v.length : b, r ? (rt.hasOwnProp(v, b) ? v[b] = [v[b], p] : v[b] = p, !f) : ((!v[b] || !rt.isObject(v[b])) && (v[b] = []), t(a, p, v[b], _) && rt.isArray(v[b]) && (v[b] = eh(v[b])), !f) } if (rt.isFormData(e) && rt.isFunction(e.entries)) { const a = {}; return rt.forEachEntry(e, (p, v) => { t(th(p), v, a, 0) }), a } return null } function nh(e, t, a) { if (rt.isString(e)) try { return (t || JSON.parse)(e), rt.trim(e) } catch (p) { if (p.name !== "SyntaxError") throw p } return (a || JSON.stringify)(e) } const Pr = { transitional: fa, adapter: ["xhr", "http"], transformRequest: [function (t, a) { const p = a.getContentType() || "", v = p.indexOf("application/json") > -1, _ = rt.isObject(t); if (_ && rt.isHTMLForm(t) && (t = new FormData(t)), rt.isFormData(t)) return v && v ? JSON.stringify(pa(t)) : t; if (rt.isArrayBuffer(t) || rt.isBuffer(t) || rt.isStream(t) || rt.isFile(t) || rt.isBlob(t)) return t; if (rt.isArrayBufferView(t)) return t.buffer; if (rt.isURLSearchParams(t)) return a.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let f; if (_) { if (p.indexOf("application/x-www-form-urlencoded") > -1) return Qu(t, this.formSerializer).toString(); if ((f = rt.isFileList(t)) || p.indexOf("multipart/form-data") > -1) { const r = this.env && this.env.FormData; return _i(f ? { "files[]": t } : t, r && new r, this.formSerializer) } } return _ || v ? (a.setContentType("application/json", !1), nh(t)) : t }], transformResponse: [function (t) { const a = this.transitional || Pr.transitional, p = a && a.forcedJSONParsing, v = this.responseType === "json"; if (t && rt.isString(t) && (p && !this.responseType || v)) { const b = !(a && a.silentJSONParsing) && v; try { return JSON.parse(t) } catch (f) { if (b) throw f.name === "SyntaxError" ? Lt.from(f, Lt.ERR_BAD_RESPONSE, this, null, this.response) : f } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: xe.classes.FormData, Blob: xe.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; rt.forEach(["delete", "get", "head", "post", "put", "patch"], e => { Pr.headers[e] = {} }); const Mr = Pr, ih = rt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), rh = e => {
	const t = {}; let a, p, v; return e && e.split(`
`).forEach(function (b) { v = b.indexOf(":"), a = b.substring(0, v).trim().toLowerCase(), p = b.substring(v + 1).trim(), !(!a || t[a] && ih[a]) && (a === "set-cookie" ? t[a] ? t[a].push(p) : t[a] = [p] : t[a] = t[a] ? t[a] + ", " + p : p) }), t
}, vs = Symbol("internals"); function bn(e) { return e && String(e).trim().toLowerCase() } function Zn(e) { return e === !1 || e == null ? e : rt.isArray(e) ? e.map(Zn) : String(e) } function sh(e) { const t = Object.create(null), a = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let p; for (; p = a.exec(e);)t[p[1]] = p[2]; return t } const oh = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function ji(e, t, a, p, v) { if (rt.isFunction(p)) return p.call(this, t, a); if (v && (t = a), !!rt.isString(t)) { if (rt.isString(p)) return t.indexOf(p) !== -1; if (rt.isRegExp(p)) return p.test(t) } } function ah(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, a, p) => a.toUpperCase() + p) } function lh(e, t) { const a = rt.toCamelCase(" " + t);["get", "set", "has"].forEach(p => { Object.defineProperty(e, p + a, { value: function (v, _, b) { return this[p].call(this, t, v, _, b) }, configurable: !0 }) }) } class yi {
	constructor(t) { t && this.set(t) } set(t, a, p) { const v = this; function _(f, r, c) { const h = bn(r); if (!h) throw new Error("header name must be a non-empty string"); const n = rt.findKey(v, h); (!n || v[n] === void 0 || c === !0 || c === void 0 && v[n] !== !1) && (v[n || r] = Zn(f)) } const b = (f, r) => rt.forEach(f, (c, h) => _(c, h, r)); return rt.isPlainObject(t) || t instanceof this.constructor ? b(t, a) : rt.isString(t) && (t = t.trim()) && !oh(t) ? b(rh(t), a) : t != null && _(a, t, p), this } get(t, a) { if (t = bn(t), t) { const p = rt.findKey(this, t); if (p) { const v = this[p]; if (!a) return v; if (a === !0) return sh(v); if (rt.isFunction(a)) return a.call(this, v, p); if (rt.isRegExp(a)) return a.exec(v); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, a) { if (t = bn(t), t) { const p = rt.findKey(this, t); return !!(p && this[p] !== void 0 && (!a || ji(this, this[p], p, a))) } return !1 } delete(t, a) { const p = this; let v = !1; function _(b) { if (b = bn(b), b) { const f = rt.findKey(p, b); f && (!a || ji(p, p[f], f, a)) && (delete p[f], v = !0) } } return rt.isArray(t) ? t.forEach(_) : _(t), v } clear(t) { const a = Object.keys(this); let p = a.length, v = !1; for (; p--;) { const _ = a[p]; (!t || ji(this, this[_], _, t, !0)) && (delete this[_], v = !0) } return v } normalize(t) { const a = this, p = {}; return rt.forEach(this, (v, _) => { const b = rt.findKey(p, _); if (b) { a[b] = Zn(v), delete a[_]; return } const f = t ? ah(_) : String(_).trim(); f !== _ && delete a[_], a[f] = Zn(v), p[f] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const a = Object.create(null); return rt.forEach(this, (p, v) => { p != null && p !== !1 && (a[v] = t && rt.isArray(p) ? p.join(", ") : p) }), a } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
		return Object.entries(this.toJSON()).map(([t, a]) => t + ": " + a).join(`
`)
	} get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...a) { const p = new this(t); return a.forEach(v => p.set(v)), p } static accessor(t) { const p = (this[vs] = this[vs] = { accessors: {} }).accessors, v = this.prototype; function _(b) { const f = bn(b); p[f] || (lh(v, b), p[f] = !0) } return rt.isArray(t) ? t.forEach(_) : _(t), this }
} yi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); rt.reduceDescriptors(yi.prototype, ({ value: e }, t) => { let a = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(p) { this[a] = p } } }); rt.freezeMethods(yi); const je = yi; function Di(e, t) { const a = this || Mr, p = t || a, v = je.from(p.headers); let _ = p.data; return rt.forEach(e, function (f) { _ = f.call(a, _, v.normalize(), t ? t.status : void 0) }), v.normalize(), _ } function ga(e) { return !!(e && e.__CANCEL__) } function zn(e, t, a) { Lt.call(this, e == null ? "canceled" : e, Lt.ERR_CANCELED, t, a), this.name = "CanceledError" } rt.inherits(zn, Lt, { __CANCEL__: !0 }); function ch(e, t, a) { const p = a.config.validateStatus; !a.status || !p || p(a.status) ? e(a) : t(new Lt("Request failed with status code " + a.status, [Lt.ERR_BAD_REQUEST, Lt.ERR_BAD_RESPONSE][Math.floor(a.status / 100) - 4], a.config, a.request, a)) } const uh = xe.hasStandardBrowserEnv ? { write(e, t, a, p, v, _) { const b = [e + "=" + encodeURIComponent(t)]; rt.isNumber(a) && b.push("expires=" + new Date(a).toGMTString()), rt.isString(p) && b.push("path=" + p), rt.isString(v) && b.push("domain=" + v), _ === !0 && b.push("secure"), document.cookie = b.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function hh(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function fh(e, t) { return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e } function ma(e, t) { return e && !hh(t) ? fh(e, t) : t } const dh = xe.hasStandardBrowserEnv ? function () { const t = /(msie|trident)/i.test(navigator.userAgent), a = document.createElement("a"); let p; function v(_) { let b = _; return t && (a.setAttribute("href", b), b = a.href), a.setAttribute("href", b), { href: a.href, protocol: a.protocol ? a.protocol.replace(/:$/, "") : "", host: a.host, search: a.search ? a.search.replace(/^\?/, "") : "", hash: a.hash ? a.hash.replace(/^#/, "") : "", hostname: a.hostname, port: a.port, pathname: a.pathname.charAt(0) === "/" ? a.pathname : "/" + a.pathname } } return p = v(window.location.href), function (b) { const f = rt.isString(b) ? v(b) : b; return f.protocol === p.protocol && f.host === p.host } }() : function () { return function () { return !0 } }(); function ph(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function gh(e, t) { e = e || 10; const a = new Array(e), p = new Array(e); let v = 0, _ = 0, b; return t = t !== void 0 ? t : 1e3, function (r) { const c = Date.now(), h = p[_]; b || (b = c), a[v] = r, p[v] = c; let n = _, o = 0; for (; n !== v;)o += a[n++], n = n % e; if (v = (v + 1) % e, v === _ && (_ = (_ + 1) % e), c - b < t) return; const i = h && c - h; return i ? Math.round(o * 1e3 / i) : void 0 } } function _s(e, t) { let a = 0; const p = gh(50, 250); return v => { const _ = v.loaded, b = v.lengthComputable ? v.total : void 0, f = _ - a, r = p(f), c = _ <= b; a = _; const h = { loaded: _, total: b, progress: b ? _ / b : void 0, bytes: f, rate: r || void 0, estimated: r && b && c ? (b - _) / r : void 0, event: v }; h[t ? "download" : "upload"] = !0, e(h) } } const mh = typeof XMLHttpRequest != "undefined", vh = mh && function (e) { return new Promise(function (a, p) { let v = e.data; const _ = je.from(e.headers).normalize(); let { responseType: b, withXSRFToken: f } = e, r; function c() { e.cancelToken && e.cancelToken.unsubscribe(r), e.signal && e.signal.removeEventListener("abort", r) } let h; if (rt.isFormData(v)) { if (xe.hasStandardBrowserEnv || xe.hasStandardBrowserWebWorkerEnv) _.setContentType(!1); else if ((h = _.getContentType()) !== !1) { const [u, ...l] = h ? h.split(";").map(d => d.trim()).filter(Boolean) : []; _.setContentType([u || "multipart/form-data", ...l].join("; ")) } } let n = new XMLHttpRequest; if (e.auth) { const u = e.auth.username || "", l = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; _.set("Authorization", "Basic " + btoa(u + ":" + l)) } const o = ma(e.baseURL, e.url); n.open(e.method.toUpperCase(), ha(o, e.params, e.paramsSerializer), !0), n.timeout = e.timeout; function i() { if (!n) return; const u = je.from("getAllResponseHeaders" in n && n.getAllResponseHeaders()), d = { data: !b || b === "text" || b === "json" ? n.responseText : n.response, status: n.status, statusText: n.statusText, headers: u, config: e, request: n }; ch(function (m) { a(m), c() }, function (m) { p(m), c() }, d), n = null } if ("onloadend" in n ? n.onloadend = i : n.onreadystatechange = function () { !n || n.readyState !== 4 || n.status === 0 && !(n.responseURL && n.responseURL.indexOf("file:") === 0) || setTimeout(i) }, n.onabort = function () { n && (p(new Lt("Request aborted", Lt.ECONNABORTED, e, n)), n = null) }, n.onerror = function () { p(new Lt("Network Error", Lt.ERR_NETWORK, e, n)), n = null }, n.ontimeout = function () { let l = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded"; const d = e.transitional || fa; e.timeoutErrorMessage && (l = e.timeoutErrorMessage), p(new Lt(l, d.clarifyTimeoutError ? Lt.ETIMEDOUT : Lt.ECONNABORTED, e, n)), n = null }, xe.hasStandardBrowserEnv && (f && rt.isFunction(f) && (f = f(e)), f || f !== !1 && dh(o))) { const u = e.xsrfHeaderName && e.xsrfCookieName && uh.read(e.xsrfCookieName); u && _.set(e.xsrfHeaderName, u) } v === void 0 && _.setContentType(null), "setRequestHeader" in n && rt.forEach(_.toJSON(), function (l, d) { n.setRequestHeader(d, l) }), rt.isUndefined(e.withCredentials) || (n.withCredentials = !!e.withCredentials), b && b !== "json" && (n.responseType = e.responseType), typeof e.onDownloadProgress == "function" && n.addEventListener("progress", _s(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && n.upload && n.upload.addEventListener("progress", _s(e.onUploadProgress)), (e.cancelToken || e.signal) && (r = u => { n && (p(!u || u.type ? new zn(null, e, n) : u), n.abort(), n = null) }, e.cancelToken && e.cancelToken.subscribe(r), e.signal && (e.signal.aborted ? r() : e.signal.addEventListener("abort", r))); const s = ph(o); if (s && xe.protocols.indexOf(s) === -1) { p(new Lt("Unsupported protocol " + s + ":", Lt.ERR_BAD_REQUEST, e)); return } n.send(v || null) }) }, tr = { http: Uu, xhr: vh }; rt.forEach(tr, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (a) { } Object.defineProperty(e, "adapterName", { value: t }) } }); const ys = e => `- ${e}`, _h = e => rt.isFunction(e) || e === null || e === !1, va = {
	getAdapter: e => {
		e = rt.isArray(e) ? e : [e]; const { length: t } = e; let a, p; const v = {}; for (let _ = 0; _ < t; _++) { a = e[_]; let b; if (p = a, !_h(a) && (p = tr[(b = String(a)).toLowerCase()], p === void 0)) throw new Lt(`Unknown adapter '${b}'`); if (p) break; v[b || "#" + _] = p } if (!p) {
			const _ = Object.entries(v).map(([f, r]) => `adapter ${f} ` + (r === !1 ? "is not supported by the environment" : "is not available in the build")); let b = t ? _.length > 1 ? `since :
`+ _.map(ys).join(`
`) : " " + ys(_[0]) : "as no adapter specified"; throw new Lt("There is no suitable adapter to dispatch the request " + b, "ERR_NOT_SUPPORT")
		} return p
	}, adapters: tr
}; function Li(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new zn(null, e) } function bs(e) { return Li(e), e.headers = je.from(e.headers), e.data = Di.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), va.getAdapter(e.adapter || Mr.adapter)(e).then(function (p) { return Li(e), p.data = Di.call(e, e.transformResponse, p), p.headers = je.from(p.headers), p }, function (p) { return ga(p) || (Li(e), p && p.response && (p.response.data = Di.call(e, e.transformResponse, p.response), p.response.headers = je.from(p.response.headers))), Promise.reject(p) }) } const ws = e => e instanceof je ? e.toJSON() : e; function on(e, t) { t = t || {}; const a = {}; function p(c, h, n) { return rt.isPlainObject(c) && rt.isPlainObject(h) ? rt.merge.call({ caseless: n }, c, h) : rt.isPlainObject(h) ? rt.merge({}, h) : rt.isArray(h) ? h.slice() : h } function v(c, h, n) { if (rt.isUndefined(h)) { if (!rt.isUndefined(c)) return p(void 0, c, n) } else return p(c, h, n) } function _(c, h) { if (!rt.isUndefined(h)) return p(void 0, h) } function b(c, h) { if (rt.isUndefined(h)) { if (!rt.isUndefined(c)) return p(void 0, c) } else return p(void 0, h) } function f(c, h, n) { if (n in t) return p(c, h); if (n in e) return p(void 0, c) } const r = { url: _, method: _, data: _, baseURL: b, transformRequest: b, transformResponse: b, paramsSerializer: b, timeout: b, timeoutMessage: b, withCredentials: b, withXSRFToken: b, adapter: b, responseType: b, xsrfCookieName: b, xsrfHeaderName: b, onUploadProgress: b, onDownloadProgress: b, decompress: b, maxContentLength: b, maxBodyLength: b, beforeRedirect: b, transport: b, httpAgent: b, httpsAgent: b, cancelToken: b, socketPath: b, responseEncoding: b, validateStatus: f, headers: (c, h) => v(ws(c), ws(h), !0) }; return rt.forEach(Object.keys(Object.assign({}, e, t)), function (h) { const n = r[h] || v, o = n(e[h], t[h], h); rt.isUndefined(o) && n !== f || (a[h] = o) }), a } const _a = "1.6.2", jr = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { jr[e] = function (p) { return typeof p === e || "a" + (t < 1 ? "n " : " ") + e } }); const Cs = {}; jr.transitional = function (t, a, p) { function v(_, b) { return "[Axios v" + _a + "] Transitional option '" + _ + "'" + b + (p ? ". " + p : "") } return (_, b, f) => { if (t === !1) throw new Lt(v(b, " has been removed" + (a ? " in " + a : "")), Lt.ERR_DEPRECATED); return a && !Cs[b] && (Cs[b] = !0, console.warn(v(b, " has been deprecated since v" + a + " and will be removed in the near future"))), t ? t(_, b, f) : !0 } }; function yh(e, t, a) { if (typeof e != "object") throw new Lt("options must be an object", Lt.ERR_BAD_OPTION_VALUE); const p = Object.keys(e); let v = p.length; for (; v-- > 0;) { const _ = p[v], b = t[_]; if (b) { const f = e[_], r = f === void 0 || b(f, _, e); if (r !== !0) throw new Lt("option " + _ + " must be " + r, Lt.ERR_BAD_OPTION_VALUE); continue } if (a !== !0) throw new Lt("Unknown option " + _, Lt.ERR_BAD_OPTION) } } const er = { assertOptions: yh, validators: jr }, Re = er.validators; class ci { constructor(t) { this.defaults = t, this.interceptors = { request: new ms, response: new ms } } request(t, a) { typeof t == "string" ? (a = a || {}, a.url = t) : a = t || {}, a = on(this.defaults, a); const { transitional: p, paramsSerializer: v, headers: _ } = a; p !== void 0 && er.assertOptions(p, { silentJSONParsing: Re.transitional(Re.boolean), forcedJSONParsing: Re.transitional(Re.boolean), clarifyTimeoutError: Re.transitional(Re.boolean) }, !1), v != null && (rt.isFunction(v) ? a.paramsSerializer = { serialize: v } : er.assertOptions(v, { encode: Re.function, serialize: Re.function }, !0)), a.method = (a.method || this.defaults.method || "get").toLowerCase(); let b = _ && rt.merge(_.common, _[a.method]); _ && rt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], s => { delete _[s] }), a.headers = je.concat(b, _); const f = []; let r = !0; this.interceptors.request.forEach(function (u) { typeof u.runWhen == "function" && u.runWhen(a) === !1 || (r = r && u.synchronous, f.unshift(u.fulfilled, u.rejected)) }); const c = []; this.interceptors.response.forEach(function (u) { c.push(u.fulfilled, u.rejected) }); let h, n = 0, o; if (!r) { const s = [bs.bind(this), void 0]; for (s.unshift.apply(s, f), s.push.apply(s, c), o = s.length, h = Promise.resolve(a); n < o;)h = h.then(s[n++], s[n++]); return h } o = f.length; let i = a; for (n = 0; n < o;) { const s = f[n++], u = f[n++]; try { i = s(i) } catch (l) { u.call(this, l); break } } try { h = bs.call(this, i) } catch (s) { return Promise.reject(s) } for (n = 0, o = c.length; n < o;)h = h.then(c[n++], c[n++]); return h } getUri(t) { t = on(this.defaults, t); const a = ma(t.baseURL, t.url); return ha(a, t.params, t.paramsSerializer) } } rt.forEach(["delete", "get", "head", "options"], function (t) { ci.prototype[t] = function (a, p) { return this.request(on(p || {}, { method: t, url: a, data: (p || {}).data })) } }); rt.forEach(["post", "put", "patch"], function (t) { function a(p) { return function (_, b, f) { return this.request(on(f || {}, { method: t, headers: p ? { "Content-Type": "multipart/form-data" } : {}, url: _, data: b })) } } ci.prototype[t] = a(), ci.prototype[t + "Form"] = a(!0) }); const Qn = ci; class Dr { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let a; this.promise = new Promise(function (_) { a = _ }); const p = this; this.promise.then(v => { if (!p._listeners) return; let _ = p._listeners.length; for (; _-- > 0;)p._listeners[_](v); p._listeners = null }), this.promise.then = v => { let _; const b = new Promise(f => { p.subscribe(f), _ = f }).then(v); return b.cancel = function () { p.unsubscribe(_) }, b }, t(function (_, b, f) { p.reason || (p.reason = new zn(_, b, f), a(p.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const a = this._listeners.indexOf(t); a !== -1 && this._listeners.splice(a, 1) } static source() { let t; return { token: new Dr(function (v) { t = v }), cancel: t } } } const bh = Dr; function wh(e) { return function (a) { return e.apply(null, a) } } function Ch(e) { return rt.isObject(e) && e.isAxiosError === !0 } const nr = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(nr).forEach(([e, t]) => { nr[t] = e }); const Sh = nr; function ya(e) { const t = new Qn(e), a = Qo(Qn.prototype.request, t); return rt.extend(a, Qn.prototype, t, { allOwnKeys: !0 }), rt.extend(a, t, null, { allOwnKeys: !0 }), a.create = function (v) { return ya(on(e, v)) }, a } const Qt = ya(Mr); Qt.Axios = Qn; Qt.CanceledError = zn; Qt.CancelToken = bh; Qt.isCancel = ga; Qt.VERSION = _a; Qt.toFormData = _i; Qt.AxiosError = Lt; Qt.Cancel = Qt.CanceledError; Qt.all = function (t) { return Promise.all(t) }; Qt.spread = wh; Qt.isAxiosError = Ch; Qt.mergeConfig = on; Qt.AxiosHeaders = je; Qt.formToJSON = e => pa(rt.isHTMLForm(e) ? new FormData(e) : e); Qt.getAdapter = va.getAdapter; Qt.HttpStatusCode = Sh; Qt.default = Qt; const Te = Qt; const xh = { style: { display: "inline-block" } }, Th = ["alt", "onClick"], Oh = { __name: "fontTmpl", setup(e) { const t = "https://nihaojob.github.io/vue-fabric-editor-static/", { fabric: a, canvasEditor: p } = zt(), { t: v } = Ke(), _ = [{ label: "Font", tempUrl: `${t}font-tmpl/1.json`, src: `${t}font-tmpl/1.png` }, { label: "Font", tempUrl: `${t}font-tmpl/2.json`, src: `${t}font-tmpl/2.png` }, { label: "Font", tempUrl: `${t}font-tmpl/3.json`, src: `${t}font-tmpl/3.png` }, { label: "Font", tempUrl: `${t}font-tmpl/4.json`, src: `${t}font-tmpl/4.png` }, { label: "Font", tempUrl: `${t}font-tmpl/5.json`, src: `${t}font-tmpl/5.png` }], b = r => { qt.Spin.show({ render: h => h("div", v("alert.loading_fonts")) }); const c = JSON.parse(r); c.id = Jt(), new a.Textbox.fromObject(c, h => { p.canvas.add(h), h.center(), p.canvas.setActiveObject(h), qt.Spin.hide() }) }, f = r => { qt.Spin.show({ render: h => h("div", v("alert.loading_data")) }), Te.get(r).then(h => { b(JSON.stringify(h.data)) }) }; return (r, c) => { const h = ut("Divider"), n = ut("Tooltip"), o = pi("lazy"); return lt(), mt("div", xh, [I(h, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(r.$t("title_template")), 1)]), _: 1 }), (lt(), mt(te, null, ce(_, (i, s) => I(n, { content: i.label, key: `${s}-bai1-button`, placement: "top" }, { default: G(() => [Ct(S("img", { class: "tmpl-img", alt: i.label, onClick: u => f(i.tempUrl) }, null, 8, Th), [[o, i.src]])]), _: 2 }, 1032, ["content"])), 64))]) } } }, kh = Yt(Oh, [["__scopeId", "data-v-cf650c3e"]]), Ot = ee({ front: "", back: "", frontImgUrl: "", backImgUrl: "", position: "", userId: "", productId: "", templateHeight: "", templateWidth: "", frontUrl: "", backUrl: "", backExsist: "", role: "" }), ba = () => { qt.Spin.show({ render: e => e("div", "Loading Template") }), Ot.userId !== "" && Te.get(`https://vista.simboz.website/api/template/showUserTemp/${Ot.productId}/${Ot.userId}`).then(e => { const { data: t } = e.data; if (t) { const { front: a, back: p, backImgUrl: v, frontImgUrl: _, position: b } = t; a != null && (Ot.front = a), p != null && (Ot.back = p), v != null && (Ot.backImgUrl = v), _ != null && (Ot.frontImgUrl = _), b != null && (Ot.position = b) } qt.Spin.hide() }).catch(e => { console.error("Error fetching data:", e), qt.Spin.hide() }) }; de(() => Ot.userId, () => { ba() }); ba(); const wa = e => (me("data-v-64b2ee91"), e = e(), ve(), e), Ah = { class: "preview-image" }, Eh = { class: "image-frame" }, Ph = ["src"], Mh = wa(() => S("div", { class: "frontButton" }, [S("p", null, "Front")], -1)), jh = { class: "image-frame" }, Dh = ["src"], Lh = wa(() => S("div", { class: "frontButton" }, [S("p", null, "Back")], -1)), Fh = Dt({ name: "userTemplate" }), $h = Dt(Ut(Et({}, Fh), { setup(e) { const { canvasEditor: t } = zt(), a = dt(null), p = dt(null), v = dt(null), _ = dt(null), b = Or(), f = Wt(() => b.state.back), r = dt(!1); ue(() => ie(this, null, function* () { try { yield b.dispatch("fetchDataFromLaravel"), r.value = f.value, console.log("fdsds", r.value) } catch (o) { console.error("Error fetching data from Laravel:", o) } })); const h = o => ie(this, null, function* () { o === "front" && t.toggleTemplate(o), o === "back" && t.toggleTemplate(o) }), n = () => { Ot.front && (v.value = Ot.back, p.value = Ot.frontImgUrl, _.value = Ot.backImgUrl, a.value = Ot.front) }; return de(Ot, o => { n() }), (o, i) => (lt(), mt("div", Ah, [S("div", { class: "section", onClick: i[0] || (i[0] = s => h("front")) }, [S("div", Eh, [S("img", { id: "image", src: p.value }, null, 8, Ph)]), Mh]), S("div", { class: "section", onClick: i[1] || (i[1] = s => h("back")) }, [S("div", jh, [S("img", { id: "image", src: _.value }, null, 8, Dh)]), Lh])])) } })); const Ih = Yt($h, [["__scopeId", "data-v-64b2ee91"]]); var Q = {}; const Rh = {}, Bh = Object.freeze(Object.defineProperty({ __proto__: null, default: Rh }, Symbol.toStringTag, { value: "Module" })), Fi = cc(Bh); (function (e) {/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */var t = t || { version: "5.3.0" }; if (e.fabric = t, typeof document != "undefined" && typeof window != "undefined") document instanceof (typeof HTMLDocument != "undefined" ? HTMLDocument : Document) ? t.document = document : t.document = document.implementation.createHTMLDocument(""), t.window = window; else { var a = Fi, p = new a.JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), { features: { FetchExternalResources: ["img"] }, resources: "usable" }).window; t.document = p.document, t.jsdomImplForWrapper = Fi.implForWrapper, t.nodeCanvas = Fi.Canvas, t.window = p, DOMParser = t.window.DOMParser } t.isTouchSupported = "ontouchstart" in t.window || "ontouchstart" in t.document || t.window && t.window.navigator && t.window.navigator.maxTouchPoints > 0, t.isLikelyNode = typeof Buffer != "undefined" && typeof window == "undefined", t.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], t.DPI = 96, t.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", t.commaWsp = "(?:\\s+,?\\s*|,\\s*)", t.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig, t.reNonWord = /[ \n\.,;!\?\-]/, t.fontPaths = {}, t.iMatrix = [1, 0, 0, 1, 0, 0], t.svgNS = "http://www.w3.org/2000/svg", t.perfLimitSizeTotal = 2097152, t.maxCacheSideLimit = 4096, t.minCacheSideLimit = 256, t.charWidthsCache = {}, t.textureSize = 2048, t.disableStyleCopyPaste = !1, t.enableGLFiltering = !0, t.devicePixelRatio = t.window.devicePixelRatio || t.window.webkitDevicePixelRatio || t.window.mozDevicePixelRatio || 1, t.browserShadowBlurConstant = 1, t.arcToSegmentsCache = {}, t.boundsOfCurveCache = {}, t.cachesBoundsOfCurve = !0, t.forceGLPutImageData = !1, t.initFilterBackend = function () { if (t.enableGLFiltering && t.isWebglSupported && t.isWebglSupported(t.textureSize)) return console.log("max texture size: " + t.maxTextureSize), new t.WebglFilterBackend({ tileSize: t.textureSize }); if (t.Canvas2dFilterBackend) return new t.Canvas2dFilterBackend }, typeof document != "undefined" && typeof window != "undefined" && (window.fabric = t), function () { function f(i, s) { if (this.__eventListeners[i]) { var u = this.__eventListeners[i]; s ? u[u.indexOf(s)] = !1 : t.util.array.fill(u, !1) } } function r(i, s) { if (this.__eventListeners || (this.__eventListeners = {}), arguments.length === 1) for (var u in i) this.on(u, i[u]); else this.__eventListeners[i] || (this.__eventListeners[i] = []), this.__eventListeners[i].push(s); return this } function c(i, s) { var u = function () { s.apply(this, arguments), this.off(i, u) }.bind(this); this.on(i, u) } function h(i, s) { if (arguments.length === 1) for (var u in i) c.call(this, u, i[u]); else c.call(this, i, s); return this } function n(i, s) { if (!this.__eventListeners) return this; if (arguments.length === 0) for (i in this.__eventListeners) f.call(this, i); else if (arguments.length === 1 && typeof arguments[0] == "object") for (var u in i) f.call(this, u, i[u]); else f.call(this, i, s); return this } function o(i, s) { if (!this.__eventListeners) return this; var u = this.__eventListeners[i]; if (!u) return this; for (var l = 0, d = u.length; l < d; l++)u[l] && u[l].call(this, s || {}); return this.__eventListeners[i] = u.filter(function (g) { return g !== !1 }), this } t.Observable = { fire: o, on: r, once: h, off: n } }(), t.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var f = 0, r = arguments.length; f < r; f++)this._onObjectAdded(arguments[f]); return this.renderOnAddRemove && this.requestRenderAll(), this }, insertAt: function (f, r, c) { var h = this._objects; return c ? h[r] = f : h.splice(r, 0, f), this._onObjectAdded && this._onObjectAdded(f), this.renderOnAddRemove && this.requestRenderAll(), this }, remove: function () { for (var f = this._objects, r, c = !1, h = 0, n = arguments.length; h < n; h++)r = f.indexOf(arguments[h]), r !== -1 && (c = !0, f.splice(r, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[h])); return this.renderOnAddRemove && c && this.requestRenderAll(), this }, forEachObject: function (f, r) { for (var c = this.getObjects(), h = 0, n = c.length; h < n; h++)f.call(r, c[h], h, c); return this }, getObjects: function (f) { return typeof f == "undefined" ? this._objects.concat() : this._objects.filter(function (r) { return r.type === f }) }, item: function (f) { return this._objects[f] }, isEmpty: function () { return this._objects.length === 0 }, size: function () { return this._objects.length }, contains: function (f, r) { return this._objects.indexOf(f) > -1 ? !0 : r ? this._objects.some(function (c) { return typeof c.contains == "function" && c.contains(f, !0) }) : !1 }, complexity: function () { return this._objects.reduce(function (f, r) { return f += r.complexity ? r.complexity() : 0, f }, 0) } }, t.CommonMethods = { _setOptions: function (f) { for (var r in f) this.set(r, f[r]) }, _initGradient: function (f, r) { f && f.colorStops && !(f instanceof t.Gradient) && this.set(r, new t.Gradient(f)) }, _initPattern: function (f, r, c) { f && f.source && !(f instanceof t.Pattern) ? this.set(r, new t.Pattern(f, c)) : c && c() }, _setObject: function (f) { for (var r in f) this._set(r, f[r]) }, set: function (f, r) { return typeof f == "object" ? this._setObject(f) : this._set(f, r), this }, _set: function (f, r) { this[f] = r }, toggle: function (f) { var r = this.get(f); return typeof r == "boolean" && this.set(f, !r), this }, get: function (f) { return this[f] } }, function (f) {
	var r = Math.sqrt, c = Math.atan2, h = Math.pow, n = Math.PI / 180, o = Math.PI / 2; t.util = {
		cos: function (i) { if (i === 0) return 1; i < 0 && (i = -i); var s = i / o; switch (s) { case 1: case 3: return 0; case 2: return -1 }return Math.cos(i) }, sin: function (i) { if (i === 0) return 0; var s = i / o, u = 1; switch (i < 0 && (u = -1), s) { case 1: return u; case 2: return 0; case 3: return -u }return Math.sin(i) }, removeFromArray: function (i, s) { var u = i.indexOf(s); return u !== -1 && i.splice(u, 1), i }, getRandomInt: function (i, s) { return Math.floor(Math.random() * (s - i + 1)) + i }, degreesToRadians: function (i) { return i * n }, radiansToDegrees: function (i) { return i / n }, rotatePoint: function (i, s, u) { var l = new t.Point(i.x - s.x, i.y - s.y), d = t.util.rotateVector(l, u); return new t.Point(d.x, d.y).addEquals(s) }, rotateVector: function (i, s) { var u = t.util.sin(s), l = t.util.cos(s), d = i.x * l - i.y * u, g = i.x * u + i.y * l; return { x: d, y: g } }, createVector: function (i, s) { return new t.Point(s.x - i.x, s.y - i.y) }, calcAngleBetweenVectors: function (i, s) { return Math.acos((i.x * s.x + i.y * s.y) / (Math.hypot(i.x, i.y) * Math.hypot(s.x, s.y))) }, getHatVector: function (i) { return new t.Point(i.x, i.y).multiply(1 / Math.hypot(i.x, i.y)) }, getBisector: function (i, s, u) { var l = t.util.createVector(i, s), d = t.util.createVector(i, u), g = t.util.calcAngleBetweenVectors(l, d), m = t.util.calcAngleBetweenVectors(t.util.rotateVector(l, g), d), y = g * (m === 0 ? 1 : -1) / 2; return { vector: t.util.getHatVector(t.util.rotateVector(l, y)), angle: g } }, projectStrokeOnPoints: function (i, s, u) { var l = [], d = s.strokeWidth / 2, g = s.strokeUniform ? new t.Point(1 / s.scaleX, 1 / s.scaleY) : new t.Point(1, 1), m = function (y) { var w = d / Math.hypot(y.x, y.y); return new t.Point(y.x * w * g.x, y.y * w * g.y) }; return i.length <= 1 || i.forEach(function (y, w) { var C = new t.Point(y.x, y.y), T, A; w === 0 ? (A = i[w + 1], T = u ? m(t.util.createVector(A, C)).addEquals(C) : i[i.length - 1]) : w === i.length - 1 ? (T = i[w - 1], A = u ? m(t.util.createVector(T, C)).addEquals(C) : i[0]) : (T = i[w - 1], A = i[w + 1]); var U = t.util.getBisector(C, T, A), R = U.vector, $ = U.angle, L, B; if (s.strokeLineJoin === "miter" && (L = -d / Math.sin($ / 2), B = new t.Point(R.x * L * g.x, R.y * L * g.y), Math.hypot(B.x, B.y) / d <= s.strokeMiterLimit)) { l.push(C.add(B)), l.push(C.subtract(B)); return } L = -d * Math.SQRT2, B = new t.Point(R.x * L * g.x, R.y * L * g.y), l.push(C.add(B)), l.push(C.subtract(B)) }), l }, transformPoint: function (i, s, u) { return u ? new t.Point(s[0] * i.x + s[2] * i.y, s[1] * i.x + s[3] * i.y) : new t.Point(s[0] * i.x + s[2] * i.y + s[4], s[1] * i.x + s[3] * i.y + s[5]) }, makeBoundingBoxFromPoints: function (i, s) { if (s) for (var u = 0; u < i.length; u++)i[u] = t.util.transformPoint(i[u], s); var l = [i[0].x, i[1].x, i[2].x, i[3].x], d = t.util.array.min(l), g = t.util.array.max(l), m = g - d, y = [i[0].y, i[1].y, i[2].y, i[3].y], w = t.util.array.min(y), C = t.util.array.max(y), T = C - w; return { left: d, top: w, width: m, height: T } }, invertTransform: function (i) { var s = 1 / (i[0] * i[3] - i[1] * i[2]), u = [s * i[3], -s * i[1], -s * i[2], s * i[0]], l = t.util.transformPoint({ x: i[4], y: i[5] }, u, !0); return u[4] = -l.x, u[5] = -l.y, u }, toFixed: function (i, s) { return parseFloat(Number(i).toFixed(s)) }, parseUnit: function (i, s) { var u = /\D{0,2}$/.exec(i), l = parseFloat(i); switch (s || (s = t.Text.DEFAULT_SVG_FONT_SIZE), u[0]) { case "mm": return l * t.DPI / 25.4; case "cm": return l * t.DPI / 2.54; case "in": return l * t.DPI; case "pt": return l * t.DPI / 72; case "pc": return l * t.DPI / 72 * 12; case "em": return l * s; default: return l } }, falseFunction: function () { return !1 }, getKlass: function (i, s) { return i = t.util.string.camelize(i.charAt(0).toUpperCase() + i.slice(1)), t.util.resolveNamespace(s)[i] }, getSvgAttributes: function (i) { var s = ["instantiated_by_use", "style", "id", "class"]; switch (i) { case "linearGradient": s = s.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]); break; case "radialGradient": s = s.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]); break; case "stop": s = s.concat(["offset", "stop-color", "stop-opacity"]); break }return s }, resolveNamespace: function (i) { if (!i) return t; var s = i.split("."), u = s.length, l, d = f || t.window; for (l = 0; l < u; ++l)d = d[s[l]]; return d }, loadImage: function (i, s, u, l) { if (!i) { s && s.call(u, i); return } var d = t.util.createImage(), g = function () { s && s.call(u, d, !1), d = d.onload = d.onerror = null }; d.onload = g, d.onerror = function () { t.log("Error loading " + d.src), s && s.call(u, null, !0), d = d.onload = d.onerror = null }, i.indexOf("data") !== 0 && l !== void 0 && l !== null && (d.crossOrigin = l), i.substring(0, 14) === "data:image/svg" && (d.onload = null, t.util.loadImageInDom(d, g)), d.src = i }, loadImageInDom: function (i, s) { var u = t.document.createElement("div"); u.style.width = u.style.height = "1px", u.style.left = u.style.top = "-100%", u.style.position = "absolute", u.appendChild(i), t.document.querySelector("body").appendChild(u), i.onload = function () { s(), u.parentNode.removeChild(u), u = null } }, enlivenObjects: function (i, s, u, l) { i = i || []; var d = [], g = 0, m = i.length; function y() { ++g === m && s && s(d.filter(function (w) { return w })) } if (!m) { s && s(d); return } i.forEach(function (w, C) { if (!w || !w.type) { y(); return } var T = t.util.getKlass(w.type, u); T.fromObject(w, function (A, U) { U || (d[C] = A), l && l(w, A, U), y() }) }) }, enlivenObjectEnlivables: function (i, s, u) { var l = t.Object.ENLIVEN_PROPS.filter(function (d) { return !!i[d] }); t.util.enlivenObjects(l.map(function (d) { return i[d] }), function (d) { var g = {}; l.forEach(function (m, y) { g[m] = d[y], s && (s[m] = d[y]) }), u && u(g) }) }, enlivenPatterns: function (i, s) { i = i || []; function u() { ++d === g && s && s(l) } var l = [], d = 0, g = i.length; if (!g) { s && s(l); return } i.forEach(function (m, y) { m && m.source ? new t.Pattern(m, function (w) { l[y] = w, u() }) : (l[y] = m, u()) }) }, groupSVGElements: function (i, s, u) { var l; return i && i.length === 1 ? (typeof u != "undefined" && (i[0].sourcePath = u), i[0]) : (s && (s.width && s.height ? s.centerPoint = { x: s.width / 2, y: s.height / 2 } : (delete s.width, delete s.height)), l = new t.Group(i, s), typeof u != "undefined" && (l.sourcePath = u), l) }, populateWithProperties: function (i, s, u) { if (u && Array.isArray(u)) for (var l = 0, d = u.length; l < d; l++)u[l] in i && (s[u[l]] = i[u[l]]) }, createCanvasElement: function () { return t.document.createElement("canvas") }, copyCanvasElement: function (i) { var s = t.util.createCanvasElement(); return s.width = i.width, s.height = i.height, s.getContext("2d").drawImage(i, 0, 0), s }, toDataURL: function (i, s, u) { return i.toDataURL("image/" + s, u) }, createImage: function () { return t.document.createElement("img") }, multiplyTransformMatrices: function (i, s, u) { return [i[0] * s[0] + i[2] * s[1], i[1] * s[0] + i[3] * s[1], i[0] * s[2] + i[2] * s[3], i[1] * s[2] + i[3] * s[3], u ? 0 : i[0] * s[4] + i[2] * s[5] + i[4], u ? 0 : i[1] * s[4] + i[3] * s[5] + i[5]] }, qrDecompose: function (i) { var s = c(i[1], i[0]), u = h(i[0], 2) + h(i[1], 2), l = r(u), d = (i[0] * i[3] - i[2] * i[1]) / l, g = c(i[0] * i[2] + i[1] * i[3], u); return { angle: s / n, scaleX: l, scaleY: d, skewX: g / n, skewY: 0, translateX: i[4], translateY: i[5] } }, calcRotateMatrix: function (i) { if (!i.angle) return t.iMatrix.concat(); var s = t.util.degreesToRadians(i.angle), u = t.util.cos(s), l = t.util.sin(s); return [u, l, -l, u, 0, 0] }, calcDimensionsMatrix: function (i) { var s = typeof i.scaleX == "undefined" ? 1 : i.scaleX, u = typeof i.scaleY == "undefined" ? 1 : i.scaleY, l = [i.flipX ? -s : s, 0, 0, i.flipY ? -u : u, 0, 0], d = t.util.multiplyTransformMatrices, g = t.util.degreesToRadians; return i.skewX && (l = d(l, [1, 0, Math.tan(g(i.skewX)), 1], !0)), i.skewY && (l = d(l, [1, Math.tan(g(i.skewY)), 0, 1], !0)), l }, composeMatrix: function (i) { var s = [1, 0, 0, 1, i.translateX || 0, i.translateY || 0], u = t.util.multiplyTransformMatrices; return i.angle && (s = u(s, t.util.calcRotateMatrix(i))), (i.scaleX !== 1 || i.scaleY !== 1 || i.skewX || i.skewY || i.flipX || i.flipY) && (s = u(s, t.util.calcDimensionsMatrix(i))), s }, resetObjectTransform: function (i) { i.scaleX = 1, i.scaleY = 1, i.skewX = 0, i.skewY = 0, i.flipX = !1, i.flipY = !1, i.rotate(0) }, saveObjectTransform: function (i) { return { scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, angle: i.angle, left: i.left, flipX: i.flipX, flipY: i.flipY, top: i.top } }, isTransparent: function (i, s, u, l) { l > 0 && (s > l ? s -= l : s = 0, u > l ? u -= l : u = 0); var d = !0, g, m, y = i.getImageData(s, u, l * 2 || 1, l * 2 || 1), w = y.data.length; for (g = 3; g < w && (m = y.data[g], d = m <= 0, d !== !1); g += 4); return y = null, d }, parsePreserveAspectRatioAttribute: function (i) { var s = "meet", u = "Mid", l = "Mid", d = i.split(" "), g; return d && d.length && (s = d.pop(), s !== "meet" && s !== "slice" ? (g = s, s = "meet") : d.length && (g = d.pop())), u = g !== "none" ? g.slice(1, 4) : "none", l = g !== "none" ? g.slice(5, 8) : "none", { meetOrSlice: s, alignX: u, alignY: l } }, clearFabricFontCache: function (i) { i = (i || "").toLowerCase(), i ? t.charWidthsCache[i] && delete t.charWidthsCache[i] : t.charWidthsCache = {} }, limitDimsByArea: function (i, s) { var u = Math.sqrt(s * i), l = Math.floor(s / u); return { x: Math.floor(u), y: l } }, capValue: function (i, s, u) { return Math.max(i, Math.min(s, u)) }, findScaleToFit: function (i, s) { return Math.min(s.width / i.width, s.height / i.height) }, findScaleToCover: function (i, s) { return Math.max(s.width / i.width, s.height / i.height) }, matrixToSVG: function (i) { return "matrix(" + i.map(function (s) { return t.util.toFixed(s, t.Object.NUM_FRACTION_DIGITS) }).join(" ") + ")" }, removeTransformFromObject: function (i, s) { var u = t.util.invertTransform(s), l = t.util.multiplyTransformMatrices(u, i.calcOwnMatrix()); t.util.applyTransformToObject(i, l) }, addTransformToObject: function (i, s) { t.util.applyTransformToObject(i, t.util.multiplyTransformMatrices(s, i.calcOwnMatrix())) }, applyTransformToObject: function (i, s) { var u = t.util.qrDecompose(s), l = new t.Point(u.translateX, u.translateY); i.flipX = !1, i.flipY = !1, i.set("scaleX", u.scaleX), i.set("scaleY", u.scaleY), i.skewX = u.skewX, i.skewY = u.skewY, i.angle = u.angle, i.setPositionByOrigin(l, "center", "center") }, sizeAfterTransform: function (i, s, u) { var l = i / 2, d = s / 2, g = [{ x: -l, y: -d }, { x: l, y: -d }, { x: -l, y: d }, { x: l, y: d }], m = t.util.calcDimensionsMatrix(u), y = t.util.makeBoundingBoxFromPoints(g, m); return { x: y.width, y: y.height } }, mergeClipPaths: function (i, s) { var u = i, l = s; u.inverted && !l.inverted && (u = s, l = i), t.util.applyTransformToObject(l, t.util.multiplyTransformMatrices(t.util.invertTransform(u.calcTransformMatrix()), l.calcTransformMatrix())); var d = u.inverted && l.inverted; return d && (u.inverted = l.inverted = !1), new t.Group([u], { clipPath: l, inverted: d }) }, hasStyleChanged: function (i, s, u) { return u = u || !1, i.fill !== s.fill || i.stroke !== s.stroke || i.strokeWidth !== s.strokeWidth || i.fontSize !== s.fontSize || i.fontFamily !== s.fontFamily || i.fontWeight !== s.fontWeight || i.fontStyle !== s.fontStyle || i.textBackgroundColor !== s.textBackgroundColor || i.deltaY !== s.deltaY || u && (i.overline !== s.overline || i.underline !== s.underline || i.linethrough !== s.linethrough) }, stylesToArray: function (u, s) {
			for (var u = t.util.object.clone(u, !0), l = s.split(`
`), d = -1, g = {}, m = [], y = 0; y < l.length; y++) { if (!u[y]) { d += l[y].length; continue } for (var w = 0; w < l[y].length; w++) { d++; var C = u[y][w]; if (C && Object.keys(C).length > 0) { var T = t.util.hasStyleChanged(g, C, !0); T ? m.push({ start: d, end: d + 1, style: C }) : m[m.length - 1].end++ } g = C || {} } } return m
		}, stylesFromArray: function (i, s) {
			if (!Array.isArray(i)) return i; for (var u = s.split(`
`), l = -1, d = 0, g = {}, m = 0; m < u.length; m++)for (var y = 0; y < u[m].length; y++)l++, i[d] && i[d].start <= l && l < i[d].end && (g[m] = g[m] || {}, g[m][y] = Object.assign({}, i[d].style), l === i[d].end - 1 && d++); return g
		}
	}
}(e), function () { var f = Array.prototype.join, r = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, c = { m: "l", M: "L" }; function h(k, M, E, P, W, O, x, F, z, q, X) { var ot = t.util.cos(k), ct = t.util.sin(k), gt = t.util.cos(M), J = t.util.sin(M), H = E * W * gt - P * O * J + x, nt = P * W * gt + E * O * J + F, it = q + z * (-E * W * ct - P * O * ot), Y = X + z * (-P * W * ct + E * O * ot), at = H + z * (E * W * J + P * O * gt), pt = nt + z * (P * W * J - E * O * gt); return ["C", it, Y, at, pt, H, nt] } function n(k, M, E, P, W, O, x) { var F = Math.PI, z = x * F / 180, q = t.util.sin(z), X = t.util.cos(z), ot = 0, ct = 0; E = Math.abs(E), P = Math.abs(P); var gt = -X * k * .5 - q * M * .5, J = -X * M * .5 + q * k * .5, H = E * E, nt = P * P, it = J * J, Y = gt * gt, at = H * nt - H * it - nt * Y, pt = 0; if (at < 0) { var St = Math.sqrt(1 - at / (H * nt)); E *= St, P *= St } else pt = (W === O ? -1 : 1) * Math.sqrt(at / (H * it + nt * Y)); var bt = pt * E * J / P, tt = -pt * P * gt / E, wt = X * bt - q * tt + k * .5, kt = q * bt + X * tt + M * .5, et = o(1, 0, (gt - bt) / E, (J - tt) / P), D = o((gt - bt) / E, (J - tt) / P, (-gt - bt) / E, (-J - tt) / P); O === 0 && D > 0 ? D -= 2 * F : O === 1 && D < 0 && (D += 2 * F); for (var vt = Math.ceil(Math.abs(D / F * 2)), _t = [], Tt = D / vt, $t = 8 / 3 * Math.sin(Tt / 4) * Math.sin(Tt / 4) / Math.sin(Tt / 2), Gt = et + Tt, It = 0; It < vt; It++)_t[It] = h(et, Gt, X, q, E, P, wt, kt, $t, ot, ct), ot = _t[It][5], ct = _t[It][6], et = Gt, Gt += Tt; return _t } function o(k, M, E, P) { var W = Math.atan2(M, k), O = Math.atan2(P, E); return O >= W ? O - W : 2 * Math.PI - (W - O) } function i(k, M, E, P, W, O, x, F) { var z; if (t.cachesBoundsOfCurve && (z = f.call(arguments), t.boundsOfCurveCache[z])) return t.boundsOfCurveCache[z]; var q = Math.sqrt, X = Math.min, ot = Math.max, ct = Math.abs, gt = [], J = [[], []], H, nt, it, Y, at, pt, St, bt; nt = 6 * k - 12 * E + 6 * W, H = -3 * k + 9 * E - 9 * W + 3 * x, it = 3 * E - 3 * k; for (var tt = 0; tt < 2; ++tt) { if (tt > 0 && (nt = 6 * M - 12 * P + 6 * O, H = -3 * M + 9 * P - 9 * O + 3 * F, it = 3 * P - 3 * M), ct(H) < 1e-12) { if (ct(nt) < 1e-12) continue; Y = -it / nt, 0 < Y && Y < 1 && gt.push(Y); continue } St = nt * nt - 4 * it * H, !(St < 0) && (bt = q(St), at = (-nt + bt) / (2 * H), 0 < at && at < 1 && gt.push(at), pt = (-nt - bt) / (2 * H), 0 < pt && pt < 1 && gt.push(pt)) } for (var wt, kt, et = gt.length, D = et, vt; et--;)Y = gt[et], vt = 1 - Y, wt = vt * vt * vt * k + 3 * vt * vt * Y * E + 3 * vt * Y * Y * W + Y * Y * Y * x, J[0][et] = wt, kt = vt * vt * vt * M + 3 * vt * vt * Y * P + 3 * vt * Y * Y * O + Y * Y * Y * F, J[1][et] = kt; J[0][D] = k, J[1][D] = M, J[0][D + 1] = x, J[1][D + 1] = F; var _t = [{ x: X.apply(null, J[0]), y: X.apply(null, J[1]) }, { x: ot.apply(null, J[0]), y: ot.apply(null, J[1]) }]; return t.cachesBoundsOfCurve && (t.boundsOfCurveCache[z] = _t), _t } function s(k, M, E) { for (var P = E[1], W = E[2], O = E[3], x = E[4], F = E[5], z = E[6], q = E[7], X = n(z - k, q - M, P, W, x, F, O), ot = 0, ct = X.length; ot < ct; ot++)X[ot][1] += k, X[ot][2] += M, X[ot][3] += k, X[ot][4] += M, X[ot][5] += k, X[ot][6] += M; return X } function u(k) { var M = 0, E = 0, P = k.length, W = 0, O = 0, x, F, z, q = [], X, ot, ct; for (F = 0; F < P; ++F) { switch (z = !1, x = k[F].slice(0), x[0]) { case "l": x[0] = "L", x[1] += M, x[2] += E; case "L": M = x[1], E = x[2]; break; case "h": x[1] += M; case "H": x[0] = "L", x[2] = E, M = x[1]; break; case "v": x[1] += E; case "V": x[0] = "L", E = x[1], x[1] = M, x[2] = E; break; case "m": x[0] = "M", x[1] += M, x[2] += E; case "M": M = x[1], E = x[2], W = x[1], O = x[2]; break; case "c": x[0] = "C", x[1] += M, x[2] += E, x[3] += M, x[4] += E, x[5] += M, x[6] += E; case "C": ot = x[3], ct = x[4], M = x[5], E = x[6]; break; case "s": x[0] = "S", x[1] += M, x[2] += E, x[3] += M, x[4] += E; case "S": X === "C" ? (ot = 2 * M - ot, ct = 2 * E - ct) : (ot = M, ct = E), M = x[3], E = x[4], x[0] = "C", x[5] = x[3], x[6] = x[4], x[3] = x[1], x[4] = x[2], x[1] = ot, x[2] = ct, ot = x[3], ct = x[4]; break; case "q": x[0] = "Q", x[1] += M, x[2] += E, x[3] += M, x[4] += E; case "Q": ot = x[1], ct = x[2], M = x[3], E = x[4]; break; case "t": x[0] = "T", x[1] += M, x[2] += E; case "T": X === "Q" ? (ot = 2 * M - ot, ct = 2 * E - ct) : (ot = M, ct = E), x[0] = "Q", M = x[1], E = x[2], x[1] = ot, x[2] = ct, x[3] = M, x[4] = E; break; case "a": x[0] = "A", x[6] += M, x[7] += E; case "A": z = !0, q = q.concat(s(M, E, x)), M = x[6], E = x[7]; break; case "z": case "Z": M = W, E = O; break }z || q.push(x), X = x[0] } return q } function l(k, M, E, P) { return Math.sqrt((E - k) * (E - k) + (P - M) * (P - M)) } function d(k) { return k * k * k } function g(k) { return 3 * k * k * (1 - k) } function m(k) { return 3 * k * (1 - k) * (1 - k) } function y(k) { return (1 - k) * (1 - k) * (1 - k) } function w(k, M, E, P, W, O, x, F) { return function (z) { var q = d(z), X = g(z), ot = m(z), ct = y(z); return { x: x * q + W * X + E * ot + k * ct, y: F * q + O * X + P * ot + M * ct } } } function C(k, M, E, P, W, O, x, F) { return function (z) { var q = 1 - z, X = 3 * q * q * (E - k) + 6 * q * z * (W - E) + 3 * z * z * (x - W), ot = 3 * q * q * (P - M) + 6 * q * z * (O - P) + 3 * z * z * (F - O); return Math.atan2(ot, X) } } function T(k) { return k * k } function A(k) { return 2 * k * (1 - k) } function U(k) { return (1 - k) * (1 - k) } function R(k, M, E, P, W, O) { return function (x) { var F = T(x), z = A(x), q = U(x); return { x: W * F + E * z + k * q, y: O * F + P * z + M * q } } } function $(k, M, E, P, W, O) { return function (x) { var F = 1 - x, z = 2 * F * (E - k) + 2 * x * (W - E), q = 2 * F * (P - M) + 2 * x * (O - P); return Math.atan2(q, z) } } function L(k, M, E) { var P = { x: M, y: E }, W, O = 0, x; for (x = 1; x <= 100; x += 1)W = k(x / 100), O += l(P.x, P.y, W.x, W.y), P = W; return O } function B(k, M) { for (var E = 0, P = 0, W = k.iterator, O = { x: k.x, y: k.y }, x, F, z = .01, q = k.angleFinder, X; P < M && z > 1e-4;)x = W(E), X = E, F = l(O.x, O.y, x.x, x.y), F + P > M ? (E -= z, z /= 2) : (O = x, E += z, P += F); return x.angle = q(X), x } function N(k) { for (var M = 0, E = k.length, P, W = 0, O = 0, x = 0, F = 0, z = [], q, X, ot, ct = 0; ct < E; ct++) { switch (P = k[ct], X = { x: W, y: O, command: P[0] }, P[0]) { case "M": X.length = 0, x = W = P[1], F = O = P[2]; break; case "L": X.length = l(W, O, P[1], P[2]), W = P[1], O = P[2]; break; case "C": q = w(W, O, P[1], P[2], P[3], P[4], P[5], P[6]), ot = C(W, O, P[1], P[2], P[3], P[4], P[5], P[6]), X.iterator = q, X.angleFinder = ot, X.length = L(q, W, O), W = P[5], O = P[6]; break; case "Q": q = R(W, O, P[1], P[2], P[3], P[4]), ot = $(W, O, P[1], P[2], P[3], P[4]), X.iterator = q, X.angleFinder = ot, X.length = L(q, W, O), W = P[3], O = P[4]; break; case "Z": case "z": X.destX = x, X.destY = F, X.length = l(W, O, x, F), W = x, O = F; break }M += X.length, z.push(X) } return z.push({ length: M, x: W, y: O }), z } function K(k, M, E) { E || (E = N(k)); for (var P = 0; M - E[P].length > 0 && P < E.length - 2;)M -= E[P].length, P++; var W = E[P], O = M / W.length, x = W.command, F = k[P], z; switch (x) { case "M": return { x: W.x, y: W.y, angle: 0 }; case "Z": case "z": return z = new t.Point(W.x, W.y).lerp(new t.Point(W.destX, W.destY), O), z.angle = Math.atan2(W.destY - W.y, W.destX - W.x), z; case "L": return z = new t.Point(W.x, W.y).lerp(new t.Point(F[1], F[2]), O), z.angle = Math.atan2(F[2] - W.y, F[1] - W.x), z; case "C": return B(W, M); case "Q": return B(W, M) } } function st(k) { var M = [], E = [], P, W, O = t.rePathCommand, x = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", F = "(" + x + ")" + t.commaWsp, z = "([01])" + t.commaWsp + "?", q = F + "?" + F + "?" + F + z + z + F + "?(" + x + ")", X = new RegExp(q, "g"), ot, ct, gt; if (!k || !k.match) return M; gt = k.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi); for (var J = 0, H, nt = gt.length; J < nt; J++) { P = gt[J], ct = P.slice(1).trim(), E.length = 0; var it = P.charAt(0); if (H = [it], it.toLowerCase() === "a") for (var Y; Y = X.exec(ct);)for (var at = 1; at < Y.length; at++)E.push(Y[at]); else for (; ot = O.exec(ct);)E.push(ot[0]); for (var at = 0, pt = E.length; at < pt; at++)W = parseFloat(E[at]), isNaN(W) || H.push(W); var St = r[it.toLowerCase()], bt = c[it] || it; if (H.length - 1 > St) for (var tt = 1, wt = H.length; tt < wt; tt += St)M.push([it].concat(H.slice(tt, tt + St))), it = bt; else M.push(H) } return M } function ft(k, M) { var E = [], P, W = new t.Point(k[0].x, k[0].y), O = new t.Point(k[1].x, k[1].y), x = k.length, F = 1, z = 0, q = x > 2; for (M = M || 0, q && (F = k[2].x < O.x ? -1 : k[2].x === O.x ? 0 : 1, z = k[2].y < O.y ? -1 : k[2].y === O.y ? 0 : 1), E.push(["M", W.x - F * M, W.y - z * M]), P = 1; P < x; P++) { if (!W.eq(O)) { var X = W.midPointFrom(O); E.push(["Q", W.x, W.y, X.x, X.y]) } W = k[P], P + 1 < k.length && (O = k[P + 1]) } return q && (F = W.x > k[P - 2].x ? 1 : W.x === k[P - 2].x ? 0 : -1, z = W.y > k[P - 2].y ? 1 : W.y === k[P - 2].y ? 0 : -1), E.push(["L", W.x + F * M, W.y + z * M]), E } function ht(k, M, E) { return E && (M = t.util.multiplyTransformMatrices(M, [1, 0, 0, 1, -E.x, -E.y])), k.map(function (P) { for (var W = P.slice(0), O = {}, x = 1; x < P.length - 1; x += 2)O.x = P[x], O.y = P[x + 1], O = t.util.transformPoint(O, M), W[x] = O.x, W[x + 1] = O.y; return W }) } t.util.joinPath = function (k) { return k.map(function (M) { return M.join(" ") }).join(" ") }, t.util.parsePath = st, t.util.makePathSimpler = u, t.util.getSmoothPathFromPoints = ft, t.util.getPathSegmentsInfo = N, t.util.getBoundsOfCurve = i, t.util.getPointOnPath = K, t.util.transformPath = ht }(), function () { var f = Array.prototype.slice; function r(i, s) { for (var u = f.call(arguments, 2), l = [], d = 0, g = i.length; d < g; d++)l[d] = u.length ? i[d][s].apply(i[d], u) : i[d][s].call(i[d]); return l } function c(i, s) { return o(i, s, function (u, l) { return u >= l }) } function h(i, s) { return o(i, s, function (u, l) { return u < l }) } function n(i, s) { for (var u = i.length; u--;)i[u] = s; return i } function o(i, s, u) { if (!(!i || i.length === 0)) { var l = i.length - 1, d = s ? i[l][s] : i[l]; if (s) for (; l--;)u(i[l][s], d) && (d = i[l][s]); else for (; l--;)u(i[l], d) && (d = i[l]); return d } } t.util.array = { fill: n, invoke: r, min: h, max: c } }(), function () { function f(c, h, n) { if (n) if (!t.isLikelyNode && h instanceof Element) c = h; else if (h instanceof Array) { c = []; for (var o = 0, i = h.length; o < i; o++)c[o] = f({}, h[o], n) } else if (h && typeof h == "object") for (var s in h) s === "canvas" || s === "group" ? c[s] = null : h.hasOwnProperty(s) && (c[s] = f({}, h[s], n)); else c = h; else for (var s in h) c[s] = h[s]; return c } function r(c, h) { return f({}, c, h) } t.util.object = { extend: f, clone: r }, t.util.object.extend(t.util, t.Observable) }(), function () { function f(o) { return o.replace(/-+(.)?/g, function (i, s) { return s ? s.toUpperCase() : "" }) } function r(o, i) { return o.charAt(0).toUpperCase() + (i ? o.slice(1) : o.slice(1).toLowerCase()) } function c(o) { return o.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function h(o) { var i = 0, s, u = []; for (i = 0, s; i < o.length; i++)(s = n(o, i)) !== !1 && u.push(s); return u } function n(o, i) { var s = o.charCodeAt(i); if (isNaN(s)) return ""; if (s < 55296 || s > 57343) return o.charAt(i); if (55296 <= s && s <= 56319) { if (o.length <= i + 1) throw "High surrogate without following low surrogate"; var u = o.charCodeAt(i + 1); if (56320 > u || u > 57343) throw "High surrogate without following low surrogate"; return o.charAt(i) + o.charAt(i + 1) } if (i === 0) throw "Low surrogate without preceding high surrogate"; var l = o.charCodeAt(i - 1); if (55296 > l || l > 56319) throw "Low surrogate without preceding high surrogate"; return !1 } t.util.string = { camelize: f, capitalize: r, escapeXml: c, graphemeSplit: h } }(), function () { var f = Array.prototype.slice, r = function () { }, c = function () { for (var s in { toString: 1 }) if (s === "toString") return !1; return !0 }(), h = function (s, u, l) { for (var d in u) d in s.prototype && typeof s.prototype[d] == "function" && (u[d] + "").indexOf("callSuper") > -1 ? s.prototype[d] = function (g) { return function () { var m = this.constructor.superclass; this.constructor.superclass = l; var y = u[g].apply(this, arguments); if (this.constructor.superclass = m, g !== "initialize") return y } }(d) : s.prototype[d] = u[d], c && (u.toString !== Object.prototype.toString && (s.prototype.toString = u.toString), u.valueOf !== Object.prototype.valueOf && (s.prototype.valueOf = u.valueOf)) }; function n() { } function o(s) { for (var u = null, l = this; l.constructor.superclass;) { var d = l.constructor.superclass.prototype[s]; if (l[s] !== d) { u = d; break } l = l.constructor.superclass.prototype } return u ? arguments.length > 1 ? u.apply(this, f.call(arguments, 1)) : u.call(this) : console.log("tried to callSuper " + s + ", method not found in prototype chain", this) } function i() { var s = null, u = f.call(arguments, 0); typeof u[0] == "function" && (s = u.shift()); function l() { this.initialize.apply(this, arguments) } l.superclass = s, l.subclasses = [], s && (n.prototype = s.prototype, l.prototype = new n, s.subclasses.push(l)); for (var d = 0, g = u.length; d < g; d++)h(l, u[d], s); return l.prototype.initialize || (l.prototype.initialize = r), l.prototype.constructor = l, l.prototype.callSuper = o, l } t.util.createClass = i }(), function () { var f = !!t.document.createElement("div").attachEvent, r = ["touchstart", "touchmove", "touchend"]; t.util.addListener = function (h, n, o, i) { h && h.addEventListener(n, o, f ? !1 : i) }, t.util.removeListener = function (h, n, o, i) { h && h.removeEventListener(n, o, f ? !1 : i) }; function c(h) { var n = h.changedTouches; return n && n[0] ? n[0] : h } t.util.getPointer = function (h) { var n = h.target, o = t.util.getScrollLeftTop(n), i = c(h); return { x: i.clientX + o.left, y: i.clientY + o.top } }, t.util.isTouchEvent = function (h) { return r.indexOf(h.type) > -1 || h.pointerType === "touch" } }(), function () { function f(i, s) { var u = i.style; if (!u) return i; if (typeof s == "string") return i.style.cssText += ";" + s, s.indexOf("opacity") > -1 ? o(i, s.match(/opacity:\s*(\d?\.?\d*)/)[1]) : i; for (var l in s) if (l === "opacity") o(i, s[l]); else { var d = l === "float" || l === "cssFloat" ? typeof u.styleFloat == "undefined" ? "cssFloat" : "styleFloat" : l; u.setProperty(d, s[l]) } return i } var r = t.document.createElement("div"), c = typeof r.style.opacity == "string", h = typeof r.style.filter == "string", n = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, o = function (i) { return i }; c ? o = function (i, s) { return i.style.opacity = s, i } : h && (o = function (i, s) { var u = i.style; return i.currentStyle && !i.currentStyle.hasLayout && (u.zoom = 1), n.test(u.filter) ? (s = s >= .9999 ? "" : "alpha(opacity=" + s * 100 + ")", u.filter = u.filter.replace(n, s)) : u.filter += " alpha(opacity=" + s * 100 + ")", i }), t.util.setStyle = f }(), function () { var f = Array.prototype.slice; function r(y) { return typeof y == "string" ? t.document.getElementById(y) : y } var c, h = function (y) { return f.call(y, 0) }; try { c = h(t.document.childNodes) instanceof Array } catch (y) { } c || (h = function (y) { for (var w = new Array(y.length), C = y.length; C--;)w[C] = y[C]; return w }); function n(y, w) { var C = t.document.createElement(y); for (var T in w) T === "class" ? C.className = w[T] : T === "for" ? C.htmlFor = w[T] : C.setAttribute(T, w[T]); return C } function o(y, w) { y && (" " + y.className + " ").indexOf(" " + w + " ") === -1 && (y.className += (y.className ? " " : "") + w) } function i(y, w, C) { return typeof w == "string" && (w = n(w, C)), y.parentNode && y.parentNode.replaceChild(w, y), w.appendChild(y), w } function s(y) { for (var w = 0, C = 0, T = t.document.documentElement, A = t.document.body || { scrollLeft: 0, scrollTop: 0 }; y && (y.parentNode || y.host) && (y = y.parentNode || y.host, y === t.document ? (w = A.scrollLeft || T.scrollLeft || 0, C = A.scrollTop || T.scrollTop || 0) : (w += y.scrollLeft || 0, C += y.scrollTop || 0), !(y.nodeType === 1 && y.style.position === "fixed"));); return { left: w, top: C } } function u(y) { var w, C = y && y.ownerDocument, T = { left: 0, top: 0 }, A = { left: 0, top: 0 }, U, R = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!C) return A; for (var $ in R) A[R[$]] += parseInt(l(y, $), 10) || 0; return w = C.documentElement, typeof y.getBoundingClientRect != "undefined" && (T = y.getBoundingClientRect()), U = s(y), { left: T.left + U.left - (w.clientLeft || 0) + A.left, top: T.top + U.top - (w.clientTop || 0) + A.top } } var l; t.document.defaultView && t.document.defaultView.getComputedStyle ? l = function (y, w) { var C = t.document.defaultView.getComputedStyle(y, null); return C ? C[w] : void 0 } : l = function (y, w) { var C = y.style[w]; return !C && y.currentStyle && (C = y.currentStyle[w]), C }, function () { var y = t.document.documentElement.style, w = "userSelect" in y ? "userSelect" : "MozUserSelect" in y ? "MozUserSelect" : "WebkitUserSelect" in y ? "WebkitUserSelect" : "KhtmlUserSelect" in y ? "KhtmlUserSelect" : ""; function C(A) { return typeof A.onselectstart != "undefined" && (A.onselectstart = t.util.falseFunction), w ? A.style[w] = "none" : typeof A.unselectable == "string" && (A.unselectable = "on"), A } function T(A) { return typeof A.onselectstart != "undefined" && (A.onselectstart = null), w ? A.style[w] = "" : typeof A.unselectable == "string" && (A.unselectable = ""), A } t.util.makeElementUnselectable = C, t.util.makeElementSelectable = T }(); function d(y) { var w = t.jsdomImplForWrapper(y); return w._canvas || w._image } function g(y) { if (t.isLikelyNode) { var w = t.jsdomImplForWrapper(y); w && (w._image = null, w._canvas = null, w._currentSrc = null, w._attributes = null, w._classList = null) } } function m(y, w) { y.imageSmoothingEnabled = y.imageSmoothingEnabled || y.webkitImageSmoothingEnabled || y.mozImageSmoothingEnabled || y.msImageSmoothingEnabled || y.oImageSmoothingEnabled, y.imageSmoothingEnabled = w } t.util.setImageSmoothing = m, t.util.getById = r, t.util.toArray = h, t.util.addClass = o, t.util.makeElement = n, t.util.wrapElement = i, t.util.getScrollLeftTop = s, t.util.getElementOffset = u, t.util.getNodeCanvas = d, t.util.cleanUpJsdomNode = g }(), function () { function f(h, n) { return h + (/\?/.test(h) ? "&" : "?") + n } function r() { } function c(h, n) { n || (n = {}); var o = n.method ? n.method.toUpperCase() : "GET", i = n.onComplete || function () { }, s = new t.window.XMLHttpRequest, u = n.body || n.parameters; return s.onreadystatechange = function () { s.readyState === 4 && (i(s), s.onreadystatechange = r) }, o === "GET" && (u = null, typeof n.parameters == "string" && (h = f(h, n.parameters))), s.open(o, h, !0), (o === "POST" || o === "PUT") && s.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), s.send(u), s } t.util.request = c }(), t.log = console.log, t.warn = console.warn, function () { var f = t.util.object.extend, r = t.util.object.clone, c = []; t.util.object.extend(c, { cancelAll: function () { var d = this.splice(0); return d.forEach(function (g) { g.cancel() }), d }, cancelByCanvas: function (d) { if (!d) return []; var g = this.filter(function (m) { return typeof m.target == "object" && m.target.canvas === d }); return g.forEach(function (m) { m.cancel() }), g }, cancelByTarget: function (d) { var g = this.findAnimationsByTarget(d); return g.forEach(function (m) { m.cancel() }), g }, findAnimationIndex: function (d) { return this.indexOf(this.findAnimation(d)) }, findAnimation: function (d) { return this.find(function (g) { return g.cancel === d }) }, findAnimationsByTarget: function (d) { return d ? this.filter(function (g) { return g.target === d }) : [] } }); function h() { return !1 } function n(d, g, m, y) { return -m * Math.cos(d / y * (Math.PI / 2)) + m + g } function o(d) { d || (d = {}); var g = !1, m, y = function () { var w = t.runningAnimations.indexOf(m); return w > -1 && t.runningAnimations.splice(w, 1)[0] }; return m = f(r(d), { cancel: function () { return g = !0, y() }, currentValue: "startValue" in d ? d.startValue : 0, completionRate: 0, durationRate: 0 }), t.runningAnimations.push(m), u(function (w) { var C = w || +new Date, T = d.duration || 500, A = C + T, U, R = d.onChange || h, $ = d.abort || h, L = d.onComplete || h, B = d.easing || n, N = "startValue" in d ? d.startValue.length > 0 : !1, K = "startValue" in d ? d.startValue : 0, st = "endValue" in d ? d.endValue : 100, ft = d.byValue || (N ? K.map(function (ht, k) { return st[k] - K[k] }) : st - K); d.onStart && d.onStart(), function ht(k) { U = k || +new Date; var M = U > A ? T : U - C, E = M / T, P = N ? K.map(function (O, x) { return B(M, K[x], ft[x], T) }) : B(M, K, ft, T), W = Math.abs(N ? (P[0] - K[0]) / ft[0] : (P - K) / ft); if (m.currentValue = N ? P.slice() : P, m.completionRate = W, m.durationRate = E, !g) { if ($(P, W, E)) { y(); return } if (U > A) { m.currentValue = N ? st.slice() : st, m.completionRate = 1, m.durationRate = 1, R(N ? st.slice() : st, 1, 1), L(st, 1, 1), y(); return } else R(P, W, E), u(ht) } }(C) }), m.cancel } var i = t.window.requestAnimationFrame || t.window.webkitRequestAnimationFrame || t.window.mozRequestAnimationFrame || t.window.oRequestAnimationFrame || t.window.msRequestAnimationFrame || function (d) { return t.window.setTimeout(d, 1e3 / 60) }, s = t.window.cancelAnimationFrame || t.window.clearTimeout; function u() { return i.apply(t.window, arguments) } function l() { return s.apply(t.window, arguments) } t.util.animate = o, t.util.requestAnimFrame = u, t.util.cancelAnimFrame = l, t.runningAnimations = c }(), function () { function f(c, h, n) { var o = "rgba(" + parseInt(c[0] + n * (h[0] - c[0]), 10) + "," + parseInt(c[1] + n * (h[1] - c[1]), 10) + "," + parseInt(c[2] + n * (h[2] - c[2]), 10); return o += "," + (c && h ? parseFloat(c[3] + n * (h[3] - c[3])) : 1), o += ")", o } function r(c, h, n, o) { var i = new t.Color(c).getSource(), s = new t.Color(h).getSource(), u = o.onComplete, l = o.onChange; return o = o || {}, t.util.animate(t.util.object.extend(o, { duration: n || 500, startValue: i, endValue: s, byValue: s, easing: function (d, g, m, y) { var w = o.colorEasing ? o.colorEasing(d, y) : 1 - Math.cos(d / y * (Math.PI / 2)); return f(g, m, w) }, onComplete: function (d, g, m) { if (u) return u(f(s, s, 0), g, m) }, onChange: function (d, g, m) { if (l) { if (Array.isArray(d)) return l(f(d, d, 0), g, m); l(d, g, m) } } })) } t.util.animateColor = r }(), function () { function f(k, M, E, P) { return k < Math.abs(M) ? (k = M, P = E / 4) : M === 0 && k === 0 ? P = E / (2 * Math.PI) * Math.asin(1) : P = E / (2 * Math.PI) * Math.asin(M / k), { a: k, c: M, p: E, s: P } } function r(k, M, E) { return k.a * Math.pow(2, 10 * (M -= 1)) * Math.sin((M * E - k.s) * (2 * Math.PI) / k.p) } function c(k, M, E, P) { return E * ((k = k / P - 1) * k * k + 1) + M } function h(k, M, E, P) { return k /= P / 2, k < 1 ? E / 2 * k * k * k + M : E / 2 * ((k -= 2) * k * k + 2) + M } function n(k, M, E, P) { return E * (k /= P) * k * k * k + M } function o(k, M, E, P) { return -E * ((k = k / P - 1) * k * k * k - 1) + M } function i(k, M, E, P) { return k /= P / 2, k < 1 ? E / 2 * k * k * k * k + M : -E / 2 * ((k -= 2) * k * k * k - 2) + M } function s(k, M, E, P) { return E * (k /= P) * k * k * k * k + M } function u(k, M, E, P) { return E * ((k = k / P - 1) * k * k * k * k + 1) + M } function l(k, M, E, P) { return k /= P / 2, k < 1 ? E / 2 * k * k * k * k * k + M : E / 2 * ((k -= 2) * k * k * k * k + 2) + M } function d(k, M, E, P) { return -E * Math.cos(k / P * (Math.PI / 2)) + E + M } function g(k, M, E, P) { return E * Math.sin(k / P * (Math.PI / 2)) + M } function m(k, M, E, P) { return -E / 2 * (Math.cos(Math.PI * k / P) - 1) + M } function y(k, M, E, P) { return k === 0 ? M : E * Math.pow(2, 10 * (k / P - 1)) + M } function w(k, M, E, P) { return k === P ? M + E : E * (-Math.pow(2, -10 * k / P) + 1) + M } function C(k, M, E, P) { return k === 0 ? M : k === P ? M + E : (k /= P / 2, k < 1 ? E / 2 * Math.pow(2, 10 * (k - 1)) + M : E / 2 * (-Math.pow(2, -10 * --k) + 2) + M) } function T(k, M, E, P) { return -E * (Math.sqrt(1 - (k /= P) * k) - 1) + M } function A(k, M, E, P) { return E * Math.sqrt(1 - (k = k / P - 1) * k) + M } function U(k, M, E, P) { return k /= P / 2, k < 1 ? -E / 2 * (Math.sqrt(1 - k * k) - 1) + M : E / 2 * (Math.sqrt(1 - (k -= 2) * k) + 1) + M } function R(k, M, E, P) { var W = 1.70158, O = 0, x = E; if (k === 0) return M; if (k /= P, k === 1) return M + E; O || (O = P * .3); var F = f(x, E, O, W); return -r(F, k, P) + M } function $(k, M, E, P) { var W = 1.70158, O = 0, x = E; if (k === 0) return M; if (k /= P, k === 1) return M + E; O || (O = P * .3); var F = f(x, E, O, W); return F.a * Math.pow(2, -10 * k) * Math.sin((k * P - F.s) * (2 * Math.PI) / F.p) + F.c + M } function L(k, M, E, P) { var W = 1.70158, O = 0, x = E; if (k === 0) return M; if (k /= P / 2, k === 2) return M + E; O || (O = P * (.3 * 1.5)); var F = f(x, E, O, W); return k < 1 ? -.5 * r(F, k, P) + M : F.a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k * P - F.s) * (2 * Math.PI) / F.p) * .5 + F.c + M } function B(k, M, E, P, W) { return W === void 0 && (W = 1.70158), E * (k /= P) * k * ((W + 1) * k - W) + M } function N(k, M, E, P, W) { return W === void 0 && (W = 1.70158), E * ((k = k / P - 1) * k * ((W + 1) * k + W) + 1) + M } function K(k, M, E, P, W) { return W === void 0 && (W = 1.70158), k /= P / 2, k < 1 ? E / 2 * (k * k * (((W *= 1.525) + 1) * k - W)) + M : E / 2 * ((k -= 2) * k * (((W *= 1.525) + 1) * k + W) + 2) + M } function st(k, M, E, P) { return E - ft(P - k, 0, E, P) + M } function ft(k, M, E, P) { return (k /= P) < 1 / 2.75 ? E * (7.5625 * k * k) + M : k < 2 / 2.75 ? E * (7.5625 * (k -= 1.5 / 2.75) * k + .75) + M : k < 2.5 / 2.75 ? E * (7.5625 * (k -= 2.25 / 2.75) * k + .9375) + M : E * (7.5625 * (k -= 2.625 / 2.75) * k + .984375) + M } function ht(k, M, E, P) { return k < P / 2 ? st(k * 2, 0, E, P) * .5 + M : ft(k * 2 - P, 0, E, P) * .5 + E * .5 + M } t.util.ease = { easeInQuad: function (k, M, E, P) { return E * (k /= P) * k + M }, easeOutQuad: function (k, M, E, P) { return -E * (k /= P) * (k - 2) + M }, easeInOutQuad: function (k, M, E, P) { return k /= P / 2, k < 1 ? E / 2 * k * k + M : -E / 2 * (--k * (k - 2) - 1) + M }, easeInCubic: function (k, M, E, P) { return E * (k /= P) * k * k + M }, easeOutCubic: c, easeInOutCubic: h, easeInQuart: n, easeOutQuart: o, easeInOutQuart: i, easeInQuint: s, easeOutQuint: u, easeInOutQuint: l, easeInSine: d, easeOutSine: g, easeInOutSine: m, easeInExpo: y, easeOutExpo: w, easeInOutExpo: C, easeInCirc: T, easeOutCirc: A, easeInOutCirc: U, easeInElastic: R, easeOutElastic: $, easeInOutElastic: L, easeInBack: B, easeOutBack: N, easeInOutBack: K, easeInBounce: st, easeOutBounce: ft, easeInOutBounce: ht } }(), function (f) { var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.util.object.clone, n = r.util.toFixed, o = r.util.parseUnit, i = r.util.multiplyTransformMatrices, s = ["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"], u = ["symbol", "image", "marker", "pattern", "view", "svg"], l = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], d = ["symbol", "g", "a", "svg", "clipPath", "defs"], g = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, m = { stroke: "strokeOpacity", fill: "fillOpacity" }, y = "font-size", w = "clip-path"; r.svgValidTagNamesRegEx = A(s), r.svgViewBoxElementsRegEx = A(u), r.svgInvalidAncestorsRegEx = A(l), r.svgValidParentsRegEx = A(d), r.cssRules = {}, r.gradientDefs = {}, r.clipPaths = {}; function C(O) { return O in g ? g[O] : O } function T(O, x, F, z) { var q = Array.isArray(x), X; if ((O === "fill" || O === "stroke") && x === "none") x = ""; else { if (O === "strokeUniform") return x === "non-scaling-stroke"; if (O === "strokeDashArray") x === "none" ? x = null : x = x.replace(/,/g, " ").split(/\s+/).map(parseFloat); else if (O === "transformMatrix") F && F.transformMatrix ? x = i(F.transformMatrix, r.parseTransformAttribute(x)) : x = r.parseTransformAttribute(x); else if (O === "visible") x = x !== "none" && x !== "hidden", F && F.visible === !1 && (x = !1); else if (O === "opacity") x = parseFloat(x), F && typeof F.opacity != "undefined" && (x *= F.opacity); else if (O === "textAnchor") x = x === "start" ? "left" : x === "end" ? "right" : "center"; else if (O === "charSpacing") X = o(x, z) / z * 1e3; else if (O === "paintFirst") { var ot = x.indexOf("fill"), ct = x.indexOf("stroke"), x = "fill"; (ot > -1 && ct > -1 && ct < ot || ot === -1 && ct > -1) && (x = "stroke") } else { if (O === "href" || O === "xlink:href" || O === "font") return x; if (O === "imageSmoothing") return x === "optimizeQuality"; X = q ? x.map(o) : o(x, z) } } return !q && isNaN(X) ? x : X } function A(O) { return new RegExp("^(" + O.join("|") + ")\\b", "i") } function U(O) { for (var x in m) if (!(typeof O[m[x]] == "undefined" || O[x] === "")) { if (typeof O[x] == "undefined") { if (!r.Object.prototype[x]) continue; O[x] = r.Object.prototype[x] } if (O[x].indexOf("url(") !== 0) { var F = new r.Color(O[x]); O[x] = F.setAlpha(n(F.getAlpha() * O[m[x]], 2)).toRgba() } } return O } function R(O, x) { var F, z = [], q, X, ot; for (X = 0, ot = x.length; X < ot; X++)F = x[X], q = O.getElementsByTagName(F), z = z.concat(Array.prototype.slice.call(q)); return z } r.parseTransformAttribute = function () { function O(tt, wt) { var kt = r.util.cos(wt[0]), et = r.util.sin(wt[0]), D = 0, vt = 0; wt.length === 3 && (D = wt[1], vt = wt[2]), tt[0] = kt, tt[1] = et, tt[2] = -et, tt[3] = kt, tt[4] = D - (kt * D - et * vt), tt[5] = vt - (et * D + kt * vt) } function x(tt, wt) { var kt = wt[0], et = wt.length === 2 ? wt[1] : wt[0]; tt[0] = kt, tt[3] = et } function F(tt, wt, kt) { tt[kt] = Math.tan(r.util.degreesToRadians(wt[0])) } function z(tt, wt) { tt[4] = wt[0], wt.length === 2 && (tt[5] = wt[1]) } var q = r.iMatrix, X = r.reNum, ot = r.commaWsp, ct = "(?:(skewX)\\s*\\(\\s*(" + X + ")\\s*\\))", gt = "(?:(skewY)\\s*\\(\\s*(" + X + ")\\s*\\))", J = "(?:(rotate)\\s*\\(\\s*(" + X + ")(?:" + ot + "(" + X + ")" + ot + "(" + X + "))?\\s*\\))", H = "(?:(scale)\\s*\\(\\s*(" + X + ")(?:" + ot + "(" + X + "))?\\s*\\))", nt = "(?:(translate)\\s*\\(\\s*(" + X + ")(?:" + ot + "(" + X + "))?\\s*\\))", it = "(?:(matrix)\\s*\\(\\s*(" + X + ")" + ot + "(" + X + ")" + ot + "(" + X + ")" + ot + "(" + X + ")" + ot + "(" + X + ")" + ot + "(" + X + ")\\s*\\))", Y = "(?:" + it + "|" + nt + "|" + H + "|" + J + "|" + ct + "|" + gt + ")", at = "(?:" + Y + "(?:" + ot + "*" + Y + ")*)", pt = "^\\s*(?:" + at + "?)\\s*$", St = new RegExp(pt), bt = new RegExp(Y, "g"); return function (tt) { var wt = q.concat(), kt = []; if (!tt || tt && !St.test(tt)) return wt; tt.replace(bt, function (D) { var vt = new RegExp(Y).exec(D).filter(function ($t) { return !!$t }), _t = vt[1], Tt = vt.slice(2).map(parseFloat); switch (_t) { case "translate": z(wt, Tt); break; case "rotate": Tt[0] = r.util.degreesToRadians(Tt[0]), O(wt, Tt); break; case "scale": x(wt, Tt); break; case "skewX": F(wt, Tt, 2); break; case "skewY": F(wt, Tt, 1); break; case "matrix": wt = Tt; break }kt.push(wt.concat()), wt = q.concat() }); for (var et = kt[0]; kt.length > 1;)kt.shift(), et = r.util.multiplyTransformMatrices(et, kt[0]); return et } }(); function $(O, x) { var F, z; O.replace(/;\s*$/, "").split(";").forEach(function (q) { var X = q.split(":"); F = X[0].trim().toLowerCase(), z = X[1].trim(), x[F] = z }) } function L(O, x) { var F, z; for (var q in O) typeof O[q] != "undefined" && (F = q.toLowerCase(), z = O[q], x[F] = z) } function B(O, x) { var F = {}; for (var z in r.cssRules[x]) if (N(O, z.split(" "))) for (var q in r.cssRules[x][z]) F[q] = r.cssRules[x][z][q]; return F } function N(O, x) { var F, z = !0; return F = st(O, x.pop()), F && x.length && (z = K(O, x)), F && z && x.length === 0 } function K(O, x) { for (var F, z = !0; O.parentNode && O.parentNode.nodeType === 1 && x.length;)z && (F = x.pop()), O = O.parentNode, z = st(O, F); return x.length === 0 } function st(O, x) { var F = O.nodeName, z = O.getAttribute("class"), q = O.getAttribute("id"), X, ot; if (X = new RegExp("^" + F, "i"), x = x.replace(X, ""), q && x.length && (X = new RegExp("#" + q + "(?![a-zA-Z\\-]+)", "i"), x = x.replace(X, "")), z && x.length) for (z = z.split(" "), ot = z.length; ot--;)X = new RegExp("\\." + z[ot] + "(?![a-zA-Z\\-]+)", "i"), x = x.replace(X, ""); return x.length === 0 } function ft(O, x) { var F; if (O.getElementById && (F = O.getElementById(x)), F) return F; var z, q, X, ot = O.getElementsByTagName("*"); for (q = 0, X = ot.length; q < X; q++)if (z = ot[q], x === z.getAttribute("id")) return z } function ht(O) { for (var x = R(O, ["use", "svg:use"]), F = 0; x.length && F < x.length;) { var z = x[F], q = z.getAttribute("xlink:href") || z.getAttribute("href"); if (q === null) return; var X = q.slice(1), ot = z.getAttribute("x") || 0, ct = z.getAttribute("y") || 0, gt = ft(O, X).cloneNode(!0), J = (gt.getAttribute("transform") || "") + " translate(" + ot + ", " + ct + ")", H, nt = x.length, it, Y, at, pt, St = r.svgNS; if (M(gt), /^svg$/i.test(gt.nodeName)) { var bt = gt.ownerDocument.createElementNS(St, "g"); for (Y = 0, at = gt.attributes, pt = at.length; Y < pt; Y++)it = at.item(Y), bt.setAttributeNS(St, it.nodeName, it.nodeValue); for (; gt.firstChild;)bt.appendChild(gt.firstChild); gt = bt } for (Y = 0, at = z.attributes, pt = at.length; Y < pt; Y++)it = at.item(Y), !(it.nodeName === "x" || it.nodeName === "y" || it.nodeName === "xlink:href" || it.nodeName === "href") && (it.nodeName === "transform" ? J = it.nodeValue + " " + J : gt.setAttribute(it.nodeName, it.nodeValue)); gt.setAttribute("transform", J), gt.setAttribute("instantiated_by_use", "1"), gt.removeAttribute("id"), H = z.parentNode, H.replaceChild(gt, z), x.length === nt && F++ } } var k = new RegExp("^\\s*(" + r.reNum + "+)\\s*,?\\s*(" + r.reNum + "+)\\s*,?\\s*(" + r.reNum + "+)\\s*,?\\s*(" + r.reNum + "+)\\s*$"); function M(O) { if (!r.svgViewBoxElementsRegEx.test(O.nodeName)) return {}; var x = O.getAttribute("viewBox"), F = 1, z = 1, q = 0, X = 0, ot, ct, gt, J, H = O.getAttribute("width"), nt = O.getAttribute("height"), it = O.getAttribute("x") || 0, Y = O.getAttribute("y") || 0, at = O.getAttribute("preserveAspectRatio") || "", pt = !x || !(x = x.match(k)), St = !H || !nt || H === "100%" || nt === "100%", bt = pt && St, tt = {}, wt = "", kt = 0, et = 0; if (tt.width = 0, tt.height = 0, tt.toBeParsed = bt, pt && (it || Y) && O.parentNode && O.parentNode.nodeName !== "#document" && (wt = " translate(" + o(it) + " " + o(Y) + ") ", gt = (O.getAttribute("transform") || "") + wt, O.setAttribute("transform", gt), O.removeAttribute("x"), O.removeAttribute("y")), bt) return tt; if (pt) return tt.width = o(H), tt.height = o(nt), tt; if (q = -parseFloat(x[1]), X = -parseFloat(x[2]), ot = parseFloat(x[3]), ct = parseFloat(x[4]), tt.minX = q, tt.minY = X, tt.viewBoxWidth = ot, tt.viewBoxHeight = ct, St ? (tt.width = ot, tt.height = ct) : (tt.width = o(H), tt.height = o(nt), F = tt.width / ot, z = tt.height / ct), at = r.util.parsePreserveAspectRatioAttribute(at), at.alignX !== "none" && (at.meetOrSlice === "meet" && (z = F = F > z ? z : F), at.meetOrSlice === "slice" && (z = F = F > z ? F : z), kt = tt.width - ot * F, et = tt.height - ct * F, at.alignX === "Mid" && (kt /= 2), at.alignY === "Mid" && (et /= 2), at.alignX === "Min" && (kt = 0), at.alignY === "Min" && (et = 0)), F === 1 && z === 1 && q === 0 && X === 0 && it === 0 && Y === 0) return tt; if ((it || Y) && O.parentNode.nodeName !== "#document" && (wt = " translate(" + o(it) + " " + o(Y) + ") "), gt = wt + " matrix(" + F + " 0 0 " + z + " " + (q * F + kt) + " " + (X * z + et) + ") ", O.nodeName === "svg") { for (J = O.ownerDocument.createElementNS(r.svgNS, "g"); O.firstChild;)J.appendChild(O.firstChild); O.appendChild(J) } else J = O, J.removeAttribute("x"), J.removeAttribute("y"), gt = J.getAttribute("transform") + gt; return J.setAttribute("transform", gt), tt } function E(O, x) { for (; O && (O = O.parentNode);)if (O.nodeName && x.test(O.nodeName.replace("svg:", "")) && !O.getAttribute("instantiated_by_use")) return !0; return !1 } r.parseSVGDocument = function (O, x, F, z) { if (O) { ht(O); var q = r.Object.__uid++, X, ot, ct = M(O), gt = r.util.toArray(O.getElementsByTagName("*")); if (ct.crossOrigin = z && z.crossOrigin, ct.svgUid = q, gt.length === 0 && r.isLikelyNode) { gt = O.selectNodes('//*[name(.)!="svg"]'); var J = []; for (X = 0, ot = gt.length; X < ot; X++)J[X] = gt[X]; gt = J } var H = gt.filter(function (it) { return M(it), r.svgValidTagNamesRegEx.test(it.nodeName.replace("svg:", "")) && !E(it, r.svgInvalidAncestorsRegEx) }); if (!H || H && !H.length) { x && x([], {}); return } var nt = {}; gt.filter(function (it) { return it.nodeName.replace("svg:", "") === "clipPath" }).forEach(function (it) { var Y = it.getAttribute("id"); nt[Y] = r.util.toArray(it.getElementsByTagName("*")).filter(function (at) { return r.svgValidTagNamesRegEx.test(at.nodeName.replace("svg:", "")) }) }), r.gradientDefs[q] = r.getGradientDefs(O), r.cssRules[q] = r.getCSSRules(O), r.clipPaths[q] = nt, r.parseElements(H, function (it, Y) { x && (x(it, ct, Y, gt), delete r.gradientDefs[q], delete r.cssRules[q], delete r.clipPaths[q]) }, h(ct), F, z) } }; function P(O, x) { var F = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], z = "xlink:href", q = x.getAttribute(z).slice(1), X = ft(O, q); if (X && X.getAttribute(z) && P(O, X), F.forEach(function (ct) { X && !x.hasAttribute(ct) && X.hasAttribute(ct) && x.setAttribute(ct, X.getAttribute(ct)) }), !x.children.length) for (var ot = X.cloneNode(!0); ot.firstChild;)x.appendChild(ot.firstChild); x.removeAttribute(z) } var W = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + r.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + r.reNum + "))?\\s+(.*)"); c(r, { parseFontDeclaration: function (O, x) { var F = O.match(W); if (F) { var z = F[1], q = F[3], X = F[4], ot = F[5], ct = F[6]; z && (x.fontStyle = z), q && (x.fontWeight = isNaN(parseFloat(q)) ? q : parseFloat(q)), X && (x.fontSize = o(X)), ct && (x.fontFamily = ct), ot && (x.lineHeight = ot === "normal" ? 1 : ot) } }, getGradientDefs: function (O) { var x = ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"], F = R(O, x), z, q = 0, X = {}; for (q = F.length; q--;)z = F[q], z.getAttribute("xlink:href") && P(O, z), X[z.getAttribute("id")] = z; return X }, parseAttributes: function (O, x, F) { if (O) { var z, q = {}, X, ot; typeof F == "undefined" && (F = O.getAttribute("svgUid")), O.parentNode && r.svgValidParentsRegEx.test(O.parentNode.nodeName) && (q = r.parseAttributes(O.parentNode, x, F)); var ct = x.reduce(function (at, pt) { return z = O.getAttribute(pt), z && (at[pt] = z), at }, {}), gt = c(B(O, F), r.parseStyleAttribute(O)); ct = c(ct, gt), gt[w] && O.setAttribute(w, gt[w]), X = ot = q.fontSize || r.Text.DEFAULT_SVG_FONT_SIZE, ct[y] && (ct[y] = X = o(ct[y], ot)); var J, H, nt = {}; for (var it in ct) J = C(it), H = T(J, ct[it], q, X), nt[J] = H; nt && nt.font && r.parseFontDeclaration(nt.font, nt); var Y = c(q, nt); return r.svgValidParentsRegEx.test(O.nodeName) ? Y : U(Y) } }, parseElements: function (O, x, F, z, q) { new r.ElementsParser(O, x, F, z, q).parse() }, parseStyleAttribute: function (O) { var x = {}, F = O.getAttribute("style"); return F && (typeof F == "string" ? $(F, x) : L(F, x)), x }, parsePointsAttribute: function (O) { if (!O) return null; O = O.replace(/,/g, " ").trim(), O = O.split(/\s+/); var x = [], F, z; for (F = 0, z = O.length; F < z; F += 2)x.push({ x: parseFloat(O[F]), y: parseFloat(O[F + 1]) }); return x }, getCSSRules: function (O) { var x = O.getElementsByTagName("style"), F, z, q = {}, X; for (F = 0, z = x.length; F < z; F++) { var ot = x[F].textContent; ot = ot.replace(/\/\*[\s\S]*?\*\//g, ""), ot.trim() !== "" && (X = ot.split("}"), X = X.filter(function (ct) { return ct.trim() }), X.forEach(function (ct) { var gt = ct.split("{"), J = {}, H = gt[1].trim(), nt = H.split(";").filter(function (pt) { return pt.trim() }); for (F = 0, z = nt.length; F < z; F++) { var it = nt[F].split(":"), Y = it[0].trim(), at = it[1].trim(); J[Y] = at } ct = gt[0].trim(), ct.split(",").forEach(function (pt) { pt = pt.replace(/^svg/i, "").trim(), pt !== "" && (q[pt] ? r.util.object.extend(q[pt], J) : q[pt] = r.util.object.clone(J)) }) })) } return q }, loadSVGFromURL: function (O, x, F, z) { O = O.replace(/^\n\s*/, "").trim(), new r.util.request(O, { method: "get", onComplete: q }); function q(X) { var ot = X.responseXML; if (!ot || !ot.documentElement) return x && x(null), !1; r.parseSVGDocument(ot.documentElement, function (ct, gt, J, H) { x && x(ct, gt, J, H) }, F, z) } }, loadSVGFromString: function (O, x, F, z) { var q = new r.window.DOMParser, X = q.parseFromString(O.trim(), "text/xml"); r.parseSVGDocument(X.documentElement, function (ot, ct, gt, J) { x(ot, ct, gt, J) }, F, z) } }) }(e), t.ElementsParser = function (f, r, c, h, n, o) { this.elements = f, this.callback = r, this.options = c, this.reviver = h, this.svgUid = c && c.svgUid || 0, this.parsingOptions = n, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = o }, function (f) { f.parse = function () { this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects() }, f.createObjects = function () { var r = this; this.elements.forEach(function (c, h) { c.setAttribute("svgUid", r.svgUid), r.createObject(c, h) }) }, f.findTag = function (r) { return t[t.util.string.capitalize(r.tagName.replace("svg:", ""))] }, f.createObject = function (r, c) { var h = this.findTag(r); if (h && h.fromElement) try { h.fromElement(r, this.createCallback(c, r), this.options) } catch (n) { t.log(n) } else this.checkIfDone() }, f.createCallback = function (r, c) { var h = this; return function (n) { var o; h.resolveGradient(n, c, "fill"), h.resolveGradient(n, c, "stroke"), n instanceof t.Image && n._originalElement && (o = n.parsePreserveAspectRatioAttribute(c)), n._removeTransformMatrix(o), h.resolveClipPath(n, c), h.reviver && h.reviver(c, n), h.instances[r] = n, h.checkIfDone() } }, f.extractPropertyDefinition = function (r, c, h) { var n = r[c], o = this.regexUrl; if (o.test(n)) { o.lastIndex = 0; var i = o.exec(n)[1]; return o.lastIndex = 0, t[h][this.svgUid][i] } }, f.resolveGradient = function (r, c, h) { var n = this.extractPropertyDefinition(r, h, "gradientDefs"); if (n) { var o = c.getAttribute(h + "-opacity"), i = t.Gradient.fromElement(n, r, o, this.options); r.set(h, i) } }, f.createClipPathCallback = function (r, c) { return function (h) { h._removeTransformMatrix(), h.fillRule = h.clipRule, c.push(h) } }, f.resolveClipPath = function (r, c) { var h = this.extractPropertyDefinition(r, "clipPath", "clipPaths"), n, o, i, s, u, l; if (h) { s = [], i = t.util.invertTransform(r.calcTransformMatrix()); for (var d = h[0].parentNode, g = c; g.parentNode && g.getAttribute("clip-path") !== r.clipPath;)g = g.parentNode; g.parentNode.appendChild(d); for (var m = 0; m < h.length; m++)n = h[m], o = this.findTag(n), o.fromElement(n, this.createClipPathCallback(r, s), this.options); s.length === 1 ? h = s[0] : h = new t.Group(s), u = t.util.multiplyTransformMatrices(i, h.calcTransformMatrix()), h.clipPath && this.resolveClipPath(h, g); var l = t.util.qrDecompose(u); h.flipX = !1, h.flipY = !1, h.set("scaleX", l.scaleX), h.set("scaleY", l.scaleY), h.angle = l.angle, h.skewX = l.skewX, h.skewY = 0, h.setPositionByOrigin({ x: l.translateX, y: l.translateY }, "center", "center"), r.clipPath = h } else delete r.clipPath }, f.checkIfDone = function () { --this.numElements === 0 && (this.instances = this.instances.filter(function (r) { return r != null }), this.callback(this.instances, this.elements)) } }(t.ElementsParser.prototype), function (f) { var r = f.fabric || (f.fabric = {}); if (r.Point) { r.warn("fabric.Point is already defined"); return } r.Point = c; function c(h, n) { this.x = h, this.y = n } c.prototype = { type: "point", constructor: c, add: function (h) { return new c(this.x + h.x, this.y + h.y) }, addEquals: function (h) { return this.x += h.x, this.y += h.y, this }, scalarAdd: function (h) { return new c(this.x + h, this.y + h) }, scalarAddEquals: function (h) { return this.x += h, this.y += h, this }, subtract: function (h) { return new c(this.x - h.x, this.y - h.y) }, subtractEquals: function (h) { return this.x -= h.x, this.y -= h.y, this }, scalarSubtract: function (h) { return new c(this.x - h, this.y - h) }, scalarSubtractEquals: function (h) { return this.x -= h, this.y -= h, this }, multiply: function (h) { return new c(this.x * h, this.y * h) }, multiplyEquals: function (h) { return this.x *= h, this.y *= h, this }, divide: function (h) { return new c(this.x / h, this.y / h) }, divideEquals: function (h) { return this.x /= h, this.y /= h, this }, eq: function (h) { return this.x === h.x && this.y === h.y }, lt: function (h) { return this.x < h.x && this.y < h.y }, lte: function (h) { return this.x <= h.x && this.y <= h.y }, gt: function (h) { return this.x > h.x && this.y > h.y }, gte: function (h) { return this.x >= h.x && this.y >= h.y }, lerp: function (h, n) { return typeof n == "undefined" && (n = .5), n = Math.max(Math.min(1, n), 0), new c(this.x + (h.x - this.x) * n, this.y + (h.y - this.y) * n) }, distanceFrom: function (h) { var n = this.x - h.x, o = this.y - h.y; return Math.sqrt(n * n + o * o) }, midPointFrom: function (h) { return this.lerp(h) }, min: function (h) { return new c(Math.min(this.x, h.x), Math.min(this.y, h.y)) }, max: function (h) { return new c(Math.max(this.x, h.x), Math.max(this.y, h.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (h, n) { return this.x = h, this.y = n, this }, setX: function (h) { return this.x = h, this }, setY: function (h) { return this.y = h, this }, setFromPoint: function (h) { return this.x = h.x, this.y = h.y, this }, swap: function (h) { var n = this.x, o = this.y; this.x = h.x, this.y = h.y, h.x = n, h.y = o }, clone: function () { return new c(this.x, this.y) } } }(e), function (f) { var r = f.fabric || (f.fabric = {}); if (r.Intersection) { r.warn("fabric.Intersection is already defined"); return } function c(h) { this.status = h, this.points = [] } r.Intersection = c, r.Intersection.prototype = { constructor: c, appendPoint: function (h) { return this.points.push(h), this }, appendPoints: function (h) { return this.points = this.points.concat(h), this } }, r.Intersection.intersectLineLine = function (h, n, o, i) { var s, u = (i.x - o.x) * (h.y - o.y) - (i.y - o.y) * (h.x - o.x), l = (n.x - h.x) * (h.y - o.y) - (n.y - h.y) * (h.x - o.x), d = (i.y - o.y) * (n.x - h.x) - (i.x - o.x) * (n.y - h.y); if (d !== 0) { var g = u / d, m = l / d; 0 <= g && g <= 1 && 0 <= m && m <= 1 ? (s = new c("Intersection"), s.appendPoint(new r.Point(h.x + g * (n.x - h.x), h.y + g * (n.y - h.y)))) : s = new c } else u === 0 || l === 0 ? s = new c("Coincident") : s = new c("Parallel"); return s }, r.Intersection.intersectLinePolygon = function (h, n, o) { var i = new c, s = o.length, u, l, d, g; for (g = 0; g < s; g++)u = o[g], l = o[(g + 1) % s], d = c.intersectLineLine(h, n, u, l), i.appendPoints(d.points); return i.points.length > 0 && (i.status = "Intersection"), i }, r.Intersection.intersectPolygonPolygon = function (h, n) { var o = new c, i = h.length, s; for (s = 0; s < i; s++) { var u = h[s], l = h[(s + 1) % i], d = c.intersectLinePolygon(u, l, n); o.appendPoints(d.points) } return o.points.length > 0 && (o.status = "Intersection"), o }, r.Intersection.intersectPolygonRectangle = function (h, n, o) { var i = n.min(o), s = n.max(o), u = new r.Point(s.x, i.y), l = new r.Point(i.x, s.y), d = c.intersectLinePolygon(i, u, h), g = c.intersectLinePolygon(u, s, h), m = c.intersectLinePolygon(s, l, h), y = c.intersectLinePolygon(l, i, h), w = new c; return w.appendPoints(d.points), w.appendPoints(g.points), w.appendPoints(m.points), w.appendPoints(y.points), w.points.length > 0 && (w.status = "Intersection"), w } }(e), function (f) { var r = f.fabric || (f.fabric = {}); if (r.Color) { r.warn("fabric.Color is already defined."); return } function c(n) { n ? this._tryParsingColor(n) : this.setSource([0, 0, 0, 1]) } r.Color = c, r.Color.prototype = { _tryParsingColor: function (n) { var o; n in c.colorNameMap && (n = c.colorNameMap[n]), n === "transparent" && (o = [255, 255, 255, 0]), o || (o = c.sourceFromHex(n)), o || (o = c.sourceFromRgb(n)), o || (o = c.sourceFromHsl(n)), o || (o = [0, 0, 0, 1]), o && this.setSource(o) }, _rgbToHsl: function (n, o, i) { n /= 255, o /= 255, i /= 255; var s, u, l, d = r.util.array.max([n, o, i]), g = r.util.array.min([n, o, i]); if (l = (d + g) / 2, d === g) s = u = 0; else { var m = d - g; switch (u = l > .5 ? m / (2 - d - g) : m / (d + g), d) { case n: s = (o - i) / m + (o < i ? 6 : 0); break; case o: s = (i - n) / m + 2; break; case i: s = (n - o) / m + 4; break }s /= 6 } return [Math.round(s * 360), Math.round(u * 100), Math.round(l * 100)] }, getSource: function () { return this._source }, setSource: function (n) { this._source = n }, toRgb: function () { var n = this.getSource(); return "rgb(" + n[0] + "," + n[1] + "," + n[2] + ")" }, toRgba: function () { var n = this.getSource(); return "rgba(" + n[0] + "," + n[1] + "," + n[2] + "," + n[3] + ")" }, toHsl: function () { var n = this.getSource(), o = this._rgbToHsl(n[0], n[1], n[2]); return "hsl(" + o[0] + "," + o[1] + "%," + o[2] + "%)" }, toHsla: function () { var n = this.getSource(), o = this._rgbToHsl(n[0], n[1], n[2]); return "hsla(" + o[0] + "," + o[1] + "%," + o[2] + "%," + n[3] + ")" }, toHex: function () { var n = this.getSource(), o, i, s; return o = n[0].toString(16), o = o.length === 1 ? "0" + o : o, i = n[1].toString(16), i = i.length === 1 ? "0" + i : i, s = n[2].toString(16), s = s.length === 1 ? "0" + s : s, o.toUpperCase() + i.toUpperCase() + s.toUpperCase() }, toHexa: function () { var n = this.getSource(), o; return o = Math.round(n[3] * 255), o = o.toString(16), o = o.length === 1 ? "0" + o : o, this.toHex() + o.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (n) { var o = this.getSource(); return o[3] = n, this.setSource(o), this }, toGrayscale: function () { var n = this.getSource(), o = parseInt((n[0] * .3 + n[1] * .59 + n[2] * .11).toFixed(0), 10), i = n[3]; return this.setSource([o, o, o, i]), this }, toBlackWhite: function (n) { var o = this.getSource(), i = (o[0] * .3 + o[1] * .59 + o[2] * .11).toFixed(0), s = o[3]; return n = n || 127, i = Number(i) < Number(n) ? 0 : 255, this.setSource([i, i, i, s]), this }, overlayWith: function (n) { n instanceof c || (n = new c(n)); var o = [], i = this.getAlpha(), s = .5, u = this.getSource(), l = n.getSource(), d; for (d = 0; d < 3; d++)o.push(Math.round(u[d] * (1 - s) + l[d] * s)); return o[3] = i, this.setSource(o), this } }, r.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, r.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, r.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, r.Color.colorNameMap = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#663399", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: "#9ACD32" }; function h(n, o, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? n + (o - n) * 6 * i : i < 1 / 2 ? o : i < 2 / 3 ? n + (o - n) * (2 / 3 - i) * 6 : n } r.Color.fromRgb = function (n) { return c.fromSource(c.sourceFromRgb(n)) }, r.Color.sourceFromRgb = function (n) { var o = n.match(c.reRGBa); if (o) { var i = parseInt(o[1], 10) / (/%$/.test(o[1]) ? 100 : 1) * (/%$/.test(o[1]) ? 255 : 1), s = parseInt(o[2], 10) / (/%$/.test(o[2]) ? 100 : 1) * (/%$/.test(o[2]) ? 255 : 1), u = parseInt(o[3], 10) / (/%$/.test(o[3]) ? 100 : 1) * (/%$/.test(o[3]) ? 255 : 1); return [parseInt(i, 10), parseInt(s, 10), parseInt(u, 10), o[4] ? parseFloat(o[4]) : 1] } }, r.Color.fromRgba = c.fromRgb, r.Color.fromHsl = function (n) { return c.fromSource(c.sourceFromHsl(n)) }, r.Color.sourceFromHsl = function (n) { var o = n.match(c.reHSLa); if (o) { var i = (parseFloat(o[1]) % 360 + 360) % 360 / 360, s = parseFloat(o[2]) / (/%$/.test(o[2]) ? 100 : 1), u = parseFloat(o[3]) / (/%$/.test(o[3]) ? 100 : 1), l, d, g; if (s === 0) l = d = g = u; else { var m = u <= .5 ? u * (s + 1) : u + s - u * s, y = u * 2 - m; l = h(y, m, i + 1 / 3), d = h(y, m, i), g = h(y, m, i - 1 / 3) } return [Math.round(l * 255), Math.round(d * 255), Math.round(g * 255), o[4] ? parseFloat(o[4]) : 1] } }, r.Color.fromHsla = c.fromHsl, r.Color.fromHex = function (n) { return c.fromSource(c.sourceFromHex(n)) }, r.Color.sourceFromHex = function (n) { if (n.match(c.reHex)) { var o = n.slice(n.indexOf("#") + 1), i = o.length === 3 || o.length === 4, s = o.length === 8 || o.length === 4, u = i ? o.charAt(0) + o.charAt(0) : o.substring(0, 2), l = i ? o.charAt(1) + o.charAt(1) : o.substring(2, 4), d = i ? o.charAt(2) + o.charAt(2) : o.substring(4, 6), g = s ? i ? o.charAt(3) + o.charAt(3) : o.substring(6, 8) : "FF"; return [parseInt(u, 16), parseInt(l, 16), parseInt(d, 16), parseFloat((parseInt(g, 16) / 255).toFixed(2))] } }, r.Color.fromSource = function (n) { var o = new c; return o.setSource(n), o } }(e), function (f) { var r = f.fabric || (f.fabric = {}), c = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], h = ["ns", "nesw", "ew", "nwse"], n = {}, o = "left", i = "top", s = "right", u = "bottom", l = "center", d = { top: u, bottom: i, left: s, right: o, center: l }, g = r.util.radiansToDegrees, m = Math.sign || function (J) { return (J > 0) - (J < 0) || +J }; function y(J, H) { var nt = J.angle + g(Math.atan2(H.y, H.x)) + 360; return Math.round(nt % 360 / 45) } function w(J, H) { var nt = H.transform.target, it = nt.canvas, Y = r.util.object.clone(H); Y.target = nt, it && it.fire("object:" + J, Y), nt.fire(J, H) } function C(J, H) { var nt = H.canvas, it = nt.uniScaleKey, Y = J[it]; return nt.uniformScaling && !Y || !nt.uniformScaling && Y } function T(J) { return J.originX === l && J.originY === l } function A(J, H, nt) { var it = J.lockScalingX, Y = J.lockScalingY; return !!(it && Y || !H && (it || Y) && nt || it && H === "x" || Y && H === "y") } function U(J, H, nt) { var it = "not-allowed", Y = C(J, nt), at = ""; if (H.x !== 0 && H.y === 0 ? at = "x" : H.x === 0 && H.y !== 0 && (at = "y"), A(nt, at, Y)) return it; var pt = y(nt, H); return c[pt] + "-resize" } function R(J, H, nt) { var it = "not-allowed"; if (H.x !== 0 && nt.lockSkewingY || H.y !== 0 && nt.lockSkewingX) return it; var Y = y(nt, H) % 4; return h[Y] + "-resize" } function $(J, H, nt) { return J[nt.canvas.altActionKey] ? n.skewCursorStyleHandler(J, H, nt) : n.scaleCursorStyleHandler(J, H, nt) } function L(J, H, nt) { var it = J[nt.canvas.altActionKey]; if (H.x === 0) return it ? "skewX" : "scaleY"; if (H.y === 0) return it ? "skewY" : "scaleX" } function B(J, H, nt) { return nt.lockRotation ? "not-allowed" : H.cursorStyle } function N(J, H, nt, it) { return { e: J, transform: H, pointer: { x: nt, y: it } } } function K(J) { return function (H, nt, it, Y) { var at = nt.target, pt = at.getCenterPoint(), St = at.translateToOriginPoint(pt, nt.originX, nt.originY), bt = J(H, nt, it, Y); return at.setPositionByOrigin(St, nt.originX, nt.originY), bt } } function st(J, H) { return function (nt, it, Y, at) { var pt = H(nt, it, Y, at); return pt && w(J, N(nt, it, Y, at)), pt } } function ft(J, H, nt, it, Y) { var at = J.target, pt = at.controls[J.corner], St = at.canvas.getZoom(), bt = at.padding / St, tt = at.toLocalPoint(new r.Point(it, Y), H, nt); return tt.x >= bt && (tt.x -= bt), tt.x <= -bt && (tt.x += bt), tt.y >= bt && (tt.y -= bt), tt.y <= bt && (tt.y += bt), tt.x -= pt.offsetX, tt.y -= pt.offsetY, tt } function ht(J) { return J.flipX !== J.flipY } function k(J, H, nt, it, Y) { if (J[H] !== 0) { var at = J._getTransformedDimensions()[it], pt = Y / at * J[nt]; J.set(nt, pt) } } function M(J, H, nt, it) { var Y = H.target, at = Y._getTransformedDimensions(0, Y.skewY), pt = ft(H, H.originX, H.originY, nt, it), St = Math.abs(pt.x * 2) - at.x, bt = Y.skewX, tt; St < 2 ? tt = 0 : (tt = g(Math.atan2(St / Y.scaleX, at.y / Y.scaleY)), H.originX === o && H.originY === u && (tt = -tt), H.originX === s && H.originY === i && (tt = -tt), ht(Y) && (tt = -tt)); var wt = bt !== tt; if (wt) { var kt = Y._getTransformedDimensions().y; Y.set("skewX", tt), k(Y, "skewY", "scaleY", "y", kt) } return wt } function E(J, H, nt, it) { var Y = H.target, at = Y._getTransformedDimensions(Y.skewX, 0), pt = ft(H, H.originX, H.originY, nt, it), St = Math.abs(pt.y * 2) - at.y, bt = Y.skewY, tt; St < 2 ? tt = 0 : (tt = g(Math.atan2(St / Y.scaleY, at.x / Y.scaleX)), H.originX === o && H.originY === u && (tt = -tt), H.originX === s && H.originY === i && (tt = -tt), ht(Y) && (tt = -tt)); var wt = bt !== tt; if (wt) { var kt = Y._getTransformedDimensions().x; Y.set("skewY", tt), k(Y, "skewX", "scaleX", "x", kt) } return wt } function P(J, H, nt, it) { var Y = H.target, at = Y.skewX, pt, St = H.originY; if (Y.lockSkewingX) return !1; if (at === 0) { var bt = ft(H, l, l, nt, it); bt.x > 0 ? pt = o : pt = s } else at > 0 && (pt = St === i ? o : s), at < 0 && (pt = St === i ? s : o), ht(Y) && (pt = pt === o ? s : o); H.originX = pt; var tt = st("skewing", K(M)); return tt(J, H, nt, it) } function W(J, H, nt, it) { var Y = H.target, at = Y.skewY, pt, St = H.originX; if (Y.lockSkewingY) return !1; if (at === 0) { var bt = ft(H, l, l, nt, it); bt.y > 0 ? pt = i : pt = u } else at > 0 && (pt = St === o ? i : u), at < 0 && (pt = St === o ? u : i), ht(Y) && (pt = pt === i ? u : i); H.originY = pt; var tt = st("skewing", K(E)); return tt(J, H, nt, it) } function O(J, H, nt, it) { var Y = H, at = Y.target, pt = at.translateToOriginPoint(at.getCenterPoint(), Y.originX, Y.originY); if (at.lockRotation) return !1; var St = Math.atan2(Y.ey - pt.y, Y.ex - pt.x), bt = Math.atan2(it - pt.y, nt - pt.x), tt = g(bt - St + Y.theta), wt = !0; if (at.snapAngle > 0) { var kt = at.snapAngle, et = at.snapThreshold || kt, D = Math.ceil(tt / kt) * kt, vt = Math.floor(tt / kt) * kt; Math.abs(tt - vt) < et ? tt = vt : Math.abs(tt - D) < et && (tt = D) } return tt < 0 && (tt = 360 + tt), tt %= 360, wt = at.angle !== tt, at.angle = tt, wt } function x(J, H, nt, it, Y) { Y = Y || {}; var at = H.target, pt = at.lockScalingX, St = at.lockScalingY, bt = Y.by, tt, wt, kt, et, D = C(J, at), vt = A(at, bt, D), _t, Tt, $t = H.gestureScale; if (vt) return !1; if ($t) wt = H.scaleX * $t, kt = H.scaleY * $t; else { if (tt = ft(H, H.originX, H.originY, nt, it), _t = bt !== "y" ? m(tt.x) : 1, Tt = bt !== "x" ? m(tt.y) : 1, H.signX || (H.signX = _t), H.signY || (H.signY = Tt), at.lockScalingFlip && (H.signX !== _t || H.signY !== Tt)) return !1; if (et = at._getTransformedDimensions(), D && !bt) { var Gt = Math.abs(tt.x) + Math.abs(tt.y), It = H.original, jt = Math.abs(et.x * It.scaleX / at.scaleX) + Math.abs(et.y * It.scaleY / at.scaleY), we = Gt / jt; wt = It.scaleX * we, kt = It.scaleY * we } else wt = Math.abs(tt.x * at.scaleX / et.x), kt = Math.abs(tt.y * at.scaleY / et.y); T(H) && (wt *= 2, kt *= 2), H.signX !== _t && bt !== "y" && (H.originX = d[H.originX], wt *= -1, H.signX = _t), H.signY !== Tt && bt !== "x" && (H.originY = d[H.originY], kt *= -1, H.signY = Tt) } var _n = at.scaleX, Hn = at.scaleY; return bt ? (bt === "x" && at.set("scaleX", wt), bt === "y" && at.set("scaleY", kt)) : (!pt && at.set("scaleX", wt), !St && at.set("scaleY", kt)), _n !== at.scaleX || Hn !== at.scaleY } function F(J, H, nt, it) { return x(J, H, nt, it) } function z(J, H, nt, it) { return x(J, H, nt, it, { by: "x" }) } function q(J, H, nt, it) { return x(J, H, nt, it, { by: "y" }) } function X(J, H, nt, it) { return J[H.target.canvas.altActionKey] ? n.skewHandlerX(J, H, nt, it) : n.scalingY(J, H, nt, it) } function ot(J, H, nt, it) { return J[H.target.canvas.altActionKey] ? n.skewHandlerY(J, H, nt, it) : n.scalingX(J, H, nt, it) } function ct(J, H, nt, it) { var Y = H.target, at = ft(H, H.originX, H.originY, nt, it), pt = Y.strokeWidth / (Y.strokeUniform ? Y.scaleX : 1), St = T(H) ? 2 : 1, bt = Y.width, tt = Math.abs(at.x * St / Y.scaleX) - pt; return Y.set("width", Math.max(tt, 0)), bt !== tt } function gt(J, H, nt, it) { var Y = H.target, at = nt - H.offsetX, pt = it - H.offsetY, St = !Y.get("lockMovementX") && Y.left !== at, bt = !Y.get("lockMovementY") && Y.top !== pt; return St && Y.set("left", at), bt && Y.set("top", pt), (St || bt) && w("moving", N(J, H, nt, it)), St || bt } n.scaleCursorStyleHandler = U, n.skewCursorStyleHandler = R, n.scaleSkewCursorStyleHandler = $, n.rotationWithSnapping = st("rotating", K(O)), n.scalingEqually = st("scaling", K(F)), n.scalingX = st("scaling", K(z)), n.scalingY = st("scaling", K(q)), n.scalingYOrSkewingX = X, n.scalingXOrSkewingY = ot, n.changeWidth = st("resizing", K(ct)), n.skewHandlerX = P, n.skewHandlerY = W, n.dragHandler = gt, n.scaleOrSkewActionName = L, n.rotationStyleHandler = B, n.fireEvent = w, n.wrapWithFixedAnchor = K, n.wrapWithFireEvent = st, n.getLocalPoint = ft, r.controlsUtils = n }(e), function (f) { var r = f.fabric || (f.fabric = {}), c = r.util.degreesToRadians, h = r.controlsUtils; function n(i, s, u, l, d) { l = l || {}; var g = this.sizeX || l.cornerSize || d.cornerSize, m = this.sizeY || l.cornerSize || d.cornerSize, y = typeof l.transparentCorners != "undefined" ? l.transparentCorners : d.transparentCorners, w = y ? "stroke" : "fill", C = !y && (l.cornerStrokeColor || d.cornerStrokeColor), T = s, A = u, U; i.save(), i.fillStyle = l.cornerColor || d.cornerColor, i.strokeStyle = l.cornerStrokeColor || d.cornerStrokeColor, g > m ? (U = g, i.scale(1, m / g), A = u * g / m) : m > g ? (U = m, i.scale(g / m, 1), T = s * m / g) : U = g, i.lineWidth = 1, i.beginPath(), i.arc(T, A, U / 2, 0, 2 * Math.PI, !1), i[w](), C && i.stroke(), i.restore() } function o(i, s, u, l, d) { l = l || {}; var g = this.sizeX || l.cornerSize || d.cornerSize, m = this.sizeY || l.cornerSize || d.cornerSize, y = typeof l.transparentCorners != "undefined" ? l.transparentCorners : d.transparentCorners, w = y ? "stroke" : "fill", C = !y && (l.cornerStrokeColor || d.cornerStrokeColor), T = g / 2, A = m / 2; i.save(), i.fillStyle = l.cornerColor || d.cornerColor, i.strokeStyle = l.cornerStrokeColor || d.cornerStrokeColor, i.lineWidth = 1, i.translate(s, u), i.rotate(c(d.angle)), i[w + "Rect"](-T, -A, g, m), C && i.strokeRect(-T, -A, g, m), i.restore() } h.renderCircleControl = n, h.renderSquareControl = o }(e), function (f) { var r = f.fabric || (f.fabric = {}); function c(h) { for (var n in h) this[n] = h[n] } r.Control = c, r.Control.prototype = { visible: !0, actionName: "scale", angle: 0, x: 0, y: 0, offsetX: 0, offsetY: 0, sizeX: null, sizeY: null, touchSizeX: null, touchSizeY: null, cursorStyle: "crosshair", withConnection: !1, actionHandler: function () { }, mouseDownHandler: function () { }, mouseUpHandler: function () { }, getActionHandler: function () { return this.actionHandler }, getMouseDownHandler: function () { return this.mouseDownHandler }, getMouseUpHandler: function () { return this.mouseUpHandler }, cursorStyleHandler: function (h, n) { return n.cursorStyle }, getActionName: function (h, n) { return n.actionName }, getVisibility: function (h, n) { var o = h._controlsVisibility; return o && typeof o[n] != "undefined" ? o[n] : this.visible }, setVisibility: function (h) { this.visible = h }, positionHandler: function (h, n) { var o = r.util.transformPoint({ x: this.x * h.x + this.offsetX, y: this.y * h.y + this.offsetY }, n); return o }, calcCornerCoords: function (h, n, o, i, s) { var u, l, d, g, m = s ? this.touchSizeX : this.sizeX, y = s ? this.touchSizeY : this.sizeY; if (m && y && m !== y) { var w = Math.atan2(y, m), C = Math.sqrt(m * m + y * y) / 2, T = w - r.util.degreesToRadians(h), A = Math.PI / 2 - w - r.util.degreesToRadians(h); u = C * r.util.cos(T), l = C * r.util.sin(T), d = C * r.util.cos(A), g = C * r.util.sin(A) } else { var U = m && y ? m : n; C = U * .7071067812; var T = r.util.degreesToRadians(45 - h); u = d = C * r.util.cos(T), l = g = C * r.util.sin(T) } return { tl: { x: o - g, y: i - d }, tr: { x: o + u, y: i - l }, bl: { x: o - u, y: i + l }, br: { x: o + g, y: i + d } } }, render: function (h, n, o, i, s) { switch (i = i || {}, i.cornerStyle || s.cornerStyle) { case "circle": r.controlsUtils.renderCircleControl.call(this, h, n, o, i, s); break; default: r.controlsUtils.renderSquareControl.call(this, h, n, o, i, s) } } } }(e), function () {
	function f(o, i) { var s = o.getAttribute("style"), u = o.getAttribute("offset") || 0, l, d, g, m; if (u = parseFloat(u) / (/%$/.test(u) ? 100 : 1), u = u < 0 ? 0 : u > 1 ? 1 : u, s) { var y = s.split(/\s*;\s*/); for (y[y.length - 1] === "" && y.pop(), m = y.length; m--;) { var w = y[m].split(/\s*:\s*/), C = w[0].trim(), T = w[1].trim(); C === "stop-color" ? l = T : C === "stop-opacity" && (g = T) } } return l || (l = o.getAttribute("stop-color") || "rgb(0,0,0)"), g || (g = o.getAttribute("stop-opacity")), l = new t.Color(l), d = l.getAlpha(), g = isNaN(parseFloat(g)) ? 1 : parseFloat(g), g *= d * i, { offset: u, color: l.toRgb(), opacity: g } } function r(o) { return { x1: o.getAttribute("x1") || 0, y1: o.getAttribute("y1") || 0, x2: o.getAttribute("x2") || "100%", y2: o.getAttribute("y2") || 0 } } function c(o) { return { x1: o.getAttribute("fx") || o.getAttribute("cx") || "50%", y1: o.getAttribute("fy") || o.getAttribute("cy") || "50%", r1: 0, x2: o.getAttribute("cx") || "50%", y2: o.getAttribute("cy") || "50%", r2: o.getAttribute("r") || "50%" } } var h = t.util.object.clone; t.Gradient = t.util.createClass({
		offsetX: 0, offsetY: 0, gradientTransform: null, gradientUnits: "pixels", type: "linear", initialize: function (o) { o || (o = {}), o.coords || (o.coords = {}); var i, s = this; Object.keys(o).forEach(function (u) { s[u] = o[u] }), this.id ? this.id += "_" + t.Object.__uid++ : this.id = t.Object.__uid++, i = { x1: o.coords.x1 || 0, y1: o.coords.y1 || 0, x2: o.coords.x2 || 0, y2: o.coords.y2 || 0 }, this.type === "radial" && (i.r1 = o.coords.r1 || 0, i.r2 = o.coords.r2 || 0), this.coords = i, this.colorStops = o.colorStops.slice() }, addColorStop: function (o) { for (var i in o) { var s = new t.Color(o[i]); this.colorStops.push({ offset: parseFloat(i), color: s.toRgb(), opacity: s.getAlpha() }) } return this }, toObject: function (o) { var i = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform }; return t.util.populateWithProperties(this, i, o), i }, toSVG: function (o, d) {
			var s = h(this.coords, !0), u, l, d = d || {}, g, m, y = h(this.colorStops, !0), w = s.r1 > s.r2, C = this.gradientTransform ? this.gradientTransform.concat() : t.iMatrix.concat(), T = -this.offsetX, A = -this.offsetY, U = !!d.additionalTransform, R = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox"; if (y.sort(function (K, st) { return K.offset - st.offset }), R === "objectBoundingBox" ? (T /= o.width, A /= o.height) : (T += o.width / 2, A += o.height / 2), o.type === "path" && this.gradientUnits !== "percentage" && (T -= o.pathOffset.x, A -= o.pathOffset.y), C[4] -= T, C[5] -= A, m = 'id="SVGID_' + this.id + '" gradientUnits="' + R + '"', m += ' gradientTransform="' + (U ? d.additionalTransform + " " : "") + t.util.matrixToSVG(C) + '" ', this.type === "linear" ? g = ["<linearGradient ", m, ' x1="', s.x1, '" y1="', s.y1, '" x2="', s.x2, '" y2="', s.y2, `">
`] : this.type === "radial" && (g = ["<radialGradient ", m, ' cx="', w ? s.x1 : s.x2, '" cy="', w ? s.y1 : s.y2, '" r="', w ? s.r1 : s.r2, '" fx="', w ? s.x2 : s.x1, '" fy="', w ? s.y2 : s.y1, `">
`]), this.type === "radial") { if (w) for (y = y.concat(), y.reverse(), u = 0, l = y.length; u < l; u++)y[u].offset = 1 - y[u].offset; var $ = Math.min(s.r1, s.r2); if ($ > 0) { var L = Math.max(s.r1, s.r2), B = $ / L; for (u = 0, l = y.length; u < l; u++)y[u].offset += B * (1 - y[u].offset) } } for (u = 0, l = y.length; u < l; u++) {
				var N = y[u]; g.push("<stop ", 'offset="', N.offset * 100 + "%", '" style="stop-color:', N.color, typeof N.opacity != "undefined" ? ";stop-opacity: " + N.opacity : ";", `"/>
`)
			} return g.push(this.type === "linear" ? `</linearGradient>
`: `</radialGradient>
`), g.join("")
		}, toLive: function (o) { var i, s = t.util.object.clone(this.coords), u, l; if (this.type) { for (this.type === "linear" ? i = o.createLinearGradient(s.x1, s.y1, s.x2, s.y2) : this.type === "radial" && (i = o.createRadialGradient(s.x1, s.y1, s.r1, s.x2, s.y2, s.r2)), u = 0, l = this.colorStops.length; u < l; u++) { var d = this.colorStops[u].color, g = this.colorStops[u].opacity, m = this.colorStops[u].offset; typeof g != "undefined" && (d = new t.Color(d).setAlpha(g).toRgba()), i.addColorStop(m, d) } return i } }
	}), t.util.object.extend(t.Gradient, { fromElement: function (o, i, s, u) { var l = parseFloat(s) / (/%$/.test(s) ? 100 : 1); l = l < 0 ? 0 : l > 1 ? 1 : l, isNaN(l) && (l = 1); var d = o.getElementsByTagName("stop"), g, m = o.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", y = o.getAttribute("gradientTransform") || "", w = [], C, T, A = 0, U = 0, R; for (o.nodeName === "linearGradient" || o.nodeName === "LINEARGRADIENT" ? (g = "linear", C = r(o)) : (g = "radial", C = c(o)), T = d.length; T--;)w.push(f(d[T], l)); R = t.parseTransformAttribute(y), n(i, C, u, m), m === "pixels" && (A = -i.left, U = -i.top); var $ = new t.Gradient({ id: o.getAttribute("id"), type: g, coords: C, colorStops: w, gradientUnits: m, gradientTransform: R, offsetX: A, offsetY: U }); return $ } }); function n(o, i, s, u) { var l, d; Object.keys(i).forEach(function (g) { l = i[g], l === "Infinity" ? d = 1 : l === "-Infinity" ? d = 0 : (d = parseFloat(i[g], 10), typeof l == "string" && /^(\d+\.\d+)%|(\d+)%$/.test(l) && (d *= .01, u === "pixels" && ((g === "x1" || g === "x2" || g === "r2") && (d *= s.viewBoxWidth || s.width), (g === "y1" || g === "y2") && (d *= s.viewBoxHeight || s.height)))), i[g] = d }) }
}(), function () {
	var f = t.util.toFixed; t.Pattern = t.util.createClass({
		repeat: "repeat", offsetX: 0, offsetY: 0, crossOrigin: "", patternTransform: null, initialize: function (r, c) { if (r || (r = {}), this.id = t.Object.__uid++, this.setOptions(r), !r.source || r.source && typeof r.source != "string") { c && c(this); return } else { var h = this; this.source = t.util.createImage(), t.util.loadImage(r.source, function (n, o) { h.source = n, c && c(h, o) }, null, this.crossOrigin) } }, toObject: function (r) { var c = t.Object.NUM_FRACTION_DIGITS, h, n; return typeof this.source.src == "string" ? h = this.source.src : typeof this.source == "object" && this.source.toDataURL && (h = this.source.toDataURL()), n = { type: "pattern", source: h, repeat: this.repeat, crossOrigin: this.crossOrigin, offsetX: f(this.offsetX, c), offsetY: f(this.offsetY, c), patternTransform: this.patternTransform ? this.patternTransform.concat() : null }, t.util.populateWithProperties(this, n, r), n }, toSVG: function (r) {
			var c = typeof this.source == "function" ? this.source() : this.source, h = c.width / r.width, n = c.height / r.height, o = this.offsetX / r.width, i = this.offsetY / r.height, s = ""; return (this.repeat === "repeat-x" || this.repeat === "no-repeat") && (n = 1, i && (n += Math.abs(i))), (this.repeat === "repeat-y" || this.repeat === "no-repeat") && (h = 1, o && (h += Math.abs(o))), c.src ? s = c.src : c.toDataURL && (s = c.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + o + '" y="' + i + '" width="' + h + '" height="' + n + `">
<image x="0" y="0" width="`+ c.width + '" height="' + c.height + '" xlink:href="' + s + `"></image>
</pattern>
`}, setOptions: function (r) { for (var c in r) this[c] = r[c] }, toLive: function (r) { var c = this.source; return !c || typeof c.src != "undefined" && (!c.complete || c.naturalWidth === 0 || c.naturalHeight === 0) ? "" : r.createPattern(c, this.repeat) }
	})
}(), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.toFixed; if (r.Shadow) { r.warn("fabric.Shadow is already defined."); return } r.Shadow = r.util.createClass({
		color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1, initialize: function (h) { typeof h == "string" && (h = this._parseShadow(h)); for (var n in h) this[n] = h[n]; this.id = r.Object.__uid++ }, _parseShadow: function (h) { var n = h.trim(), o = r.Shadow.reOffsetsAndBlur.exec(n) || [], i = n.replace(r.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)"; return { color: i.trim(), offsetX: parseFloat(o[1], 10) || 0, offsetY: parseFloat(o[2], 10) || 0, blur: parseFloat(o[3], 10) || 0 } }, toString: function () { return [this.offsetX, this.offsetY, this.blur, this.color].join("px ") }, toSVG: function (h) {
			var n = 40, o = 40, i = r.Object.NUM_FRACTION_DIGITS, s = r.util.rotateVector({ x: this.offsetX, y: this.offsetY }, r.util.degreesToRadians(-h.angle)), u = 20, l = new r.Color(this.color); return h.width && h.height && (n = c((Math.abs(s.x) + this.blur) / h.width, i) * 100 + u, o = c((Math.abs(s.y) + this.blur) / h.height, i) * 100 + u), h.flipX && (s.x *= -1), h.flipY && (s.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + o + '%" height="' + (100 + 2 * o) + '%" x="-' + n + '%" width="' + (100 + 2 * n) + `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`+ c(this.blur ? this.blur / 2 : 0, i) + `"></feGaussianBlur>
	<feOffset dx="`+ c(s.x, i) + '" dy="' + c(s.y, i) + `" result="oBlur" ></feOffset>
	<feFlood flood-color="`+ l.toRgb() + '" flood-opacity="' + l.getAlpha() + `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`}, toObject: function () { if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling }; var h = {}, n = r.Shadow.prototype; return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function (o) { this[o] !== n[o] && (h[o] = this[o]) }, this), h }
	}), r.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/
}(e), function () {
	if (t.StaticCanvas) { t.warn("fabric.StaticCanvas is already defined."); return } var f = t.util.object.extend, r = t.util.getElementOffset, c = t.util.removeFromArray, h = t.util.toFixed, n = t.util.transformPoint, o = t.util.invertTransform, i = t.util.getNodeCanvas, s = t.util.createCanvasElement, u = new Error("Could not initialize `canvas` element"); t.StaticCanvas = t.util.createClass(t.CommonMethods, {
		initialize: function (l, d) { d || (d = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(l, d) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: t.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !0, clipPath: void 0, _initStatic: function (l, d) { var g = this.requestRenderAllBound; this._objects = [], this._createLowerCanvas(l), this._initOptions(d), this.interactive || this._initRetinaScaling(), d.overlayImage && this.setOverlayImage(d.overlayImage, g), d.backgroundImage && this.setBackgroundImage(d.backgroundImage, g), d.backgroundColor && this.setBackgroundColor(d.backgroundColor, g), d.overlayColor && this.setOverlayColor(d.overlayColor, g), this.calcOffset() }, _isRetinaScaling: function () { return t.devicePixelRatio > 1 && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? Math.max(1, t.devicePixelRatio) : 1 }, _initRetinaScaling: function () { if (this._isRetinaScaling()) { var l = t.devicePixelRatio; this.__initRetinaScaling(l, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(l, this.upperCanvasEl, this.contextTop) } }, __initRetinaScaling: function (l, d, g) { d.setAttribute("width", this.width * l), d.setAttribute("height", this.height * l), g.scale(l, l) }, calcOffset: function () { return this._offset = r(this.lowerCanvasEl), this }, setOverlayImage: function (l, d, g) { return this.__setBgOverlayImage("overlayImage", l, d, g) }, setBackgroundImage: function (l, d, g) { return this.__setBgOverlayImage("backgroundImage", l, d, g) }, setOverlayColor: function (l, d) { return this.__setBgOverlayColor("overlayColor", l, d) }, setBackgroundColor: function (l, d) { return this.__setBgOverlayColor("backgroundColor", l, d) }, __setBgOverlayImage: function (l, d, g, m) { return typeof d == "string" ? t.util.loadImage(d, function (y, w) { if (y) { var C = new t.Image(y, m); this[l] = C, C.canvas = this } g && g(y, w) }, this, m && m.crossOrigin) : (m && d.setOptions(m), this[l] = d, d && (d.canvas = this), g && g(d, !1)), this }, __setBgOverlayColor: function (l, d, g) { return this[l] = d, this._initGradient(d, l), this._initPattern(d, l, g), this }, _createCanvasElement: function () { var l = s(); if (!l || (l.style || (l.style = {}), typeof l.getContext == "undefined")) throw u; return l }, _initOptions: function (l) { var d = this.lowerCanvasEl; this._setOptions(l), this.width = this.width || parseInt(d.width, 10) || 0, this.height = this.height || parseInt(d.height, 10) || 0, this.lowerCanvasEl.style && (d.width = this.width, d.height = this.height, d.style.width = this.width + "px", d.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (l) { l && l.getContext ? this.lowerCanvasEl = l : this.lowerCanvasEl = t.util.getById(l) || this._createCanvasElement(), t.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (l, d) { return this.setDimensions({ width: l }, d) }, setHeight: function (l, d) { return this.setDimensions({ height: l }, d) }, setDimensions: function (l, d) { var g; d = d || {}; for (var m in l) g = l[m], d.cssOnly || (this._setBackstoreDimension(m, l[m]), g += "px", this.hasLostContext = !0), d.backstoreOnly || this._setCssDimension(m, g); return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), d.cssOnly || this.requestRenderAll(), this }, _setBackstoreDimension: function (l, d) { return this.lowerCanvasEl[l] = d, this.upperCanvasEl && (this.upperCanvasEl[l] = d), this.cacheCanvasEl && (this.cacheCanvasEl[l] = d), this[l] = d, this }, _setCssDimension: function (l, d) { return this.lowerCanvasEl.style[l] = d, this.upperCanvasEl && (this.upperCanvasEl.style[l] = d), this.wrapperEl && (this.wrapperEl.style[l] = d), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (l) { var d = this._activeObject, g = this.backgroundImage, m = this.overlayImage, y, w, C; for (this.viewportTransform = l, w = 0, C = this._objects.length; w < C; w++)y = this._objects[w], y.group || y.setCoords(!0); return d && d.setCoords(), g && g.setCoords(!0), m && m.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this }, zoomToPoint: function (l, d) { var g = l, m = this.viewportTransform.slice(0); l = n(l, o(this.viewportTransform)), m[0] = d, m[3] = d; var y = n(l, m); return m[4] += g.x - y.x, m[5] += g.y - y.y, this.setViewportTransform(m) }, setZoom: function (l) { return this.zoomToPoint(new t.Point(0, 0), l), this }, absolutePan: function (l) { var d = this.viewportTransform.slice(0); return d[4] = -l.x, d[5] = -l.y, this.setViewportTransform(d) }, relativePan: function (l) { return this.absolutePan(new t.Point(-l.x - this.viewportTransform[4], -l.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (l) { this.stateful && l.setupState(), l._set("canvas", this), l.setCoords(), this.fire("object:added", { target: l }), l.fire("added") }, _onObjectRemoved: function (l) { this.fire("object:removed", { target: l }), l.fire("removed"), delete l.canvas }, clearContext: function (l) { return l.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this }, renderAll: function () { var l = this.contextContainer; return this.renderCanvas(l, this._objects), this }, renderAndReset: function () { this.isRendering = 0, this.renderAll() }, requestRenderAll: function () { return this.isRendering || (this.isRendering = t.util.requestAnimFrame(this.renderAndResetBound)), this }, calcViewportBoundaries: function () { var l = {}, d = this.width, g = this.height, m = o(this.viewportTransform); return l.tl = n({ x: 0, y: 0 }, m), l.br = n({ x: d, y: g }, m), l.tr = new t.Point(l.br.x, l.tl.y), l.bl = new t.Point(l.tl.x, l.br.y), this.vptCoords = l, l }, cancelRequestedRender: function () { this.isRendering && (t.util.cancelAnimFrame(this.isRendering), this.isRendering = 0) }, renderCanvas: function (l, d) { var g = this.viewportTransform, m = this.clipPath; this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(l), t.util.setImageSmoothing(l, this.imageSmoothingEnabled), this.fire("before:render", { ctx: l }), this._renderBackground(l), l.save(), l.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._renderObjects(l, d), l.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(l), m && (m.canvas = this, m.shouldCache(), m._transformDone = !0, m.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(l)), this._renderOverlay(l), this.controlsAboveOverlay && this.interactive && this.drawControls(l), this.fire("after:render", { ctx: l }) }, drawClipPathOnCanvas: function (l) { var d = this.viewportTransform, g = this.clipPath; l.save(), l.transform(d[0], d[1], d[2], d[3], d[4], d[5]), l.globalCompositeOperation = "destination-in", g.transform(l), l.scale(1 / g.zoomX, 1 / g.zoomY), l.drawImage(g._cacheCanvas, -g.cacheTranslationX, -g.cacheTranslationY), l.restore() }, _renderObjects: function (l, d) { var g, m; for (g = 0, m = d.length; g < m; ++g)d[g] && d[g].render(l) }, _renderBackgroundOrOverlay: function (l, d) { var g = this[d + "Color"], m = this[d + "Image"], y = this.viewportTransform, w = this[d + "Vpt"]; if (!(!g && !m)) { if (g) { l.save(), l.beginPath(), l.moveTo(0, 0), l.lineTo(this.width, 0), l.lineTo(this.width, this.height), l.lineTo(0, this.height), l.closePath(), l.fillStyle = g.toLive ? g.toLive(l, this) : g, w && l.transform(y[0], y[1], y[2], y[3], y[4], y[5]), l.transform(1, 0, 0, 1, g.offsetX || 0, g.offsetY || 0); var C = g.gradientTransform || g.patternTransform; C && l.transform(C[0], C[1], C[2], C[3], C[4], C[5]), l.fill(), l.restore() } m && (l.save(), w && l.transform(y[0], y[1], y[2], y[3], y[4], y[5]), m.render(l), l.restore()) } }, _renderBackground: function (l) { this._renderBackgroundOrOverlay(l, "background") }, _renderOverlay: function (l) { this._renderBackgroundOrOverlay(l, "overlay") }, getCenter: function () { return { top: this.height / 2, left: this.width / 2 } }, getCenterPoint: function () { return new t.Point(this.width / 2, this.height / 2) }, centerObjectH: function (l) { return this._centerObject(l, new t.Point(this.getCenterPoint().x, l.getCenterPoint().y)) }, centerObjectV: function (l) { return this._centerObject(l, new t.Point(l.getCenterPoint().x, this.getCenterPoint().y)) }, centerObject: function (l) { var d = this.getCenterPoint(); return this._centerObject(l, d) }, viewportCenterObject: function (l) { var d = this.getVpCenter(); return this._centerObject(l, d) }, viewportCenterObjectH: function (l) { var d = this.getVpCenter(); return this._centerObject(l, new t.Point(d.x, l.getCenterPoint().y)), this }, viewportCenterObjectV: function (l) { var d = this.getVpCenter(); return this._centerObject(l, new t.Point(l.getCenterPoint().x, d.y)) }, getVpCenter: function () { var l = this.getCenterPoint(), d = o(this.viewportTransform); return n(l, d) }, _centerObject: function (l, d) { return l.setPositionByOrigin(d, "center", "center"), l.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this }, toDatalessJSON: function (l) { return this.toDatalessObject(l) }, toObject: function (l) { return this._toObjectMethod("toObject", l) }, toDatalessObject: function (l) { return this._toObjectMethod("toDatalessObject", l) }, _toObjectMethod: function (l, d) { var g = this.clipPath, m = { version: t.version, objects: this._toObjects(l, d) }; return g && !g.excludeFromExport && (m.clipPath = this._toObject(this.clipPath, l, d)), f(m, this.__serializeBgOverlay(l, d)), t.util.populateWithProperties(this, m, d), m }, _toObjects: function (l, d) { return this._objects.filter(function (g) { return !g.excludeFromExport }).map(function (g) { return this._toObject(g, l, d) }, this) }, _toObject: function (l, d, g) { var m; this.includeDefaultValues || (m = l.includeDefaultValues, l.includeDefaultValues = !1); var y = l[d](g); return this.includeDefaultValues || (l.includeDefaultValues = m), y }, __serializeBgOverlay: function (l, d) { var g = {}, m = this.backgroundImage, y = this.overlayImage, w = this.backgroundColor, C = this.overlayColor; return w && w.toObject ? w.excludeFromExport || (g.background = w.toObject(d)) : w && (g.background = w), C && C.toObject ? C.excludeFromExport || (g.overlay = C.toObject(d)) : C && (g.overlay = C), m && !m.excludeFromExport && (g.backgroundImage = this._toObject(m, l, d)), y && !y.excludeFromExport && (g.overlayImage = this._toObject(y, l, d)), g }, svgViewportTransformation: !0, toSVG: function (l, d) {
			l || (l = {}), l.reviver = d; var g = []; return this._setSVGPreamble(g, l), this._setSVGHeader(g, l), this.clipPath && g.push('<g clip-path="url(#' + this.clipPath.clipPathId + `)" >
`), this._setSVGBgOverlayColor(g, "background"), this._setSVGBgOverlayImage(g, "backgroundImage", d), this._setSVGObjects(g, d), this.clipPath && g.push(`</g>
`), this._setSVGBgOverlayColor(g, "overlay"), this._setSVGBgOverlayImage(g, "overlayImage", d), g.push("</svg>"), g.join("")
		}, _setSVGPreamble: function (l, d) {
			d.suppressPreamble || l.push('<?xml version="1.0" encoding="', d.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`)
		}, _setSVGHeader: function (l, d) {
			var g = d.width || this.width, m = d.height || this.height, y, w = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', C = t.Object.NUM_FRACTION_DIGITS; d.viewBox ? w = 'viewBox="' + d.viewBox.x + " " + d.viewBox.y + " " + d.viewBox.width + " " + d.viewBox.height + '" ' : this.svgViewportTransformation && (y = this.viewportTransform, w = 'viewBox="' + h(-y[4] / y[0], C) + " " + h(-y[5] / y[3], C) + " " + h(this.width / y[0], C) + " " + h(this.height / y[3], C) + '" '), l.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', g, '" ', 'height="', m, '" ', w, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", t.version, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(d), `</defs>
`)
		}, createSVGClipPathMarkup: function (l) {
			var d = this.clipPath; return d ? (d.clipPathId = "CLIPPATH_" + t.Object.__uid++, '<clipPath id="' + d.clipPathId + `" >
`+ this.clipPath.toClipPathSVG(l.reviver) + `</clipPath>
`) : ""
		}, createSVGRefElementsMarkup: function () { var l = this, d = ["background", "overlay"].map(function (g) { var m = l[g + "Color"]; if (m && m.toLive) { var y = l[g + "Vpt"], w = l.viewportTransform, C = { width: l.width / (y ? w[0] : 1), height: l.height / (y ? w[3] : 1) }; return m.toSVG(C, { additionalTransform: y ? t.util.matrixToSVG(w) : "" }) } }); return d.join("") }, createSVGFontFacesMarkup: function () {
			var l = "", d = {}, g, m, y, w, C, T, A, U, R, $ = t.fontPaths, L = []; for (this._objects.forEach(function N(K) { L.push(K), K._objects && K._objects.forEach(N) }), U = 0, R = L.length; U < R; U++)if (g = L[U], m = g.fontFamily, !(g.type.indexOf("text") === -1 || d[m] || !$[m]) && (d[m] = !0, !!g.styles)) { y = g.styles; for (C in y) { w = y[C]; for (A in w) T = w[A], m = T.fontFamily, !d[m] && $[m] && (d[m] = !0) } } for (var B in d) l += [`		@font-face {
`, "			font-family: '", B, `';
`, "			src: url('", $[B], `');
`, `		}
`].join(""); return l && (l = ['	<style type="text/css">', `<![CDATA[
`, l, "]]>", `</style>
`].join("")), l
		}, _setSVGObjects: function (l, d) { var g, m, y, w = this._objects; for (m = 0, y = w.length; m < y; m++)g = w[m], !g.excludeFromExport && this._setSVGObject(l, g, d) }, _setSVGObject: function (l, d, g) { l.push(d.toSVG(g)) }, _setSVGBgOverlayImage: function (l, d, g) { this[d] && !this[d].excludeFromExport && this[d].toSVG && l.push(this[d].toSVG(g)) }, _setSVGBgOverlayColor: function (l, d) {
			var g = this[d + "Color"], m = this.viewportTransform, y = this.width, w = this.height; if (g) if (g.toLive) {
				var C = g.repeat, T = t.util.invertTransform(m), A = this[d + "Vpt"], U = A ? t.util.matrixToSVG(T) : ""; l.push('<rect transform="' + U + " translate(", y / 2, ",", w / 2, ')"', ' x="', g.offsetX - y / 2, '" y="', g.offsetY - w / 2, '" ', 'width="', C === "repeat-y" || C === "no-repeat" ? g.source.width : y, '" height="', C === "repeat-x" || C === "no-repeat" ? g.source.height : w, '" fill="url(#SVGID_' + g.id + ')"', `></rect>
`)
			} else l.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', g, '"', `></rect>
`)
		}, sendToBack: function (l) { if (!l) return this; var d = this._activeObject, g, m, y; if (l === d && l.type === "activeSelection") for (y = d._objects, g = y.length; g--;)m = y[g], c(this._objects, m), this._objects.unshift(m); else c(this._objects, l), this._objects.unshift(l); return this.renderOnAddRemove && this.requestRenderAll(), this }, bringToFront: function (l) { if (!l) return this; var d = this._activeObject, g, m, y; if (l === d && l.type === "activeSelection") for (y = d._objects, g = 0; g < y.length; g++)m = y[g], c(this._objects, m), this._objects.push(m); else c(this._objects, l), this._objects.push(l); return this.renderOnAddRemove && this.requestRenderAll(), this }, sendBackwards: function (l, d) { if (!l) return this; var g = this._activeObject, m, y, w, C, T, A = 0; if (l === g && l.type === "activeSelection") for (T = g._objects, m = 0; m < T.length; m++)y = T[m], w = this._objects.indexOf(y), w > 0 + A && (C = w - 1, c(this._objects, y), this._objects.splice(C, 0, y)), A++; else w = this._objects.indexOf(l), w !== 0 && (C = this._findNewLowerIndex(l, w, d), c(this._objects, l), this._objects.splice(C, 0, l)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewLowerIndex: function (l, d, g) { var m, y; if (g) for (m = d, y = d - 1; y >= 0; --y) { var w = l.intersectsWithObject(this._objects[y]) || l.isContainedWithinObject(this._objects[y]) || this._objects[y].isContainedWithinObject(l); if (w) { m = y; break } } else m = d - 1; return m }, bringForward: function (l, d) { if (!l) return this; var g = this._activeObject, m, y, w, C, T, A = 0; if (l === g && l.type === "activeSelection") for (T = g._objects, m = T.length; m--;)y = T[m], w = this._objects.indexOf(y), w < this._objects.length - 1 - A && (C = w + 1, c(this._objects, y), this._objects.splice(C, 0, y)), A++; else w = this._objects.indexOf(l), w !== this._objects.length - 1 && (C = this._findNewUpperIndex(l, w, d), c(this._objects, l), this._objects.splice(C, 0, l)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewUpperIndex: function (l, d, g) { var m, y, w; if (g) for (m = d, y = d + 1, w = this._objects.length; y < w; ++y) { var C = l.intersectsWithObject(this._objects[y]) || l.isContainedWithinObject(this._objects[y]) || this._objects[y].isContainedWithinObject(l); if (C) { m = y; break } } else m = d + 1; return m }, moveTo: function (l, d) { return c(this._objects, l), this._objects.splice(d, 0, l), this.renderOnAddRemove && this.requestRenderAll() }, dispose: function () { return this.isRendering && (t.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function (l) { l.dispose && l.dispose() }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), t.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), t.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>" }
	}), f(t.StaticCanvas.prototype, t.Observable), f(t.StaticCanvas.prototype, t.Collection), f(t.StaticCanvas.prototype, t.DataURLExporter), f(t.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (l) { var d = s(); if (!d || !d.getContext) return null; var g = d.getContext("2d"); if (!g) return null; switch (l) { case "setLineDash": return typeof g.setLineDash != "undefined"; default: return null } } }), t.StaticCanvas.prototype.toJSON = t.StaticCanvas.prototype.toObject, t.isLikelyNode && (t.StaticCanvas.prototype.createPNGStream = function () { var l = i(this.lowerCanvasEl); return l && l.createPNGStream() }, t.StaticCanvas.prototype.createJPEGStream = function (l) { var d = i(this.lowerCanvasEl); return d && d.createJPEGStream(l) })
}(), t.BaseBrush = t.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeMiterLimit: 10, strokeDashArray: null, limitedToCanvasSize: !1, _setBrushStyles: function (f) { f.strokeStyle = this.color, f.lineWidth = this.width, f.lineCap = this.strokeLineCap, f.miterLimit = this.strokeMiterLimit, f.lineJoin = this.strokeLineJoin, f.setLineDash(this.strokeDashArray || []) }, _saveAndTransform: function (f) { var r = this.canvas.viewportTransform; f.save(), f.transform(r[0], r[1], r[2], r[3], r[4], r[5]) }, _setShadow: function () { if (this.shadow) { var f = this.canvas, r = this.shadow, c = f.contextTop, h = f.getZoom(); f && f._isRetinaScaling() && (h *= t.devicePixelRatio), c.shadowColor = r.color, c.shadowBlur = r.blur * h, c.shadowOffsetX = r.offsetX * h, c.shadowOffsetY = r.offsetY * h } }, needsFullRender: function () { var f = new t.Color(this.color); return f.getAlpha() < 1 || !!this.shadow }, _resetShadow: function () { var f = this.canvas.contextTop; f.shadowColor = "", f.shadowBlur = f.shadowOffsetX = f.shadowOffsetY = 0 }, _isOutSideCanvas: function (f) { return f.x < 0 || f.x > this.canvas.getWidth() || f.y < 0 || f.y > this.canvas.getHeight() } }), function () { t.PencilBrush = t.util.createClass(t.BaseBrush, { decimate: .4, drawStraightLine: !1, straightLineKey: "shiftKey", initialize: function (f) { this.canvas = f, this._points = [] }, needsFullRender: function () { return this.callSuper("needsFullRender") || this._hasStraightLine }, _drawSegment: function (f, r, c) { var h = r.midPointFrom(c); return f.quadraticCurveTo(r.x, r.y, h.x, h.y), h }, onMouseDown: function (f, r) { this.canvas._isMainEvent(r.e) && (this.drawStraightLine = r.e[this.straightLineKey], this._prepareForDrawing(f), this._captureDrawingPath(f), this._render()) }, onMouseMove: function (f, r) { if (this.canvas._isMainEvent(r.e) && (this.drawStraightLine = r.e[this.straightLineKey], !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(f)) && this._captureDrawingPath(f) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render(); else { var c = this._points, h = c.length, n = this.canvas.contextTop; this._saveAndTransform(n), this.oldEnd && (n.beginPath(), n.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(n, c[h - 2], c[h - 1], !0), n.stroke(), n.restore() } }, onMouseUp: function (f) { return this.canvas._isMainEvent(f.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0 }, _prepareForDrawing: function (f) { var r = new t.Point(f.x, f.y); this._reset(), this._addPoint(r), this.canvas.contextTop.moveTo(r.x, r.y) }, _addPoint: function (f) { return this._points.length > 1 && f.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(f), !0) }, _reset: function () { this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1 }, _captureDrawingPath: function (f) { var r = new t.Point(f.x, f.y); return this._addPoint(r) }, _render: function (f) { var r, c, h = this._points[0], n = this._points[1]; if (f = f || this.canvas.contextTop, this._saveAndTransform(f), f.beginPath(), this._points.length === 2 && h.x === n.x && h.y === n.y) { var o = this.width / 1e3; h = new t.Point(h.x, h.y), n = new t.Point(n.x, n.y), h.x -= o, n.x += o } for (f.moveTo(h.x, h.y), r = 1, c = this._points.length; r < c; r++)this._drawSegment(f, h, n), h = this._points[r], n = this._points[r + 1]; f.lineTo(h.x, h.y), f.stroke(), f.restore() }, convertPointsToSVGPath: function (f) { var r = this.width / 1e3; return t.util.getSmoothPathFromPoints(f, r) }, _isEmptySVGPath: function (f) { var r = t.util.joinPath(f); return r === "M 0 0 Q 0 0 0 0 L 0 0" }, createPath: function (f) { var r = new t.Path(f, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray }); return this.shadow && (this.shadow.affectStroke = !0, r.shadow = new t.Shadow(this.shadow)), r }, decimatePoints: function (f, r) { if (f.length <= 2) return f; var c = this.canvas.getZoom(), h = Math.pow(r / c, 2), n, o = f.length - 1, i = f[0], s = [i], u; for (n = 1; n < o - 1; n++)u = Math.pow(i.x - f[n].x, 2) + Math.pow(i.y - f[n].y, 2), u >= h && (i = f[n], s.push(i)); return s.push(f[o]), s }, _finalizeAndAddPath: function () { var f = this.canvas.contextTop; f.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate)); var r = this.convertPointsToSVGPath(this._points); if (this._isEmptySVGPath(r)) { this.canvas.requestRenderAll(); return } var c = this.createPath(r); this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: c }), this.canvas.add(c), this.canvas.requestRenderAll(), c.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: c }) } }) }(), t.CircleBrush = t.util.createClass(t.BaseBrush, { width: 10, initialize: function (f) { this.canvas = f, this.points = [] }, drawDot: function (f) { var r = this.addPoint(f), c = this.canvas.contextTop; this._saveAndTransform(c), this.dot(c, r), c.restore() }, dot: function (f, r) { f.fillStyle = r.fill, f.beginPath(), f.arc(r.x, r.y, r.radius, 0, Math.PI * 2, !1), f.closePath(), f.fill() }, onMouseDown: function (f) { this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(f) }, _render: function () { var f = this.canvas.contextTop, r, c, h = this.points; for (this._saveAndTransform(f), r = 0, c = h.length; r < c; r++)this.dot(f, h[r]); f.restore() }, onMouseMove: function (f) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(f) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(f), this._render()) : this.drawDot(f)) }, onMouseUp: function () { var f = this.canvas.renderOnAddRemove, r, c; this.canvas.renderOnAddRemove = !1; var h = []; for (r = 0, c = this.points.length; r < c; r++) { var n = this.points[r], o = new t.Circle({ radius: n.radius, left: n.x, top: n.y, originX: "center", originY: "center", fill: n.fill }); this.shadow && (o.shadow = new t.Shadow(this.shadow)), h.push(o) } var i = new t.Group(h); i.canvas = this.canvas, this.canvas.fire("before:path:created", { path: i }), this.canvas.add(i), this.canvas.fire("path:created", { path: i }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = f, this.canvas.requestRenderAll() }, addPoint: function (f) { var r = new t.Point(f.x, f.y), c = t.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, h = new t.Color(this.color).setAlpha(t.util.getRandomInt(0, 100) / 100).toRgba(); return r.radius = c, r.fill = h, this.points.push(r), r } }), t.SprayBrush = t.util.createClass(t.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: !1, optimizeOverlapping: !0, initialize: function (f) { this.canvas = f, this.sprayChunks = [] }, onMouseDown: function (f) { this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(f), this.render(this.sprayChunkPoints) }, onMouseMove: function (f) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(f) || (this.addSprayChunk(f), this.render(this.sprayChunkPoints)) }, onMouseUp: function () { var f = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var r = [], c = 0, h = this.sprayChunks.length; c < h; c++)for (var n = this.sprayChunks[c], o = 0, i = n.length; o < i; o++) { var s = new t.Rect({ width: n[o].width, height: n[o].width, left: n[o].x + 1, top: n[o].y + 1, originX: "center", originY: "center", fill: this.color }); r.push(s) } this.optimizeOverlapping && (r = this._getOptimizedRects(r)); var u = new t.Group(r); this.shadow && u.set("shadow", new t.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: u }), this.canvas.add(u), this.canvas.fire("path:created", { path: u }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = f, this.canvas.requestRenderAll() }, _getOptimizedRects: function (f) { var r = {}, c, h, n; for (h = 0, n = f.length; h < n; h++)c = f[h].left + "" + f[h].top, r[c] || (r[c] = f[h]); var o = []; for (c in r) o.push(r[c]); return o }, render: function (f) { var r = this.canvas.contextTop, c, h; for (r.fillStyle = this.color, this._saveAndTransform(r), c = 0, h = f.length; c < h; c++) { var n = f[c]; typeof n.opacity != "undefined" && (r.globalAlpha = n.opacity), r.fillRect(n.x, n.y, n.width, n.width) } r.restore() }, _render: function () { var f = this.canvas.contextTop, r, c; for (f.fillStyle = this.color, this._saveAndTransform(f), r = 0, c = this.sprayChunks.length; r < c; r++)this.render(this.sprayChunks[r]); f.restore() }, addSprayChunk: function (f) { this.sprayChunkPoints = []; var r, c, h, n = this.width / 2, o; for (o = 0; o < this.density; o++) { r = t.util.getRandomInt(f.x - n, f.x + n), c = t.util.getRandomInt(f.y - n, f.y + n), this.dotWidthVariance ? h = t.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : h = this.dotWidth; var i = new t.Point(r, c); i.width = h, this.randomOpacity && (i.opacity = t.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(i) } this.sprayChunks.push(this.sprayChunkPoints) } }), t.PatternBrush = t.util.createClass(t.PencilBrush, { getPatternSrc: function () { var f = 20, r = 5, c = t.util.createCanvasElement(), h = c.getContext("2d"); return c.width = c.height = f + r, h.fillStyle = this.color, h.beginPath(), h.arc(f / 2, f / 2, f / 2, 0, Math.PI * 2, !1), h.closePath(), h.fill(), c }, getPatternSrcFunction: function () { return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"') }, getPattern: function (f) { return f.createPattern(this.source || this.getPatternSrc(), "repeat") }, _setBrushStyles: function (f) { this.callSuper("_setBrushStyles", f), f.strokeStyle = this.getPattern(f) }, createPath: function (f) { var r = this.callSuper("createPath", f), c = r._getLeftTopCoords().scalarAdd(r.strokeWidth / 2); return r.stroke = new t.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -c.x, offsetY: -c.y }), r } }), function () { var f = t.util.getPointer, r = t.util.degreesToRadians, c = t.util.isTouchEvent; t.Canvas = t.util.createClass(t.StaticCanvas, { initialize: function (n, o) { o || (o = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(n, o), this._initInteractive(), this._createCacheCanvas() }, uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, targets: [], enablePointerEvents: !1, _hoveredTarget: null, _hoveredTargets: [], _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = t.PencilBrush && new t.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var n = this.getActiveObjects(), o, i, s; if (n.length > 0 && !this.preserveObjectStacking) { i = [], s = []; for (var u = 0, l = this._objects.length; u < l; u++)o = this._objects[u], n.indexOf(o) === -1 ? i.push(o) : s.push(o); n.length > 1 && (this._activeObject._objects = s), i.push.apply(i, s) } else i = this._objects; return i }, renderAll: function () { this.contextTopDirty && !this._groupSelector && !this.isDrawingMode && (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1); var n = this.contextContainer; return this.renderCanvas(n, this._chooseObjectsToRender()), this }, renderTopLayer: function (n) { n.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(n), this.contextTopDirty = !0), n.restore() }, renderTop: function () { var n = this.contextTop; return this.clearContext(n), this.renderTopLayer(n), this.fire("after:render"), this }, _normalizePointer: function (n, o) { var i = n.calcTransformMatrix(), s = t.util.invertTransform(i), u = this.restorePointerVpt(o); return t.util.transformPoint(u, s) }, isTargetTransparent: function (n, o, i) { if (n.shouldCache() && n._cacheCanvas && n !== this._activeObject) { var s = this._normalizePointer(n, { x: o, y: i }), u = Math.max(n.cacheTranslationX + s.x * n.zoomX, 0), l = Math.max(n.cacheTranslationY + s.y * n.zoomY, 0), y = t.util.isTransparent(n._cacheContext, Math.round(u), Math.round(l), this.targetFindTolerance); return y } var d = this.contextCache, g = n.selectionBackgroundColor, m = this.viewportTransform; n.selectionBackgroundColor = "", this.clearContext(d), d.save(), d.transform(m[0], m[1], m[2], m[3], m[4], m[5]), n.render(d), d.restore(), n.selectionBackgroundColor = g; var y = t.util.isTransparent(d, o, i, this.targetFindTolerance); return y }, _isSelectionKeyPressed: function (n) { var o = !1; return Array.isArray(this.selectionKey) ? o = !!this.selectionKey.find(function (i) { return n[i] === !0 }) : o = n[this.selectionKey], o }, _shouldClearSelection: function (n, o) { var i = this.getActiveObjects(), s = this._activeObject; return !o || o && s && i.length > 1 && i.indexOf(o) === -1 && s !== o && !this._isSelectionKeyPressed(n) || o && !o.evented || o && !o.selectable && s && s !== o }, _shouldCenterTransform: function (n, o, i) { if (n) { var s; return o === "scale" || o === "scaleX" || o === "scaleY" || o === "resizing" ? s = this.centeredScaling || n.centeredScaling : o === "rotate" && (s = this.centeredRotation || n.centeredRotation), s ? !i : i } }, _getOriginFromCorner: function (n, o) { var i = { x: n.originX, y: n.originY }; return o === "ml" || o === "tl" || o === "bl" ? i.x = "right" : (o === "mr" || o === "tr" || o === "br") && (i.x = "left"), o === "tl" || o === "mt" || o === "tr" ? i.y = "bottom" : (o === "bl" || o === "mb" || o === "br") && (i.y = "top"), i }, _getActionFromCorner: function (n, o, i, s) { if (!o || !n) return "drag"; var u = s.controls[o]; return u.getActionName(i, u, s) }, _setupCurrentTransform: function (n, o, i) { if (o) { var s = this.getPointer(n), u = o.__corner, l = o.controls[u], d = i && u ? l.getActionHandler(n, o, l) : t.controlsUtils.dragHandler, g = this._getActionFromCorner(i, u, n, o), m = this._getOriginFromCorner(o, u), y = n[this.centeredKey], w = { target: o, action: g, actionHandler: d, corner: u, scaleX: o.scaleX, scaleY: o.scaleY, skewX: o.skewX, skewY: o.skewY, offsetX: s.x - o.left, offsetY: s.y - o.top, originX: m.x, originY: m.y, ex: s.x, ey: s.y, lastX: s.x, lastY: s.y, theta: r(o.angle), width: o.width * o.scaleX, shiftKey: n.shiftKey, altKey: y, original: t.util.saveObjectTransform(o) }; this._shouldCenterTransform(o, g, y) && (w.originX = "center", w.originY = "center"), w.original.originX = m.x, w.original.originY = m.y, this._currentTransform = w, this._beforeTransform(n) } }, setCursor: function (n) { this.upperCanvasEl.style.cursor = n }, _drawSelection: function (n) { var o = this._groupSelector, i = new t.Point(o.ex, o.ey), s = t.util.transformPoint(i, this.viewportTransform), u = new t.Point(o.ex + o.left, o.ey + o.top), l = t.util.transformPoint(u, this.viewportTransform), d = Math.min(s.x, l.x), g = Math.min(s.y, l.y), m = Math.max(s.x, l.x), y = Math.max(s.y, l.y), w = this.selectionLineWidth / 2; this.selectionColor && (n.fillStyle = this.selectionColor, n.fillRect(d, g, m - d, y - g)), !(!this.selectionLineWidth || !this.selectionBorderColor) && (n.lineWidth = this.selectionLineWidth, n.strokeStyle = this.selectionBorderColor, d += w, g += w, m -= w, y -= w, t.Object.prototype._setLineDash.call(this, n, this.selectionDashArray), n.strokeRect(d, g, m - d, y - g)) }, findTarget: function (n, o) { if (!this.skipTargetFind) { var i = !0, s = this.getPointer(n, i), u = this._activeObject, l = this.getActiveObjects(), d, g, m = c(n), y = l.length > 1 && !o || l.length === 1; if (this.targets = [], y && u._findTargetCorner(s, m) || l.length > 1 && !o && u === this._searchPossibleTargets([u], s)) return u; if (l.length === 1 && u === this._searchPossibleTargets([u], s)) if (this.preserveObjectStacking) d = u, g = this.targets, this.targets = []; else return u; var w = this._searchPossibleTargets(this._objects, s); return n[this.altSelectionKey] && w && d && w !== d && (w = d, this.targets = g), w } }, _checkTarget: function (n, o, i) { if (o && o.visible && o.evented && o.containsPoint(n)) if ((this.perPixelTargetFind || o.perPixelTargetFind) && !o.isEditing) { var s = this.isTargetTransparent(o, i.x, i.y); if (!s) return !0 } else return !0 }, _searchPossibleTargets: function (n, o) { for (var i, s = n.length, u; s--;) { var l = n[s], d = l.group ? this._normalizePointer(l.group, o) : o; if (this._checkTarget(d, l, o)) { i = n[s], i.subTargetCheck && i instanceof t.Group && (u = this._searchPossibleTargets(i._objects, o), u && this.targets.push(u)); break } } return i }, restorePointerVpt: function (n) { return t.util.transformPoint(n, t.util.invertTransform(this.viewportTransform)) }, getPointer: function (n, o) { if (this._absolutePointer && !o) return this._absolutePointer; if (this._pointer && o) return this._pointer; var i = f(n), s = this.upperCanvasEl, u = s.getBoundingClientRect(), l = u.width || 0, d = u.height || 0, g; (!l || !d) && ("top" in u && "bottom" in u && (d = Math.abs(u.top - u.bottom)), "right" in u && "left" in u && (l = Math.abs(u.right - u.left))), this.calcOffset(), i.x = i.x - this._offset.left, i.y = i.y - this._offset.top, o || (i = this.restorePointerVpt(i)); var m = this.getRetinaScaling(); return m !== 1 && (i.x /= m, i.y /= m), l === 0 || d === 0 ? g = { width: 1, height: 1 } : g = { width: s.width / l, height: s.height / d }, { x: i.x * g.width, y: i.y * g.height } }, _createUpperCanvas: function () { var n = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), o = this.lowerCanvasEl, i = this.upperCanvasEl; i ? i.className = "" : (i = this._createCanvasElement(), this.upperCanvasEl = i), t.util.addClass(i, "upper-canvas " + n), this.wrapperEl.appendChild(i), this._copyCanvasStyle(o, i), this._applyCanvasStyle(i), this.contextTop = i.getContext("2d") }, getTopContext: function () { return this.contextTop }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = t.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), t.util.setStyle(this.wrapperEl, { width: this.width + "px", height: this.height + "px", position: "relative" }), t.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (n) { var o = this.width || n.width, i = this.height || n.height; t.util.setStyle(n, { position: "absolute", width: o + "px", height: i + "px", left: 0, top: 0, "touch-action": this.allowTouchScrolling ? "manipulation" : "none", "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none" }), n.width = o, n.height = i, t.util.makeElementUnselectable(n) }, _copyCanvasStyle: function (n, o) { o.style.cssText = n.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, getActiveObject: function () { return this._activeObject }, getActiveObjects: function () { var n = this._activeObject; return n ? n.type === "activeSelection" && n._objects ? n._objects.slice(0) : [n] : [] }, _onObjectRemoved: function (n) { n === this._activeObject && (this.fire("before:selection:cleared", { target: n }), this._discardActiveObject(), this.fire("selection:cleared", { target: n }), n.fire("deselected")), n === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", n) }, _fireSelectionEvents: function (n, o) { var i = !1, s = this.getActiveObjects(), u = [], l = []; n.forEach(function (d) { s.indexOf(d) === -1 && (i = !0, d.fire("deselected", { e: o, target: d }), l.push(d)) }), s.forEach(function (d) { n.indexOf(d) === -1 && (i = !0, d.fire("selected", { e: o, target: d }), u.push(d)) }), n.length > 0 && s.length > 0 ? i && this.fire("selection:updated", { e: o, selected: u, deselected: l }) : s.length > 0 ? this.fire("selection:created", { e: o, selected: u }) : n.length > 0 && this.fire("selection:cleared", { e: o, deselected: l }) }, setActiveObject: function (n, o) { var i = this.getActiveObjects(); return this._setActiveObject(n, o), this._fireSelectionEvents(i, o), this }, _setActiveObject: function (n, o) { return this._activeObject === n || !this._discardActiveObject(o, n) || n.onSelect({ e: o }) ? !1 : (this._activeObject = n, !0) }, _discardActiveObject: function (n, o) { var i = this._activeObject; if (i) { if (i.onDeselect({ e: n, object: o })) return !1; this._activeObject = null } return !0 }, discardActiveObject: function (n) { var o = this.getActiveObjects(), i = this.getActiveObject(); return o.length && this.fire("before:selection:cleared", { target: i, e: n }), this._discardActiveObject(n), this._fireSelectionEvents(o, n), this }, dispose: function () { var n = this.wrapperEl; return this.removeListeners(), n.removeChild(this.upperCanvasEl), n.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach(function (o) { t.util.cleanUpJsdomNode(this[o]), this[o] = void 0 }.bind(this)), n.parentNode && n.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, t.StaticCanvas.prototype.dispose.call(this), this }, clear: function () { return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (n) { var o = this._activeObject; o && o._renderControls(n) }, _toObject: function (n, o, i) { var s = this._realizeGroupTransformOnObject(n), u = this.callSuper("_toObject", n, o, i); return this._unwindGroupTransformOnObject(n, s), u }, _realizeGroupTransformOnObject: function (n) { if (n.group && n.group.type === "activeSelection" && this._activeObject === n.group) { var o = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"], i = {}; return o.forEach(function (s) { i[s] = n[s] }), t.util.addTransformToObject(n, this._activeObject.calcOwnMatrix()), i } else return null }, _unwindGroupTransformOnObject: function (n, o) { o && n.set(o) }, _setSVGObject: function (n, o, i) { var s = this._realizeGroupTransformOnObject(o); this.callSuper("_setSVGObject", n, o, i), this._unwindGroupTransformOnObject(o, s) }, setViewportTransform: function (n) { this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), t.StaticCanvas.prototype.setViewportTransform.call(this, n) } }); for (var h in t.StaticCanvas) h !== "prototype" && (t.Canvas[h] = t.StaticCanvas[h]) }(), function () { var f = t.util.addListener, r = t.util.removeListener, c = 3, h = 2, n = 1, o = { passive: !1 }; function i(s, u) { return s.button && s.button === u - 1 } t.util.object.extend(t.Canvas.prototype, { mainTouchId: null, _initEventListeners: function () { this.removeListeners(), this._bindEvents(), this.addOrRemove(f, "add") }, _getEventPrefix: function () { return this.enablePointerEvents ? "pointer" : "mouse" }, addOrRemove: function (s, u) { var l = this.upperCanvasEl, d = this._getEventPrefix(); s(t.window, "resize", this._onResize), s(l, d + "down", this._onMouseDown), s(l, d + "move", this._onMouseMove, o), s(l, d + "out", this._onMouseOut), s(l, d + "enter", this._onMouseEnter), s(l, "wheel", this._onMouseWheel), s(l, "contextmenu", this._onContextMenu), s(l, "dblclick", this._onDoubleClick), s(l, "dragover", this._onDragOver), s(l, "dragenter", this._onDragEnter), s(l, "dragleave", this._onDragLeave), s(l, "drop", this._onDrop), this.enablePointerEvents || s(l, "touchstart", this._onTouchStart, o), typeof eventjs != "undefined" && u in eventjs && (eventjs[u](l, "gesture", this._onGesture), eventjs[u](l, "drag", this._onDrag), eventjs[u](l, "orientation", this._onOrientationChange), eventjs[u](l, "shake", this._onShake), eventjs[u](l, "longpress", this._onLongPress)) }, removeListeners: function () { this.addOrRemove(r, "remove"); var s = this._getEventPrefix(); r(t.document, s + "up", this._onMouseUp), r(t.document, "touchend", this._onTouchEnd, o), r(t.document, s + "move", this._onMouseMove, o), r(t.document, "touchmove", this._onMouseMove, o) }, _bindEvents: function () { this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0) }, _onGesture: function (s, u) { this.__onTransformGesture && this.__onTransformGesture(s, u) }, _onDrag: function (s, u) { this.__onDrag && this.__onDrag(s, u) }, _onMouseWheel: function (s) { this.__onMouseWheel(s) }, _onMouseOut: function (s) { var u = this._hoveredTarget; this.fire("mouse:out", { target: u, e: s }), this._hoveredTarget = null, u && u.fire("mouseout", { e: s }); var l = this; this._hoveredTargets.forEach(function (d) { l.fire("mouse:out", { target: u, e: s }), d && u.fire("mouseout", { e: s }) }), this._hoveredTargets = [] }, _onMouseEnter: function (s) { !this._currentTransform && !this.findTarget(s) && (this.fire("mouse:over", { target: null, e: s }), this._hoveredTarget = null, this._hoveredTargets = []) }, _onOrientationChange: function (s, u) { this.__onOrientationChange && this.__onOrientationChange(s, u) }, _onShake: function (s, u) { this.__onShake && this.__onShake(s, u) }, _onLongPress: function (s, u) { this.__onLongPress && this.__onLongPress(s, u) }, _onDragOver: function (s) { s.preventDefault(); var u = this._simpleEventHandler("dragover", s); this._fireEnterLeaveEvents(u, s) }, _onDrop: function (s) { return this._simpleEventHandler("drop:before", s), this._simpleEventHandler("drop", s) }, _onContextMenu: function (s) { return this.stopContextMenu && (s.stopPropagation(), s.preventDefault()), !1 }, _onDoubleClick: function (s) { this._cacheTransformEventData(s), this._handleEvent(s, "dblclick"), this._resetTransformEventData(s) }, getPointerId: function (s) { var u = s.changedTouches; return u ? u[0] && u[0].identifier : this.enablePointerEvents ? s.pointerId : -1 }, _isMainEvent: function (s) { return s.isPrimary === !0 ? !0 : s.isPrimary === !1 ? !1 : s.type === "touchend" && s.touches.length === 0 ? !0 : s.changedTouches ? s.changedTouches[0].identifier === this.mainTouchId : !0 }, _onTouchStart: function (s) { s.preventDefault(), this.mainTouchId === null && (this.mainTouchId = this.getPointerId(s)), this.__onMouseDown(s), this._resetTransformEventData(); var u = this.upperCanvasEl, l = this._getEventPrefix(); f(t.document, "touchend", this._onTouchEnd, o), f(t.document, "touchmove", this._onMouseMove, o), r(u, l + "down", this._onMouseDown) }, _onMouseDown: function (s) { this.__onMouseDown(s), this._resetTransformEventData(); var u = this.upperCanvasEl, l = this._getEventPrefix(); r(u, l + "move", this._onMouseMove, o), f(t.document, l + "up", this._onMouseUp), f(t.document, l + "move", this._onMouseMove, o) }, _onTouchEnd: function (s) { if (!(s.touches.length > 0)) { this.__onMouseUp(s), this._resetTransformEventData(), this.mainTouchId = null; var u = this._getEventPrefix(); r(t.document, "touchend", this._onTouchEnd, o), r(t.document, "touchmove", this._onMouseMove, o); var l = this; this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function () { f(l.upperCanvasEl, u + "down", l._onMouseDown), l._willAddMouseDown = 0 }, 400) } }, _onMouseUp: function (s) { this.__onMouseUp(s), this._resetTransformEventData(); var u = this.upperCanvasEl, l = this._getEventPrefix(); this._isMainEvent(s) && (r(t.document, l + "up", this._onMouseUp), r(t.document, l + "move", this._onMouseMove, o), f(u, l + "move", this._onMouseMove, o)) }, _onMouseMove: function (s) { !this.allowTouchScrolling && s.preventDefault && s.preventDefault(), this.__onMouseMove(s) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (s) { var u = this._activeObject; return !!u != !!s || u && s && u !== s ? !0 : (u && u.isEditing, !1) }, __onMouseUp: function (s) { var u, l = this._currentTransform, d = this._groupSelector, g = !1, m = !d || d.left === 0 && d.top === 0; if (this._cacheTransformEventData(s), u = this._target, this._handleEvent(s, "up:before"), i(s, c)) { this.fireRightClick && this._handleEvent(s, "up", c, m); return } if (i(s, h)) { this.fireMiddleClick && this._handleEvent(s, "up", h, m), this._resetTransformEventData(); return } if (this.isDrawingMode && this._isCurrentlyDrawing) { this._onMouseUpInDrawingMode(s); return } if (this._isMainEvent(s)) { if (l && (this._finalizeCurrentTransform(s), g = l.actionPerformed), !m) { var y = u === this._activeObject; this._maybeGroupObjects(s), g || (g = this._shouldRender(u) || !y && u === this._activeObject) } var w, C; if (u) { if (w = u._findTargetCorner(this.getPointer(s, !0), t.util.isTouchEvent(s)), u.selectable && u !== this._activeObject && u.activeOn === "up") this.setActiveObject(u, s), g = !0; else { var T = u.controls[w], A = T && T.getMouseUpHandler(s, u, T); A && (C = this.getPointer(s), A(s, l, C.x, C.y)) } u.isMoving = !1 } if (l && (l.target !== u || l.corner !== w)) { var U = l.target && l.target.controls[l.corner], R = U && U.getMouseUpHandler(s, u, T); C = C || this.getPointer(s), R && R(s, l, C.x, C.y) } this._setCursorFromEvent(s, u), this._handleEvent(s, "up", n, m), this._groupSelector = null, this._currentTransform = null, u && (u.__corner = 0), g ? this.requestRenderAll() : m || this.renderTop() } }, _simpleEventHandler: function (s, u) { var l = this.findTarget(u), d = this.targets, g = { e: u, target: l, subTargets: d }; if (this.fire(s, g), l && l.fire(s, g), !d) return l; for (var m = 0; m < d.length; m++)d[m].fire(s, g); return l }, _handleEvent: function (s, u, l, d) { var g = this._target, m = this.targets || [], y = { e: s, target: g, subTargets: m, button: l || n, isClick: d || !1, pointer: this._pointer, absolutePointer: this._absolutePointer, transform: this._currentTransform }; u === "up" && (y.currentTarget = this.findTarget(s), y.currentSubTargets = this.targets), this.fire("mouse:" + u, y), g && g.fire("mouse" + u, y); for (var w = 0; w < m.length; w++)m[w].fire("mouse" + u, y) }, _finalizeCurrentTransform: function (s) { var u = this._currentTransform, l = u.target, d = { e: s, target: l, transform: u, action: u.action }; l._scaling && (l._scaling = !1), l.setCoords(), (u.actionPerformed || this.stateful && l.hasStateChanged()) && this._fire("modified", d) }, _onMouseDownInDrawingMode: function (s) { this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(s).requestRenderAll(); var u = this.getPointer(s); this.freeDrawingBrush.onMouseDown(u, { e: s, pointer: u }), this._handleEvent(s, "down") }, _onMouseMoveInDrawingMode: function (s) { if (this._isCurrentlyDrawing) { var u = this.getPointer(s); this.freeDrawingBrush.onMouseMove(u, { e: s, pointer: u }) } this.setCursor(this.freeDrawingCursor), this._handleEvent(s, "move") }, _onMouseUpInDrawingMode: function (s) { var u = this.getPointer(s); this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: s, pointer: u }), this._handleEvent(s, "up") }, __onMouseDown: function (s) { this._cacheTransformEventData(s), this._handleEvent(s, "down:before"); var u = this._target; if (i(s, c)) { this.fireRightClick && this._handleEvent(s, "down", c); return } if (i(s, h)) { this.fireMiddleClick && this._handleEvent(s, "down", h); return } if (this.isDrawingMode) { this._onMouseDownInDrawingMode(s); return } if (this._isMainEvent(s) && !this._currentTransform) { var l = this._pointer; this._previousPointer = l; var d = this._shouldRender(u), g = this._shouldGroup(s, u); if (this._shouldClearSelection(s, u) ? this.discardActiveObject(s) : g && (this._handleGrouping(s, u), u = this._activeObject), this.selection && (!u || !u.selectable && !u.isEditing && u !== this._activeObject) && (this._groupSelector = { ex: this._absolutePointer.x, ey: this._absolutePointer.y, top: 0, left: 0 }), u) { var m = u === this._activeObject; u.selectable && u.activeOn === "down" && this.setActiveObject(u, s); var y = u._findTargetCorner(this.getPointer(s, !0), t.util.isTouchEvent(s)); if (u.__corner = y, u === this._activeObject && (y || !g)) { this._setupCurrentTransform(s, u, m); var w = u.controls[y], l = this.getPointer(s), C = w && w.getMouseDownHandler(s, u, w); C && C(s, this._currentTransform, l.x, l.y) } } this._handleEvent(s, "down"), (d || g) && this.requestRenderAll() } }, _resetTransformEventData: function () { this._target = null, this._pointer = null, this._absolutePointer = null }, _cacheTransformEventData: function (s) { this._resetTransformEventData(), this._pointer = this.getPointer(s, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(s) || null }, _beforeTransform: function (s) { var u = this._currentTransform; this.stateful && u.target.saveState(), this.fire("before:transform", { e: s, transform: u }) }, __onMouseMove: function (s) { this._handleEvent(s, "move:before"), this._cacheTransformEventData(s); var u, l; if (this.isDrawingMode) { this._onMouseMoveInDrawingMode(s); return } if (this._isMainEvent(s)) { var d = this._groupSelector; d ? (l = this._absolutePointer, d.left = l.x - d.ex, d.top = l.y - d.ey, this.renderTop()) : this._currentTransform ? this._transformObject(s) : (u = this.findTarget(s) || null, this._setCursorFromEvent(s, u), this._fireOverOutEvents(u, s)), this._handleEvent(s, "move"), this._resetTransformEventData() } }, _fireOverOutEvents: function (s, u) { var l = this._hoveredTarget, d = this._hoveredTargets, g = this.targets, m = Math.max(d.length, g.length); this.fireSyntheticInOutEvents(s, u, { oldTarget: l, evtOut: "mouseout", canvasEvtOut: "mouse:out", evtIn: "mouseover", canvasEvtIn: "mouse:over" }); for (var y = 0; y < m; y++)this.fireSyntheticInOutEvents(g[y], u, { oldTarget: d[y], evtOut: "mouseout", evtIn: "mouseover" }); this._hoveredTarget = s, this._hoveredTargets = this.targets.concat() }, _fireEnterLeaveEvents: function (s, u) { var l = this._draggedoverTarget, d = this._hoveredTargets, g = this.targets, m = Math.max(d.length, g.length); this.fireSyntheticInOutEvents(s, u, { oldTarget: l, evtOut: "dragleave", evtIn: "dragenter" }); for (var y = 0; y < m; y++)this.fireSyntheticInOutEvents(g[y], u, { oldTarget: d[y], evtOut: "dragleave", evtIn: "dragenter" }); this._draggedoverTarget = s }, fireSyntheticInOutEvents: function (s, u, l) { var d, g, m = l.oldTarget, y, w, C = m !== s, T = l.canvasEvtIn, A = l.canvasEvtOut; C && (d = { e: u, target: s, previousTarget: m }, g = { e: u, target: m, nextTarget: s }), w = s && C, y = m && C, y && (A && this.fire(A, g), m.fire(l.evtOut, g)), w && (T && this.fire(T, d), s.fire(l.evtIn, d)) }, __onMouseWheel: function (s) { this._cacheTransformEventData(s), this._handleEvent(s, "wheel"), this._resetTransformEventData() }, _transformObject: function (s) { var u = this.getPointer(s), l = this._currentTransform; l.reset = !1, l.shiftKey = s.shiftKey, l.altKey = s[this.centeredKey], this._performTransformAction(s, l, u), l.actionPerformed && this.requestRenderAll() }, _performTransformAction: function (s, u, l) { var d = l.x, g = l.y, m = u.action, y = !1, w = u.actionHandler; w && (y = w(s, u, d, g)), m === "drag" && y && (u.target.isMoving = !0, this.setCursor(u.target.moveCursor || this.moveCursor)), u.actionPerformed = u.actionPerformed || y }, _fire: t.controlsUtils.fireEvent, _setCursorFromEvent: function (s, u) { if (!u) return this.setCursor(this.defaultCursor), !1; var l = u.hoverCursor || this.hoverCursor, d = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, g = (!d || !d.contains(u)) && u._findTargetCorner(this.getPointer(s, !0)); g ? this.setCursor(this.getCornerCursor(g, u, s)) : (u.subTargetCheck && this.targets.concat().reverse().map(function (m) { l = m.hoverCursor || l }), this.setCursor(l)) }, getCornerCursor: function (s, u, l) { var d = u.controls[s]; return d.cursorStyleHandler(l, d, u) } }) }(), function () { var f = Math.min, r = Math.max; t.util.object.extend(t.Canvas.prototype, { _shouldGroup: function (c, h) { var n = this._activeObject; return n && this._isSelectionKeyPressed(c) && h && h.selectable && this.selection && (n !== h || n.type === "activeSelection") && !h.onSelect({ e: c }) }, _handleGrouping: function (c, h) { var n = this._activeObject; n.__corner || h === n && (h = this.findTarget(c, !0), !h || !h.selectable) || (n && n.type === "activeSelection" ? this._updateActiveSelection(h, c) : this._createActiveSelection(h, c)) }, _updateActiveSelection: function (c, h) { var n = this._activeObject, o = n._objects.slice(0); n.contains(c) ? (n.removeWithUpdate(c), this._hoveredTarget = c, this._hoveredTargets = this.targets.concat(), n.size() === 1 && this._setActiveObject(n.item(0), h)) : (n.addWithUpdate(c), this._hoveredTarget = n, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(o, h) }, _createActiveSelection: function (c, h) { var n = this.getActiveObjects(), o = this._createGroup(c); this._hoveredTarget = o, this._setActiveObject(o, h), this._fireSelectionEvents(n, h) }, _createGroup: function (c) { var h = this._objects, n = h.indexOf(this._activeObject) < h.indexOf(c), o = n ? [this._activeObject, c] : [c, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new t.ActiveSelection(o, { canvas: this }) }, _groupSelectedObjects: function (c) { var h = this._collectObjects(c), n; h.length === 1 ? this.setActiveObject(h[0], c) : h.length > 1 && (n = new t.ActiveSelection(h.reverse(), { canvas: this }), this.setActiveObject(n, c)) }, _collectObjects: function (c) { for (var h = [], n, o = this._groupSelector.ex, i = this._groupSelector.ey, s = o + this._groupSelector.left, u = i + this._groupSelector.top, l = new t.Point(f(o, s), f(i, u)), d = new t.Point(r(o, s), r(i, u)), g = !this.selectionFullyContained, m = o === s && i === u, y = this._objects.length; y-- && (n = this._objects[y], !(!(!n || !n.selectable || !n.visible) && (g && n.intersectsWithRect(l, d, !0) || n.isContainedWithinRect(l, d, !0) || g && n.containsPoint(l, null, !0) || g && n.containsPoint(d, null, !0)) && (h.push(n), m)));); return h.length > 1 && (h = h.filter(function (w) { return !w.onSelect({ e: c }) })), h }, _maybeGroupObjects: function (c) { this.selection && this._groupSelector && this._groupSelectedObjects(c), this.setCursor(this.defaultCursor), this._groupSelector = null } }) }(), function () { t.util.object.extend(t.StaticCanvas.prototype, { toDataURL: function (f) { f || (f = {}); var r = f.format || "png", c = f.quality || 1, h = (f.multiplier || 1) * (f.enableRetinaScaling ? this.getRetinaScaling() : 1), n = this.toCanvasElement(h, f); return t.util.toDataURL(n, r, c) }, toCanvasElement: function (f, r) { f = f || 1, r = r || {}; var c = (r.width || this.width) * f, h = (r.height || this.height) * f, n = this.getZoom(), o = this.width, i = this.height, s = n * f, u = this.viewportTransform, l = (u[4] - (r.left || 0)) * f, d = (u[5] - (r.top || 0)) * f, g = this.interactive, m = [s, 0, 0, s, l, d], y = this.enableRetinaScaling, w = t.util.createCanvasElement(), C = this.contextTop; return w.width = c, w.height = h, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = m, this.width = c, this.height = h, this.calcViewportBoundaries(), this.renderCanvas(w.getContext("2d"), this._objects), this.viewportTransform = u, this.width = o, this.height = i, this.calcViewportBoundaries(), this.interactive = g, this.enableRetinaScaling = y, this.contextTop = C, w } }) }(), t.util.object.extend(t.StaticCanvas.prototype, { loadFromJSON: function (f, r, c) { if (f) { var h = typeof f == "string" ? JSON.parse(f) : t.util.object.clone(f), n = this, o = h.clipPath, i = this.renderOnAddRemove; return this.renderOnAddRemove = !1, delete h.clipPath, this._enlivenObjects(h.objects, function (s) { n.clear(), n._setBgOverlay(h, function () { o ? n._enlivenObjects([o], function (u) { n.clipPath = u[0], n.__setupCanvas.call(n, h, s, i, r) }) : n.__setupCanvas.call(n, h, s, i, r) }) }, c), this } }, __setupCanvas: function (f, r, c, h) { var n = this; r.forEach(function (o, i) { n.insertAt(o, i) }), this.renderOnAddRemove = c, delete f.objects, delete f.backgroundImage, delete f.overlayImage, delete f.background, delete f.overlay, this._setOptions(f), this.renderAll(), h && h() }, _setBgOverlay: function (f, r) { var c = { backgroundColor: !1, overlayColor: !1, backgroundImage: !1, overlayImage: !1 }; if (!f.backgroundImage && !f.overlayImage && !f.background && !f.overlay) { r && r(); return } var h = function () { c.backgroundImage && c.overlayImage && c.backgroundColor && c.overlayColor && r && r() }; this.__setBgOverlay("backgroundImage", f.backgroundImage, c, h), this.__setBgOverlay("overlayImage", f.overlayImage, c, h), this.__setBgOverlay("backgroundColor", f.background, c, h), this.__setBgOverlay("overlayColor", f.overlay, c, h) }, __setBgOverlay: function (f, r, c, h) { var n = this; if (!r) { c[f] = !0, h && h(); return } f === "backgroundImage" || f === "overlayImage" ? t.util.enlivenObjects([r], function (o) { n[f] = o[0], c[f] = !0, h && h() }) : this["set" + t.util.string.capitalize(f, !0)](r, function () { c[f] = !0, h && h() }) }, _enlivenObjects: function (f, r, c) { if (!f || f.length === 0) { r && r([]); return } t.util.enlivenObjects(f, function (h) { r && r(h) }, null, c) }, _toDataURL: function (f, r) { this.clone(function (c) { r(c.toDataURL(f)) }) }, _toDataURLWithMultiplier: function (f, r, c) { this.clone(function (h) { c(h.toDataURLWithMultiplier(f, r)) }) }, clone: function (f, r) { var c = JSON.stringify(this.toJSON(r)); this.cloneWithoutData(function (h) { h.loadFromJSON(c, function () { f && f(h) }) }) }, cloneWithoutData: function (f) { var r = t.util.createCanvasElement(); r.width = this.width, r.height = this.height; var c = new t.Canvas(r); this.backgroundImage ? (c.setBackgroundImage(this.backgroundImage.src, function () { c.renderAll(), f && f(c) }), c.backgroundImageOpacity = this.backgroundImageOpacity, c.backgroundImageStretch = this.backgroundImageStretch) : f && f(c) } }), function (f) { var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.util.object.clone, n = r.util.toFixed, o = r.util.string.capitalize, i = r.util.degreesToRadians, s = !r.isLikelyNode, u = 2; r.Object || (r.Object = r.util.createClass(r.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgb(178,204,255)", borderDashArray: null, cornerColor: "rgb(178,204,255)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, minScaleLimit: 0, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, perPixelTargetFind: !1, includeDefaultValues: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: s, statefullCache: !1, noScaleCache: !0, strokeUniform: !1, dirty: !0, __corner: 0, paintFirst: "fill", activeOn: "down", stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "), colorProperties: "fill stroke backgroundColor".split(" "), clipPath: void 0, inverted: !1, absolutePositioned: !1, initialize: function (l) { l && this.setOptions(l) }, _createCacheCanvas: function () { this._cacheProperties = {}, this._cacheCanvas = r.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0 }, _limitCacheSize: function (l) { var d = r.perfLimitSizeTotal, g = l.width, m = l.height, y = r.maxCacheSideLimit, w = r.minCacheSideLimit; if (g <= y && m <= y && g * m <= d) return g < w && (l.width = w), m < w && (l.height = w), l; var C = g / m, T = r.util.limitDimsByArea(C, d), A = r.util.capValue, U = A(w, T.x, y), R = A(w, T.y, y); return g > U && (l.zoomX /= g / U, l.width = U, l.capped = !0), m > R && (l.zoomY /= m / R, l.height = R, l.capped = !0), l }, _getCacheCanvasDimensions: function () { var l = this.getTotalObjectScaling(), d = this._getTransformedDimensions(0, 0), g = d.x * l.scaleX / this.scaleX, m = d.y * l.scaleY / this.scaleY; return { width: g + u, height: m + u, zoomX: l.scaleX, zoomY: l.scaleY, x: g, y: m } }, _updateCacheCanvas: function () { var l = this.canvas; if (this.noScaleCache && l && l._currentTransform) { var d = l._currentTransform.target, g = l._currentTransform.action; if (this === d && g.slice && g.slice(0, 5) === "scale") return !1 } var m = this._cacheCanvas, y = this._limitCacheSize(this._getCacheCanvasDimensions()), w = r.minCacheSideLimit, C = y.width, T = y.height, A, U, R = y.zoomX, $ = y.zoomY, L = C !== this.cacheWidth || T !== this.cacheHeight, B = this.zoomX !== R || this.zoomY !== $, N = L || B, K = 0, st = 0, ft = !1; if (L) { var ht = this._cacheCanvas.width, k = this._cacheCanvas.height, M = C > ht || T > k, E = (C < ht * .9 || T < k * .9) && ht > w && k > w; ft = M || E, M && !y.capped && (C > w || T > w) && (K = C * .1, st = T * .1) } return this instanceof r.Text && this.path && (N = !0, ft = !0, K += this.getHeightOfLine(0) * this.zoomX, st += this.getHeightOfLine(0) * this.zoomY), N ? (ft ? (m.width = Math.ceil(C + K), m.height = Math.ceil(T + st)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, m.width, m.height)), A = y.x / 2, U = y.y / 2, this.cacheTranslationX = Math.round(m.width / 2 - A) + A, this.cacheTranslationY = Math.round(m.height / 2 - U) + U, this.cacheWidth = C, this.cacheHeight = T, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(R, $), this.zoomX = R, this.zoomY = $, !0) : !1 }, setOptions: function (l) { this._setOptions(l), this._initGradient(l.fill, "fill"), this._initGradient(l.stroke, "stroke"), this._initPattern(l.fill, "fill"), this._initPattern(l.stroke, "stroke") }, transform: function (l) { var d = this.group && !this.group._transformDone || this.group && this.canvas && l === this.canvas.contextTop, g = this.calcTransformMatrix(!d); l.transform(g[0], g[1], g[2], g[3], g[4], g[5]) }, toObject: function (l) { var d = r.Object.NUM_FRACTION_DIGITS, g = { type: this.type, version: r.version, originX: this.originX, originY: this.originY, left: n(this.left, d), top: n(this.top, d), width: n(this.width, d), height: n(this.height, d), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: n(this.strokeWidth, d), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: n(this.strokeMiterLimit, d), scaleX: n(this.scaleX, d), scaleY: n(this.scaleY, d), angle: n(this.angle, d), flipX: this.flipX, flipY: this.flipY, opacity: n(this.opacity, d), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: n(this.skewX, d), skewY: n(this.skewY, d) }; return this.clipPath && !this.clipPath.excludeFromExport && (g.clipPath = this.clipPath.toObject(l), g.clipPath.inverted = this.clipPath.inverted, g.clipPath.absolutePositioned = this.clipPath.absolutePositioned), r.util.populateWithProperties(this, g, l), this.includeDefaultValues || (g = this._removeDefaultValues(g)), g }, toDatalessObject: function (l) { return this.toObject(l) }, _removeDefaultValues: function (l) { var d = r.util.getKlass(l.type).prototype, g = d.stateProperties; return g.forEach(function (m) { m === "left" || m === "top" || (l[m] === d[m] && delete l[m], Array.isArray(l[m]) && Array.isArray(d[m]) && l[m].length === 0 && d[m].length === 0 && delete l[m]) }), l }, toString: function () { return "#<fabric." + o(this.type) + ">" }, getObjectScaling: function () { if (!this.group) return { scaleX: this.scaleX, scaleY: this.scaleY }; var l = r.util.qrDecompose(this.calcTransformMatrix()); return { scaleX: Math.abs(l.scaleX), scaleY: Math.abs(l.scaleY) } }, getTotalObjectScaling: function () { var l = this.getObjectScaling(), d = l.scaleX, g = l.scaleY; if (this.canvas) { var m = this.canvas.getZoom(), y = this.canvas.getRetinaScaling(); d *= m * y, g *= m * y } return { scaleX: d, scaleY: g } }, getObjectOpacity: function () { var l = this.opacity; return this.group && (l *= this.group.getObjectOpacity()), l }, _set: function (l, d) { var g = l === "scaleX" || l === "scaleY", m = this[l] !== d, y = !1; return g && (d = this._constrainScale(d)), l === "scaleX" && d < 0 ? (this.flipX = !this.flipX, d *= -1) : l === "scaleY" && d < 0 ? (this.flipY = !this.flipY, d *= -1) : l === "shadow" && d && !(d instanceof r.Shadow) ? d = new r.Shadow(d) : l === "dirty" && this.group && this.group.set("dirty", d), this[l] = d, m && (y = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(l) > -1 ? (this.dirty = !0, y && this.group.set("dirty", !0)) : y && this.stateProperties.indexOf(l) > -1 && this.group.set("dirty", !0)), this }, setOnGroup: function () { }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : r.iMatrix.concat() }, isNotVisible: function () { return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible }, render: function (l) { this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (l.save(), this._setupCompositeOperation(l), this.drawSelectionBackground(l), this.transform(l), this._setOpacity(l), this._setShadow(l, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(l)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(l), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), l.restore()) }, renderCache: function (l) { l = l || {}, (!this._cacheCanvas || !this._cacheContext) && this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, l.forClipping), this.dirty = !1) }, _removeCacheCanvas: function () { this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0 }, hasStroke: function () { return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0 }, hasFill: function () { return this.fill && this.fill !== "transparent" }, needsItsOwnCache: function () { return !!(this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow == "object" || this.clipPath) }, shouldCache: function () { return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching }, willDrawShadow: function () { return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0) }, drawClipPathOnCache: function (l, d) { if (l.save(), d.inverted ? l.globalCompositeOperation = "destination-out" : l.globalCompositeOperation = "destination-in", d.absolutePositioned) { var g = r.util.invertTransform(this.calcTransformMatrix()); l.transform(g[0], g[1], g[2], g[3], g[4], g[5]) } d.transform(l), l.scale(1 / d.zoomX, 1 / d.zoomY), l.drawImage(d._cacheCanvas, -d.cacheTranslationX, -d.cacheTranslationY), l.restore() }, drawObject: function (l, d) { var g = this.fill, m = this.stroke; d ? (this.fill = "black", this.stroke = "", this._setClippingProperties(l)) : this._renderBackground(l), this._render(l), this._drawClipPath(l, this.clipPath), this.fill = g, this.stroke = m }, _drawClipPath: function (l, d) { d && (d.canvas = this.canvas, d.shouldCache(), d._transformDone = !0, d.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(l, d)) }, drawCacheOnCanvas: function (l) { l.scale(1 / this.zoomX, 1 / this.zoomY), l.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY) }, isCacheDirty: function (l) { if (this.isNotVisible()) return !1; if (this._cacheCanvas && this._cacheContext && !l && this._updateCacheCanvas()) return !0; if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (this._cacheCanvas && this._cacheContext && !l) { var d = this.cacheWidth / this.zoomX, g = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-d / 2, -g / 2, d, g) } return !0 } return !1 }, _renderBackground: function (l) { if (this.backgroundColor) { var d = this._getNonTransformedDimensions(); l.fillStyle = this.backgroundColor, l.fillRect(-d.x / 2, -d.y / 2, d.x, d.y), this._removeShadow(l) } }, _setOpacity: function (l) { this.group && !this.group._transformDone ? l.globalAlpha = this.getObjectOpacity() : l.globalAlpha *= this.opacity }, _setStrokeStyles: function (l, d) { var g = d.stroke; g && (l.lineWidth = d.strokeWidth, l.lineCap = d.strokeLineCap, l.lineDashOffset = d.strokeDashOffset, l.lineJoin = d.strokeLineJoin, l.miterLimit = d.strokeMiterLimit, g.toLive ? g.gradientUnits === "percentage" || g.gradientTransform || g.patternTransform ? this._applyPatternForTransformedGradient(l, g) : (l.strokeStyle = g.toLive(l, this), this._applyPatternGradientTransform(l, g)) : l.strokeStyle = d.stroke) }, _setFillStyles: function (l, d) { var g = d.fill; g && (g.toLive ? (l.fillStyle = g.toLive(l, this), this._applyPatternGradientTransform(l, d.fill)) : l.fillStyle = g) }, _setClippingProperties: function (l) { l.globalAlpha = 1, l.strokeStyle = "transparent", l.fillStyle = "#000000" }, _setLineDash: function (l, d) { !d || d.length === 0 || (1 & d.length && d.push.apply(d, d), l.setLineDash(d)) }, _renderControls: function (l, d) { var g = this.getViewportTransform(), m = this.calcTransformMatrix(), y, w, C; d = d || {}, w = typeof d.hasBorders != "undefined" ? d.hasBorders : this.hasBorders, C = typeof d.hasControls != "undefined" ? d.hasControls : this.hasControls, m = r.util.multiplyTransformMatrices(g, m), y = r.util.qrDecompose(m), l.save(), l.translate(y.translateX, y.translateY), l.lineWidth = 1 * this.borderScaleFactor, this.group || (l.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (y.angle -= 180), l.rotate(i(this.group ? y.angle : this.angle)), d.forActiveSelection || this.group ? w && this.drawBordersInGroup(l, y, d) : w && this.drawBorders(l, d), C && this.drawControls(l, d), l.restore() }, _setShadow: function (l) { if (this.shadow) { var d = this.shadow, g = this.canvas, m, y = g && g.viewportTransform[0] || 1, w = g && g.viewportTransform[3] || 1; d.nonScaling ? m = { scaleX: 1, scaleY: 1 } : m = this.getObjectScaling(), g && g._isRetinaScaling() && (y *= r.devicePixelRatio, w *= r.devicePixelRatio), l.shadowColor = d.color, l.shadowBlur = d.blur * r.browserShadowBlurConstant * (y + w) * (m.scaleX + m.scaleY) / 4, l.shadowOffsetX = d.offsetX * y * m.scaleX, l.shadowOffsetY = d.offsetY * w * m.scaleY } }, _removeShadow: function (l) { this.shadow && (l.shadowColor = "", l.shadowBlur = l.shadowOffsetX = l.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (l, d) { if (!d || !d.toLive) return { offsetX: 0, offsetY: 0 }; var g = d.gradientTransform || d.patternTransform, m = -this.width / 2 + d.offsetX || 0, y = -this.height / 2 + d.offsetY || 0; return d.gradientUnits === "percentage" ? l.transform(this.width, 0, 0, this.height, m, y) : l.transform(1, 0, 0, 1, m, y), g && l.transform(g[0], g[1], g[2], g[3], g[4], g[5]), { offsetX: m, offsetY: y } }, _renderPaintInOrder: function (l) { this.paintFirst === "stroke" ? (this._renderStroke(l), this._renderFill(l)) : (this._renderFill(l), this._renderStroke(l)) }, _render: function () { }, _renderFill: function (l) { this.fill && (l.save(), this._setFillStyles(l, this), this.fillRule === "evenodd" ? l.fill("evenodd") : l.fill(), l.restore()) }, _renderStroke: function (l) { if (!(!this.stroke || this.strokeWidth === 0)) { if (this.shadow && !this.shadow.affectStroke && this._removeShadow(l), l.save(), this.strokeUniform && this.group) { var d = this.getObjectScaling(); l.scale(1 / d.scaleX, 1 / d.scaleY) } else this.strokeUniform && l.scale(1 / this.scaleX, 1 / this.scaleY); this._setLineDash(l, this.strokeDashArray), this._setStrokeStyles(l, this), l.stroke(), l.restore() } }, _applyPatternForTransformedGradient: function (l, d) { var g = this._limitCacheSize(this._getCacheCanvasDimensions()), m = r.util.createCanvasElement(), y, w = this.canvas.getRetinaScaling(), C = g.x / this.scaleX / w, T = g.y / this.scaleY / w; m.width = C, m.height = T, y = m.getContext("2d"), y.beginPath(), y.moveTo(0, 0), y.lineTo(C, 0), y.lineTo(C, T), y.lineTo(0, T), y.closePath(), y.translate(C / 2, T / 2), y.scale(g.zoomX / this.scaleX / w, g.zoomY / this.scaleY / w), this._applyPatternGradientTransform(y, d), y.fillStyle = d.toLive(l), y.fill(), l.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), l.scale(w * this.scaleX / g.zoomX, w * this.scaleY / g.zoomY), l.strokeStyle = y.createPattern(m, "no-repeat") }, _findCenterFromElement: function () { return { x: this.left + this.width / 2, y: this.top + this.height / 2 } }, _assignTransformMatrixProps: function () { if (this.transformMatrix) { var l = r.util.qrDecompose(this.transformMatrix); this.flipX = !1, this.flipY = !1, this.set("scaleX", l.scaleX), this.set("scaleY", l.scaleY), this.angle = l.angle, this.skewX = l.skewX, this.skewY = 0 } }, _removeTransformMatrix: function (l) { var d = this._findCenterFromElement(); this.transformMatrix && (this._assignTransformMatrixProps(), d = r.util.transformPoint(d, this.transformMatrix)), this.transformMatrix = null, l && (this.scaleX *= l.scaleX, this.scaleY *= l.scaleY, this.cropX = l.cropX, this.cropY = l.cropY, d.x += l.offsetLeft, d.y += l.offsetTop, this.width = l.width, this.height = l.height), this.setPositionByOrigin(d, "center", "center") }, clone: function (l, d) { var g = this.toObject(d); this.constructor.fromObject ? this.constructor.fromObject(g, l) : r.Object._fromObject("Object", g, l) }, cloneAsImage: function (l, d) { var g = this.toCanvasElement(d); return l && l(new r.Image(g)), this }, toCanvasElement: function (l) { l || (l = {}); var d = r.util, g = d.saveObjectTransform(this), m = this.group, y = this.shadow, w = Math.abs, C = (l.multiplier || 1) * (l.enableRetinaScaling ? r.devicePixelRatio : 1); delete this.group, l.withoutTransform && d.resetObjectTransform(this), l.withoutShadow && (this.shadow = null); var T = r.util.createCanvasElement(), A = this.getBoundingRect(!0, !0), U = this.shadow, R, $ = { x: 0, y: 0 }, L, B, N; U && (L = U.blur, U.nonScaling ? R = { scaleX: 1, scaleY: 1 } : R = this.getObjectScaling(), $.x = 2 * Math.round(w(U.offsetX) + L) * w(R.scaleX), $.y = 2 * Math.round(w(U.offsetY) + L) * w(R.scaleY)), B = A.width + $.x, N = A.height + $.y, T.width = Math.ceil(B), T.height = Math.ceil(N); var K = new r.StaticCanvas(T, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }); l.format === "jpeg" && (K.backgroundColor = "#fff"), this.setPositionByOrigin(new r.Point(K.width / 2, K.height / 2), "center", "center"); var st = this.canvas; K.add(this); var ft = K.toCanvasElement(C || 1, l); return this.shadow = y, this.set("canvas", st), m && (this.group = m), this.set(g).setCoords(), K._objects = [], K.dispose(), K = null, ft }, toDataURL: function (l) { return l || (l = {}), r.util.toDataURL(this.toCanvasElement(l), l.format || "png", l.quality || 1) }, isType: function (l) { return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === l }, complexity: function () { return 1 }, toJSON: function (l) { return this.toObject(l) }, rotate: function (l) { var d = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation; return d && this._setOriginToCenter(), this.set("angle", l), d && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, getLocalPointer: function (l, d) { d = d || this.canvas.getPointer(l); var g = new r.Point(d.x, d.y), m = this._getLeftTopCoords(); return this.angle && (g = r.util.rotatePoint(g, m, i(-this.angle))), { x: g.x - m.x, y: g.y - m.y } }, _setupCompositeOperation: function (l) { this.globalCompositeOperation && (l.globalCompositeOperation = this.globalCompositeOperation) }, dispose: function () { r.runningAnimations && r.runningAnimations.cancelByTarget(this) } }), r.util.createAccessors && r.util.createAccessors(r.Object), c(r.Object.prototype, r.Observable), r.Object.NUM_FRACTION_DIGITS = 2, r.Object.ENLIVEN_PROPS = ["clipPath"], r.Object._fromObject = function (l, d, g, m) { var y = r[l]; d = h(d, !0), r.util.enlivenPatterns([d.fill, d.stroke], function (w) { typeof w[0] != "undefined" && (d.fill = w[0]), typeof w[1] != "undefined" && (d.stroke = w[1]), r.util.enlivenObjectEnlivables(d, d, function () { var C = m ? new y(d[m], d) : new y(d); g && g(C) }) }) }, r.Object.__uid = 0) }(e), function () { var f = t.util.degreesToRadians, r = { left: -.5, center: 0, right: .5 }, c = { top: -.5, center: 0, bottom: .5 }; t.util.object.extend(t.Object.prototype, { translateToGivenOrigin: function (h, n, o, i, s) { var u = h.x, l = h.y, d, g, m; return typeof n == "string" ? n = r[n] : n -= .5, typeof i == "string" ? i = r[i] : i -= .5, d = i - n, typeof o == "string" ? o = c[o] : o -= .5, typeof s == "string" ? s = c[s] : s -= .5, g = s - o, (d || g) && (m = this._getTransformedDimensions(), u = h.x + d * m.x, l = h.y + g * m.y), new t.Point(u, l) }, translateToCenterPoint: function (h, n, o) { var i = this.translateToGivenOrigin(h, n, o, "center", "center"); return this.angle ? t.util.rotatePoint(i, h, f(this.angle)) : i }, translateToOriginPoint: function (h, n, o) { var i = this.translateToGivenOrigin(h, "center", "center", n, o); return this.angle ? t.util.rotatePoint(i, h, f(this.angle)) : i }, getCenterPoint: function () { var h = new t.Point(this.left, this.top); return this.translateToCenterPoint(h, this.originX, this.originY) }, getPointByOrigin: function (h, n) { var o = this.getCenterPoint(); return this.translateToOriginPoint(o, h, n) }, toLocalPoint: function (h, n, o) { var i = this.getCenterPoint(), s, u; return typeof n != "undefined" && typeof o != "undefined" ? s = this.translateToGivenOrigin(i, "center", "center", n, o) : s = new t.Point(this.left, this.top), u = new t.Point(h.x, h.y), this.angle && (u = t.util.rotatePoint(u, i, -f(this.angle))), u.subtractEquals(s) }, setPositionByOrigin: function (h, n, o) { var i = this.translateToCenterPoint(h, n, o), s = this.translateToOriginPoint(i, this.originX, this.originY); this.set("left", s.x), this.set("top", s.y) }, adjustPosition: function (h) { var n = f(this.angle), o = this.getScaledWidth(), i = t.util.cos(n) * o, s = t.util.sin(n) * o, u, l; typeof this.originX == "string" ? u = r[this.originX] : u = this.originX - .5, typeof h == "string" ? l = r[h] : l = h - .5, this.left += i * (l - u), this.top += s * (l - u), this.setCoords(), this.originX = h }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var h = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = h.x, this.top = h.y }, _resetOrigin: function () { var h = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = h.x, this.top = h.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") } }) }(), function () { function f(o) { return [new t.Point(o.tl.x, o.tl.y), new t.Point(o.tr.x, o.tr.y), new t.Point(o.br.x, o.br.y), new t.Point(o.bl.x, o.bl.y)] } var r = t.util, c = r.degreesToRadians, h = r.multiplyTransformMatrices, n = r.transformPoint; r.object.extend(t.Object.prototype, { oCoords: null, aCoords: null, lineCoords: null, ownMatrixCache: null, matrixCache: null, controls: {}, _getCoords: function (o, i) { return i ? o ? this.calcACoords() : this.calcLineCoords() : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0), o ? this.aCoords : this.lineCoords) }, getCoords: function (o, i) { return f(this._getCoords(o, i)) }, intersectsWithRect: function (o, i, s, u) { var l = this.getCoords(s, u), d = t.Intersection.intersectPolygonRectangle(l, o, i); return d.status === "Intersection" }, intersectsWithObject: function (o, i, s) { var u = t.Intersection.intersectPolygonPolygon(this.getCoords(i, s), o.getCoords(i, s)); return u.status === "Intersection" || o.isContainedWithinObject(this, i, s) || this.isContainedWithinObject(o, i, s) }, isContainedWithinObject: function (o, i, s) { for (var u = this.getCoords(i, s), l = i ? o.aCoords : o.lineCoords, d = 0, g = o._getImageLines(l); d < 4; d++)if (!o.containsPoint(u[d], g)) return !1; return !0 }, isContainedWithinRect: function (o, i, s, u) { var l = this.getBoundingRect(s, u); return l.left >= o.x && l.left + l.width <= i.x && l.top >= o.y && l.top + l.height <= i.y }, containsPoint: function (o, d, s, u) { var l = this._getCoords(s, u), d = d || this._getImageLines(l), g = this._findCrossPoints(o, d); return g !== 0 && g % 2 === 1 }, isOnScreen: function (o) { if (!this.canvas) return !1; var i = this.canvas.vptCoords.tl, s = this.canvas.vptCoords.br, u = this.getCoords(!0, o); return u.some(function (l) { return l.x <= s.x && l.x >= i.x && l.y <= s.y && l.y >= i.y }) || this.intersectsWithRect(i, s, !0, o) ? !0 : this._containsCenterOfCanvas(i, s, o) }, _containsCenterOfCanvas: function (o, i, s) { var u = { x: (o.x + i.x) / 2, y: (o.y + i.y) / 2 }; return !!this.containsPoint(u, null, !0, s) }, isPartiallyOnScreen: function (o) { if (!this.canvas) return !1; var i = this.canvas.vptCoords.tl, s = this.canvas.vptCoords.br; if (this.intersectsWithRect(i, s, !0, o)) return !0; var u = this.getCoords(!0, o).every(function (l) { return (l.x >= s.x || l.x <= i.x) && (l.y >= s.y || l.y <= i.y) }); return u && this._containsCenterOfCanvas(i, s, o) }, _getImageLines: function (o) { var i = { topline: { o: o.tl, d: o.tr }, rightline: { o: o.tr, d: o.br }, bottomline: { o: o.br, d: o.bl }, leftline: { o: o.bl, d: o.tl } }; return i }, _findCrossPoints: function (o, i) { var s, u, l, d, g, m = 0, y; for (var w in i) if (y = i[w], !(y.o.y < o.y && y.d.y < o.y) && !(y.o.y >= o.y && y.d.y >= o.y) && (y.o.x === y.d.x && y.o.x >= o.x ? g = y.o.x : (s = 0, u = (y.d.y - y.o.y) / (y.d.x - y.o.x), l = o.y - s * o.x, d = y.o.y - u * y.o.x, g = -(l - d) / (s - u)), g >= o.x && (m += 1), m === 2)) break; return m }, getBoundingRect: function (o, i) { var s = this.getCoords(o, i); return r.makeBoundingBoxFromPoints(s) }, getScaledWidth: function () { return this._getTransformedDimensions().x }, getScaledHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (o) { return Math.abs(o) < this.minScaleLimit ? o < 0 ? -this.minScaleLimit : this.minScaleLimit : o === 0 ? 1e-4 : o }, scale: function (o) { return this._set("scaleX", o), this._set("scaleY", o), this.setCoords() }, scaleToWidth: function (o, i) { var s = this.getBoundingRect(i).width / this.getScaledWidth(); return this.scale(o / this.width / s) }, scaleToHeight: function (o, i) { var s = this.getBoundingRect(i).height / this.getScaledHeight(); return this.scale(o / this.height / s) }, calcLineCoords: function () { var o = this.getViewportTransform(), i = this.padding, s = c(this.angle), u = r.cos(s), l = r.sin(s), d = u * i, g = l * i, m = d + g, y = d - g, w = this.calcACoords(), C = { tl: n(w.tl, o), tr: n(w.tr, o), bl: n(w.bl, o), br: n(w.br, o) }; return i && (C.tl.x -= y, C.tl.y -= m, C.tr.x += m, C.tr.y -= y, C.bl.x -= m, C.bl.y += y, C.br.x += y, C.br.y += m), C }, calcOCoords: function () { var o = this._calcRotateMatrix(), i = this._calcTranslateMatrix(), s = this.getViewportTransform(), u = h(s, i), l = h(u, o), l = h(l, [1 / s[0], 0, 0, 1 / s[3], 0, 0]), d = this._calculateCurrentDimensions(), g = {}; return this.forEachControl(function (m, y, w) { g[y] = m.positionHandler(d, l, w) }), g }, calcACoords: function () { var o = this._calcRotateMatrix(), i = this._calcTranslateMatrix(), s = h(i, o), u = this._getTransformedDimensions(), l = u.x / 2, d = u.y / 2; return { tl: n({ x: -l, y: -d }, s), tr: n({ x: l, y: -d }, s), bl: n({ x: -l, y: d }, s), br: n({ x: l, y: d }, s) } }, setCoords: function (o) { return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), o ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this) }, _calcRotateMatrix: function () { return r.calcRotateMatrix(this) }, _calcTranslateMatrix: function () { var o = this.getCenterPoint(); return [1, 0, 0, 1, o.x, o.y] }, transformMatrixKey: function (o) { var i = "_", s = ""; return !o && this.group && (s = this.group.transformMatrixKey(o) + i), s + this.top + i + this.left + i + this.scaleX + i + this.scaleY + i + this.skewX + i + this.skewY + i + this.angle + i + this.originX + i + this.originY + i + this.width + i + this.height + i + this.strokeWidth + this.flipX + this.flipY }, calcTransformMatrix: function (o) { var i = this.calcOwnMatrix(); if (o || !this.group) return i; var s = this.transformMatrixKey(o), u = this.matrixCache || (this.matrixCache = {}); return u.key === s ? u.value : (this.group && (i = h(this.group.calcTransformMatrix(!1), i)), u.key = s, u.value = i, i) }, calcOwnMatrix: function () { var o = this.transformMatrixKey(!0), i = this.ownMatrixCache || (this.ownMatrixCache = {}); if (i.key === o) return i.value; var s = this._calcTranslateMatrix(), u = { angle: this.angle, translateX: s[4], translateY: s[5], scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }; return i.key = o, i.value = r.composeMatrix(u), i.value }, _getNonTransformedDimensions: function () { var o = this.strokeWidth, i = this.width + o, s = this.height + o; return { x: i, y: s } }, _getTransformedDimensions: function (o, i) { typeof o == "undefined" && (o = this.skewX), typeof i == "undefined" && (i = this.skewY); var s, u, l, d = o === 0 && i === 0; if (this.strokeUniform ? (u = this.width, l = this.height) : (s = this._getNonTransformedDimensions(), u = s.x, l = s.y), d) return this._finalizeDimensions(u * this.scaleX, l * this.scaleY); var g = r.sizeAfterTransform(u, l, { scaleX: this.scaleX, scaleY: this.scaleY, skewX: o, skewY: i }); return this._finalizeDimensions(g.x, g.y) }, _finalizeDimensions: function (o, i) { return this.strokeUniform ? { x: o + this.strokeWidth, y: i + this.strokeWidth } : { x: o, y: i } }, _calculateCurrentDimensions: function () { var o = this.getViewportTransform(), i = this._getTransformedDimensions(), s = n(i, o, !0); return s.scalarAdd(2 * this.padding) } }) }(), t.util.object.extend(t.Object.prototype, { sendToBack: function () { return this.group ? t.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? t.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this }, sendBackwards: function (f) { return this.group ? t.StaticCanvas.prototype.sendBackwards.call(this.group, this, f) : this.canvas && this.canvas.sendBackwards(this, f), this }, bringForward: function (f) { return this.group ? t.StaticCanvas.prototype.bringForward.call(this.group, this, f) : this.canvas && this.canvas.bringForward(this, f), this }, moveTo: function (f) { return this.group && this.group.type !== "activeSelection" ? t.StaticCanvas.prototype.moveTo.call(this.group, this, f) : this.canvas && this.canvas.moveTo(this, f), this } }), function () {
	function f(c, h) { if (h) { if (h.toLive) return c + ": url(#SVGID_" + h.id + "); "; var n = new t.Color(h), o = c + ": " + n.toRgb() + "; ", i = n.getAlpha(); return i !== 1 && (o += c + "-opacity: " + i.toString() + "; "), o } else return c + ": none; " } var r = t.util.toFixed; t.util.object.extend(t.Object.prototype, {
		getSvgStyles: function (c) { var h = this.fillRule ? this.fillRule : "nonzero", n = this.strokeWidth ? this.strokeWidth : "0", o = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", i = this.strokeDashOffset ? this.strokeDashOffset : "0", s = this.strokeLineCap ? this.strokeLineCap : "butt", u = this.strokeLineJoin ? this.strokeLineJoin : "miter", l = this.strokeMiterLimit ? this.strokeMiterLimit : "4", d = typeof this.opacity != "undefined" ? this.opacity : "1", g = this.visible ? "" : " visibility: hidden;", m = c ? "" : this.getSvgFilter(), y = f("fill", this.fill), w = f("stroke", this.stroke); return [w, "stroke-width: ", n, "; ", "stroke-dasharray: ", o, "; ", "stroke-linecap: ", s, "; ", "stroke-dashoffset: ", i, "; ", "stroke-linejoin: ", u, "; ", "stroke-miterlimit: ", l, "; ", y, "fill-rule: ", h, "; ", "opacity: ", d, ";", m, g].join("") }, getSvgSpanStyles: function (c, h) { var n = "; ", i = c.fontFamily ? "font-family: " + (c.fontFamily.indexOf("'") === -1 && c.fontFamily.indexOf('"') === -1 ? "'" + c.fontFamily + "'" : c.fontFamily) + n : "", o = c.strokeWidth ? "stroke-width: " + c.strokeWidth + n : "", i = i, s = c.fontSize ? "font-size: " + c.fontSize + "px" + n : "", u = c.fontStyle ? "font-style: " + c.fontStyle + n : "", l = c.fontWeight ? "font-weight: " + c.fontWeight + n : "", d = c.fill ? f("fill", c.fill) : "", g = c.stroke ? f("stroke", c.stroke) : "", m = this.getSvgTextDecoration(c), y = c.deltaY ? "baseline-shift: " + -c.deltaY + "; " : ""; return m && (m = "text-decoration: " + m + n), [g, o, i, s, u, l, m, d, y, h ? "white-space: pre; " : ""].join("") }, getSvgTextDecoration: function (c) { return ["overline", "underline", "line-through"].filter(function (h) { return c[h.replace("-", "")] }).join(" ") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgCommons: function () { return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("") }, getSvgTransform: function (c, h) { var n = c ? this.calcTransformMatrix() : this.calcOwnMatrix(), o = 'transform="' + t.util.matrixToSVG(n); return o + (h || "") + '" ' }, _setSVGBg: function (c) {
			if (this.backgroundColor) {
				var h = t.Object.NUM_FRACTION_DIGITS; c.push("		<rect ", this._getFillAttributes(this.backgroundColor), ' x="', r(-this.width / 2, h), '" y="', r(-this.height / 2, h), '" width="', r(this.width, h), '" height="', r(this.height, h), `"></rect>
`)
			}
		}, toSVG: function (c) { return this._createBaseSVGMarkup(this._toSVG(c), { reviver: c }) }, toClipPathSVG: function (c) { return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(c), { reviver: c }) }, _createBaseClipPathSVGMarkup: function (c, h) { h = h || {}; var n = h.reviver, o = h.additionalTransform || "", i = [this.getSvgTransform(!0, o), this.getSvgCommons()].join(""), s = c.indexOf("COMMON_PARTS"); return c[s] = i, n ? n(c.join("")) : c.join("") }, _createBaseSVGMarkup: function (c, h) {
			h = h || {}; var n = h.noStyle, o = h.reviver, i = n ? "" : 'style="' + this.getSvgStyles() + '" ', s = h.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", u = this.clipPath, l = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, g = this.stroke, m = this.fill, y = this.shadow, w, C = [], T, A = c.indexOf("COMMON_PARTS"), U = h.additionalTransform; return u && (u.clipPathId = "CLIPPATH_" + t.Object.__uid++, T = '<clipPath id="' + u.clipPathId + `" >
`+ u.toClipPathSVG(o) + `</clipPath>
`), d && C.push("<g ", s, this.getSvgCommons(), ` >
`), C.push("<g ", this.getSvgTransform(!1), d ? "" : s + this.getSvgCommons(), ` >
`), w = [i, l, n ? "" : this.addPaintOrder(), " ", U ? 'transform="' + U + '" ' : ""].join(""), c[A] = w, m && m.toLive && C.push(m.toSVG(this)), g && g.toLive && C.push(g.toSVG(this)), y && C.push(y.toSVG(this)), u && C.push(T), C.push(c.join("")), C.push(`</g>
`), d && C.push(`</g>
`), o ? o(C.join("")) : C.join("")
		}, addPaintOrder: function () { return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "" }
	})
}(), function () { var f = t.util.object.extend, r = "stateProperties"; function c(n, o, i) { var s = {}, u = !0; i.forEach(function (l) { s[l] = n[l] }), f(n[o], s, u) } function h(n, o, i) { if (n === o) return !0; if (Array.isArray(n)) { if (!Array.isArray(o) || n.length !== o.length) return !1; for (var s = 0, u = n.length; s < u; s++)if (!h(n[s], o[s])) return !1; return !0 } else if (n && typeof n == "object") { var l = Object.keys(n), d; if (!o || typeof o != "object" || !i && l.length !== Object.keys(o).length) return !1; for (var s = 0, u = l.length; s < u; s++)if (d = l[s], !(d === "canvas" || d === "group") && !h(n[d], o[d])) return !1; return !0 } } t.util.object.extend(t.Object.prototype, { hasStateChanged: function (n) { n = n || r; var o = "_" + n; return Object.keys(this[o]).length < this[n].length ? !0 : !h(this[o], this, !0) }, saveState: function (n) { var o = n && n.propertySet || r, i = "_" + o; return this[i] ? (c(this, i, this[o]), n && n.stateProperties && c(this, i, n.stateProperties), this) : this.setupState(n) }, setupState: function (n) { n = n || {}; var o = n.propertySet || r; return n.propertySet = o, this["_" + o] = {}, this.saveState(n), this } }) }(), function () { var f = t.util.degreesToRadians; t.util.object.extend(t.Object.prototype, { _findTargetCorner: function (r, c) { if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1; var h = r.x, n = r.y, o, i, s = Object.keys(this.oCoords), u = s.length - 1, l; for (this.__corner = 0; u >= 0; u--)if (l = s[u], !!this.isControlVisible(l) && (i = this._getImageLines(c ? this.oCoords[l].touchCorner : this.oCoords[l].corner), o = this._findCrossPoints({ x: h, y: n }, i), o !== 0 && o % 2 === 1)) return this.__corner = l, l; return !1 }, forEachControl: function (r) { for (var c in this.controls) r(this.controls[c], c, this) }, _setCornerCoords: function () { var r = this.oCoords; for (var c in r) { var h = this.controls[c]; r[c].corner = h.calcCornerCoords(this.angle, this.cornerSize, r[c].x, r[c].y, !1), r[c].touchCorner = h.calcCornerCoords(this.angle, this.touchCornerSize, r[c].x, r[c].y, !0) } }, drawSelectionBackground: function (r) { if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this; r.save(); var c = this.getCenterPoint(), h = this._calculateCurrentDimensions(), n = this.canvas.viewportTransform; return r.translate(c.x, c.y), r.scale(1 / n[0], 1 / n[3]), r.rotate(f(this.angle)), r.fillStyle = this.selectionBackgroundColor, r.fillRect(-h.x / 2, -h.y / 2, h.x, h.y), r.restore(), this }, drawBorders: function (r, c) { c = c || {}; var h = this._calculateCurrentDimensions(), n = this.borderScaleFactor, o = h.x + n, i = h.y + n, s = typeof c.hasControls != "undefined" ? c.hasControls : this.hasControls, u = !1; return r.save(), r.strokeStyle = c.borderColor || this.borderColor, this._setLineDash(r, c.borderDashArray || this.borderDashArray), r.strokeRect(-o / 2, -i / 2, o, i), s && (r.beginPath(), this.forEachControl(function (l, d, g) { l.withConnection && l.getVisibility(g, d) && (u = !0, r.moveTo(l.x * o, l.y * i), r.lineTo(l.x * o + l.offsetX, l.y * i + l.offsetY)) }), u && r.stroke()), r.restore(), this }, drawBordersInGroup: function (r, c, h) { h = h || {}; var n = t.util.sizeAfterTransform(this.width, this.height, c), o = this.strokeWidth, i = this.strokeUniform, s = this.borderScaleFactor, u = n.x + o * (i ? this.canvas.getZoom() : c.scaleX) + s, l = n.y + o * (i ? this.canvas.getZoom() : c.scaleY) + s; return r.save(), this._setLineDash(r, h.borderDashArray || this.borderDashArray), r.strokeStyle = h.borderColor || this.borderColor, r.strokeRect(-u / 2, -l / 2, u, l), r.restore(), this }, drawControls: function (r, c) { c = c || {}, r.save(); var h = this.canvas.getRetinaScaling(), n, o; return r.setTransform(h, 0, 0, h, 0, 0), r.strokeStyle = r.fillStyle = c.cornerColor || this.cornerColor, this.transparentCorners || (r.strokeStyle = c.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(r, c.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (n = this.group.calcTransformMatrix()), this.forEachControl(function (i, s, u) { o = u.oCoords[s], i.getVisibility(u, s) && (n && (o = t.util.transformPoint(o, n)), i.render(r, o.x, o.y, c, u)) }), r.restore(), this }, isControlVisible: function (r) { return this.controls[r] && this.controls[r].getVisibility(this, r) }, setControlVisible: function (r, c) { return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[r] = c, this }, setControlsVisibility: function (r) { r || (r = {}); for (var c in r) this.setControlVisible(c, r[c]); return this }, onDeselect: function () { }, onSelect: function () { } }) }(), t.util.object.extend(t.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function (f, r) { r = r || {}; var c = function () { }, h = r.onComplete || c, n = r.onChange || c, o = this; return t.util.animate({ target: this, startValue: f.left, endValue: this.getCenterPoint().x, duration: this.FX_DURATION, onChange: function (i) { f.set("left", i), o.requestRenderAll(), n() }, onComplete: function () { f.setCoords(), h() } }) }, fxCenterObjectV: function (f, r) { r = r || {}; var c = function () { }, h = r.onComplete || c, n = r.onChange || c, o = this; return t.util.animate({ target: this, startValue: f.top, endValue: this.getCenterPoint().y, duration: this.FX_DURATION, onChange: function (i) { f.set("top", i), o.requestRenderAll(), n() }, onComplete: function () { f.setCoords(), h() } }) }, fxRemove: function (f, r) { r = r || {}; var c = function () { }, h = r.onComplete || c, n = r.onChange || c, o = this; return t.util.animate({ target: this, startValue: f.opacity, endValue: 0, duration: this.FX_DURATION, onChange: function (i) { f.set("opacity", i), o.requestRenderAll(), n() }, onComplete: function () { o.remove(f), h() } }) } }), t.util.object.extend(t.Object.prototype, { animate: function () { if (arguments[0] && typeof arguments[0] == "object") { var f = [], r, c, h = []; for (r in arguments[0]) f.push(r); for (var n = 0, o = f.length; n < o; n++)r = f[n], c = n !== o - 1, h.push(this._animate(r, arguments[0][r], arguments[1], c)); return h } else return this._animate.apply(this, arguments) }, _animate: function (f, r, c, h) { var n = this, o; r = r.toString(), c ? c = t.util.object.clone(c) : c = {}, ~f.indexOf(".") && (o = f.split(".")); var i = n.colorProperties.indexOf(f) > -1 || o && n.colorProperties.indexOf(o[1]) > -1, s = o ? this.get(o[0])[o[1]] : this.get(f); "from" in c || (c.from = s), i || (~r.indexOf("=") ? r = s + parseFloat(r.replace("=", "")) : r = parseFloat(r)); var u = { target: this, startValue: c.from, endValue: r, byValue: c.by, easing: c.easing, duration: c.duration, abort: c.abort && function (l, d, g) { return c.abort.call(n, l, d, g) }, onChange: function (l, d, g) { o ? n[o[0]][o[1]] = l : n.set(f, l), !h && c.onChange && c.onChange(l, d, g) }, onComplete: function (l, d, g) { h || (n.setCoords(), c.onComplete && c.onComplete(l, d, g)) } }; return i ? t.util.animateColor(u.startValue, u.endValue, u.duration, u) : t.util.animate(u) } }), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.util.object.clone, n = { x1: 1, x2: 1, y1: 1, y2: 1 }; if (r.Line) { r.warn("fabric.Line is already defined"); return } r.Line = r.util.createClass(r.Object, {
		type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: r.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"), initialize: function (i, s) { i || (i = [0, 0, 0, 0]), this.callSuper("initialize", s), this.set("x1", i[0]), this.set("y1", i[1]), this.set("x2", i[2]), this.set("y2", i[3]), this._setWidthHeight(s) }, _setWidthHeight: function (i) { i || (i = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in i ? i.left : this._getLeftToOriginX(), this.top = "top" in i ? i.top : this._getTopToOriginY() }, _set: function (i, s) { return this.callSuper("_set", i, s), typeof n[i] != "undefined" && this._setWidthHeight(), this }, _getLeftToOriginX: o({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: o({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (i) { i.beginPath(); var s = this.calcLinePoints(); i.moveTo(s.x1, s.y1), i.lineTo(s.x2, s.y2), i.lineWidth = this.strokeWidth; var u = i.strokeStyle; i.strokeStyle = this.stroke || i.fillStyle, this.stroke && this._renderStroke(i), i.strokeStyle = u }, _findCenterFromElement: function () { return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 } }, toObject: function (i) { return c(this.callSuper("toObject", i), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var i = this.callSuper("_getNonTransformedDimensions"); return this.strokeLineCap === "butt" && (this.width === 0 && (i.y -= this.strokeWidth), this.height === 0 && (i.x -= this.strokeWidth)), i }, calcLinePoints: function () { var i = this.x1 <= this.x2 ? -1 : 1, s = this.y1 <= this.y2 ? -1 : 1, u = i * this.width * .5, l = s * this.height * .5, d = i * this.width * -.5, g = s * this.height * -.5; return { x1: u, x2: d, y1: l, y2: g } }, _toSVG: function () {
			var i = this.calcLinePoints(); return ["<line ", "COMMON_PARTS", 'x1="', i.x1, '" y1="', i.y1, '" x2="', i.x2, '" y2="', i.y2, `" />
`]
		}
	}), r.Line.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), r.Line.fromElement = function (i, s, u) { u = u || {}; var l = r.parseAttributes(i, r.Line.ATTRIBUTE_NAMES), d = [l.x1 || 0, l.y1 || 0, l.x2 || 0, l.y2 || 0]; s(new r.Line(d, c(l, u))) }, r.Line.fromObject = function (i, s) { function u(d) { delete d.points, s && s(d) } var l = h(i, !0); l.points = [i.x1, i.y1, i.x2, i.y2], r.Object._fromObject("Line", l, u, "points") }; function o(i, s) { var u = i.origin, l = i.axis1, d = i.axis2, g = i.dimension, m = s.nearest, y = s.center, w = s.farthest; return function () { switch (this.get(u)) { case m: return Math.min(this.get(l), this.get(d)); case y: return Math.min(this.get(l), this.get(d)) + .5 * this.get(g); case w: return Math.max(this.get(l), this.get(d)) } } }
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.degreesToRadians; if (r.Circle) { r.warn("fabric.Circle is already defined."); return } r.Circle = r.util.createClass(r.Object, {
		type: "circle", radius: 0, startAngle: 0, endAngle: 360, cacheProperties: r.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"), _set: function (n, o) { return this.callSuper("_set", n, o), n === "radius" && this.setRadius(o), this }, toObject: function (n) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(n)) }, _toSVG: function () {
			var n, o = 0, i = 0, s = (this.endAngle - this.startAngle) % 360; if (s === 0) n = ["<circle ", "COMMON_PARTS", 'cx="' + o + '" cy="' + i + '" ', 'r="', this.radius, `" />
`]; else {
				var u = c(this.startAngle), l = c(this.endAngle), d = this.radius, g = r.util.cos(u) * d, m = r.util.sin(u) * d, y = r.util.cos(l) * d, w = r.util.sin(l) * d, C = s > 180 ? "1" : "0"; n = ['<path d="M ' + g + " " + m, " A " + d + " " + d, " 0 ", +C + " 1", " " + y + " " + w, '" ', "COMMON_PARTS", ` />
`]
			} return n
		}, _render: function (n) { n.beginPath(), n.arc(0, 0, this.radius, c(this.startAngle), c(this.endAngle), !1), this._renderPaintInOrder(n) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (n) { return this.radius = n, this.set("width", n * 2).set("height", n * 2) }
	}), r.Circle.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), r.Circle.fromElement = function (n, o) { var i = r.parseAttributes(n, r.Circle.ATTRIBUTE_NAMES); if (!h(i)) throw new Error("value of `r` attribute is required and can not be negative"); i.left = (i.left || 0) - i.radius, i.top = (i.top || 0) - i.radius, o(new r.Circle(i)) }; function h(n) { return "radius" in n && n.radius >= 0 } r.Circle.fromObject = function (n, o) { r.Object._fromObject("Circle", n, o) }
}(e), function (f) { var r = f.fabric || (f.fabric = {}); if (r.Triangle) { r.warn("fabric.Triangle is already defined"); return } r.Triangle = r.util.createClass(r.Object, { type: "triangle", width: 100, height: 100, _render: function (c) { var h = this.width / 2, n = this.height / 2; c.beginPath(), c.moveTo(-h, n), c.lineTo(0, -n), c.lineTo(h, n), c.closePath(), this._renderPaintInOrder(c) }, _toSVG: function () { var c = this.width / 2, h = this.height / 2, n = [-c + " " + h, "0 " + -h, c + " " + h].join(","); return ["<polygon ", "COMMON_PARTS", 'points="', n, '" />'] } }), r.Triangle.fromObject = function (c, h) { return r.Object._fromObject("Triangle", c, h) } }(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = Math.PI * 2; if (r.Ellipse) { r.warn("fabric.Ellipse is already defined."); return } r.Ellipse = r.util.createClass(r.Object, {
		type: "ellipse", rx: 0, ry: 0, cacheProperties: r.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (h) { this.callSuper("initialize", h), this.set("rx", h && h.rx || 0), this.set("ry", h && h.ry || 0) }, _set: function (h, n) { switch (this.callSuper("_set", h, n), h) { case "rx": this.rx = n, this.set("width", n * 2); break; case "ry": this.ry = n, this.set("height", n * 2); break }return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (h) { return this.callSuper("toObject", ["rx", "ry"].concat(h)) }, _toSVG: function () {
			return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, `" />
`]
		}, _render: function (h) { h.beginPath(), h.save(), h.transform(1, 0, 0, this.ry / this.rx, 0, 0), h.arc(0, 0, this.rx, 0, c, !1), h.restore(), this._renderPaintInOrder(h) }
	}), r.Ellipse.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), r.Ellipse.fromElement = function (h, n) { var o = r.parseAttributes(h, r.Ellipse.ATTRIBUTE_NAMES); o.left = (o.left || 0) - o.rx, o.top = (o.top || 0) - o.ry, n(new r.Ellipse(o)) }, r.Ellipse.fromObject = function (h, n) { r.Object._fromObject("Ellipse", h, n) }
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend; if (r.Rect) { r.warn("fabric.Rect is already defined"); return } r.Rect = r.util.createClass(r.Object, {
		stateProperties: r.Object.prototype.stateProperties.concat("rx", "ry"), type: "rect", rx: 0, ry: 0, cacheProperties: r.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (h) { this.callSuper("initialize", h), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (h) { var n = this.rx ? Math.min(this.rx, this.width / 2) : 0, o = this.ry ? Math.min(this.ry, this.height / 2) : 0, i = this.width, s = this.height, u = -this.width / 2, l = -this.height / 2, d = n !== 0 || o !== 0, g = 1 - .5522847498; h.beginPath(), h.moveTo(u + n, l), h.lineTo(u + i - n, l), d && h.bezierCurveTo(u + i - g * n, l, u + i, l + g * o, u + i, l + o), h.lineTo(u + i, l + s - o), d && h.bezierCurveTo(u + i, l + s - g * o, u + i - g * n, l + s, u + i - n, l + s), h.lineTo(u + n, l + s), d && h.bezierCurveTo(u + g * n, l + s, u, l + s - g * o, u, l + s - o), h.lineTo(u, l + o), d && h.bezierCurveTo(u, l + g * o, u + g * n, l, u + n, l), h.closePath(), this._renderPaintInOrder(h) }, toObject: function (h) { return this.callSuper("toObject", ["rx", "ry"].concat(h)) }, _toSVG: function () {
			var h = -this.width / 2, n = -this.height / 2; return ["<rect ", "COMMON_PARTS", 'x="', h, '" y="', n, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, `" />
`]
		}
	}), r.Rect.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), r.Rect.fromElement = function (h, n, o) { if (!h) return n(null); o = o || {}; var i = r.parseAttributes(h, r.Rect.ATTRIBUTE_NAMES); i.left = i.left || 0, i.top = i.top || 0, i.height = i.height || 0, i.width = i.width || 0; var s = new r.Rect(c(o ? r.util.object.clone(o) : {}, i)); s.visible = s.visible && s.width > 0 && s.height > 0, n(s) }, r.Rect.fromObject = function (h, n) { return r.Object._fromObject("Rect", h, n) }
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.util.array.min, n = r.util.array.max, o = r.util.toFixed, i = r.util.projectStrokeOnPoints; if (r.Polyline) { r.warn("fabric.Polyline is already defined"); return } r.Polyline = r.util.createClass(r.Object, {
		type: "polyline", points: null, exactBoundingBox: !1, cacheProperties: r.Object.prototype.cacheProperties.concat("points"), initialize: function (s, u) { u = u || {}, this.points = s || [], this.callSuper("initialize", u), this._setPositionDimensions(u) }, _projectStrokeOnPoints: function () { return i(this.points, this, !0) }, _setPositionDimensions: function (s) { var u = this._calcDimensions(s), l, d = this.exactBoundingBox ? this.strokeWidth : 0; this.width = u.width - d, this.height = u.height - d, s.fromSVG || (l = this.translateToGivenOrigin({ x: u.left - this.strokeWidth / 2 + d / 2, y: u.top - this.strokeWidth / 2 + d / 2 }, "left", "top", this.originX, this.originY)), typeof s.left == "undefined" && (this.left = s.fromSVG ? u.left : l.x), typeof s.top == "undefined" && (this.top = s.fromSVG ? u.top : l.y), this.pathOffset = { x: u.left + this.width / 2 + d / 2, y: u.top + this.height / 2 + d / 2 } }, _calcDimensions: function () { var s = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, u = h(s, "x") || 0, l = h(s, "y") || 0, d = n(s, "x") || 0, g = n(s, "y") || 0, m = d - u, y = g - l; return { left: u, top: l, width: m, height: y } }, toObject: function (s) { return c(this.callSuper("toObject", s), { points: this.points.concat() }) }, _toSVG: function () {
			for (var s = [], u = this.pathOffset.x, l = this.pathOffset.y, d = r.Object.NUM_FRACTION_DIGITS, g = 0, m = this.points.length; g < m; g++)s.push(o(this.points[g].x - u, d), ",", o(this.points[g].y - l, d), " "); return ["<" + this.type + " ", "COMMON_PARTS", 'points="', s.join(""), `" />
`]
		}, commonRender: function (s) { var u, l = this.points.length, d = this.pathOffset.x, g = this.pathOffset.y; if (!l || isNaN(this.points[l - 1].y)) return !1; s.beginPath(), s.moveTo(this.points[0].x - d, this.points[0].y - g); for (var m = 0; m < l; m++)u = this.points[m], s.lineTo(u.x - d, u.y - g); return !0 }, _render: function (s) { this.commonRender(s) && this._renderPaintInOrder(s) }, complexity: function () { return this.get("points").length }
	}), r.Polyline.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat(), r.Polyline.fromElementGenerator = function (s) { return function (u, l, d) { if (!u) return l(null); d || (d = {}); var g = r.parsePointsAttribute(u.getAttribute("points")), m = r.parseAttributes(u, r[s].ATTRIBUTE_NAMES); m.fromSVG = !0, l(new r[s](g, c(m, d))) } }, r.Polyline.fromElement = r.Polyline.fromElementGenerator("Polyline"), r.Polyline.fromObject = function (s, u) { return r.Object._fromObject("Polyline", s, u, "points") }
}(e), function (f) { var r = f.fabric || (f.fabric = {}), c = r.util.projectStrokeOnPoints; if (r.Polygon) { r.warn("fabric.Polygon is already defined"); return } r.Polygon = r.util.createClass(r.Polyline, { type: "polygon", _projectStrokeOnPoints: function () { return c(this.points, this) }, _render: function (h) { this.commonRender(h) && (h.closePath(), this._renderPaintInOrder(h)) } }), r.Polygon.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat(), r.Polygon.fromElement = r.Polyline.fromElementGenerator("Polygon"), r.Polygon.fromObject = function (h, n) { r.Object._fromObject("Polygon", h, n, "points") } }(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.array.min, h = r.util.array.max, n = r.util.object.extend, o = r.util.object.clone, i = r.util.toFixed; if (r.Path) { r.warn("fabric.Path is already defined"); return } r.Path = r.util.createClass(r.Object, {
		type: "path", path: null, cacheProperties: r.Object.prototype.cacheProperties.concat("path", "fillRule"), stateProperties: r.Object.prototype.stateProperties.concat("path"), initialize: function (s, u) { u = o(u || {}), delete u.path, this.callSuper("initialize", u), this._setPath(s || [], u) }, _setPath: function (s, u) { this.path = r.util.makePathSimpler(Array.isArray(s) ? s : r.util.parsePath(s)), r.Polyline.prototype._setPositionDimensions.call(this, u || {}) }, _renderPathCommands: function (s) { var u, l = 0, d = 0, g = 0, m = 0, y = 0, w = 0, C = -this.pathOffset.x, T = -this.pathOffset.y; s.beginPath(); for (var A = 0, U = this.path.length; A < U; ++A)switch (u = this.path[A], u[0]) { case "L": g = u[1], m = u[2], s.lineTo(g + C, m + T); break; case "M": g = u[1], m = u[2], l = g, d = m, s.moveTo(g + C, m + T); break; case "C": g = u[5], m = u[6], y = u[3], w = u[4], s.bezierCurveTo(u[1] + C, u[2] + T, y + C, w + T, g + C, m + T); break; case "Q": s.quadraticCurveTo(u[1] + C, u[2] + T, u[3] + C, u[4] + T), g = u[3], m = u[4], y = u[1], w = u[2]; break; case "z": case "Z": g = l, m = d, s.closePath(); break } }, _render: function (s) { this._renderPathCommands(s), this._renderPaintInOrder(s) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (s) { return n(this.callSuper("toObject", s), { path: this.path.map(function (u) { return u.slice() }) }) }, toDatalessObject: function (s) { var u = this.toObject(["sourcePath"].concat(s)); return u.sourcePath && delete u.path, u }, _toSVG: function () {
			var s = r.util.joinPath(this.path); return ["<path ", "COMMON_PARTS", 'd="', s, '" stroke-linecap="round" ', `/>
`]
		}, _getOffsetTransform: function () { var s = r.Object.NUM_FRACTION_DIGITS; return " translate(" + i(-this.pathOffset.x, s) + ", " + i(-this.pathOffset.y, s) + ")" }, toClipPathSVG: function (s) { var u = this._getOffsetTransform(); return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: s, additionalTransform: u }) }, toSVG: function (s) { var u = this._getOffsetTransform(); return this._createBaseSVGMarkup(this._toSVG(), { reviver: s, additionalTransform: u }) }, complexity: function () { return this.path.length }, _calcDimensions: function () { for (var s = [], u = [], l, d = 0, g = 0, m = 0, y = 0, w, C = 0, T = this.path.length; C < T; ++C) { switch (l = this.path[C], l[0]) { case "L": m = l[1], y = l[2], w = []; break; case "M": m = l[1], y = l[2], d = m, g = y, w = []; break; case "C": w = r.util.getBoundsOfCurve(m, y, l[1], l[2], l[3], l[4], l[5], l[6]), m = l[5], y = l[6]; break; case "Q": w = r.util.getBoundsOfCurve(m, y, l[1], l[2], l[1], l[2], l[3], l[4]), m = l[3], y = l[4]; break; case "z": case "Z": m = d, y = g; break }w.forEach(function (N) { s.push(N.x), u.push(N.y) }), s.push(m), u.push(y) } var A = c(s) || 0, U = c(u) || 0, R = h(s) || 0, $ = h(u) || 0, L = R - A, B = $ - U; return { left: A, top: U, width: L, height: B } }
	}), r.Path.fromObject = function (s, u) { if (typeof s.sourcePath == "string") { var l = s.sourcePath; r.loadSVGFromURL(l, function (d) { var g = d[0]; g.setOptions(s), s.clipPath ? r.util.enlivenObjects([s.clipPath], function (m) { g.clipPath = m[0], u && u(g) }) : u && u(g) }) } else r.Object._fromObject("Path", s, u, "path") }, r.Path.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat(["d"]), r.Path.fromElement = function (s, u, l) { var d = r.parseAttributes(s, r.Path.ATTRIBUTE_NAMES); d.fromSVG = !0, u(new r.Path(d.d, n(d, l))) }
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.array.min, h = r.util.array.max; r.Group || (r.Group = r.util.createClass(r.Object, r.Collection, {
		type: "group", strokeWidth: 0, subTargetCheck: !1, cacheProperties: [], useSetOnGroup: !1, initialize: function (n, o, i) { o = o || {}, this._objects = [], i && this.callSuper("initialize", o), this._objects = n || []; for (var s = this._objects.length; s--;)this._objects[s].group = this; if (i) this._updateObjectsACoords(); else { var u = o && o.centerPoint; o.originX !== void 0 && (this.originX = o.originX), o.originY !== void 0 && (this.originY = o.originY), u || this._calcBounds(), this._updateObjectsCoords(u), delete o.centerPoint, this.callSuper("initialize", o) } this.setCoords() }, _updateObjectsACoords: function () { for (var n = !0, o = this._objects.length; o--;)this._objects[o].setCoords(n) }, _updateObjectsCoords: function (o) { for (var o = o || this.getCenterPoint(), i = this._objects.length; i--;)this._updateObjectCoords(this._objects[i], o) }, _updateObjectCoords: function (n, o) { var i = n.left, s = n.top, u = !0; n.set({ left: i - o.x, top: s - o.y }), n.group = this, n.setCoords(u) }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (n) { var o = !!this.group; return this._restoreObjectsState(), r.util.resetObjectTransform(this), n && (o && r.util.removeTransformFromObject(n, this.group.calcTransformMatrix()), this._objects.push(n), n.group = this, n._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, o ? this.group.addWithUpdate() : this.setCoords(), this }, removeWithUpdate: function (n) { return this._restoreObjectsState(), r.util.resetObjectTransform(this), this.remove(n), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _onObjectAdded: function (n) { this.dirty = !0, n.group = this, n._set("canvas", this.canvas) }, _onObjectRemoved: function (n) { this.dirty = !0, delete n.group }, _set: function (n, o) { var i = this._objects.length; if (this.useSetOnGroup) for (; i--;)this._objects[i].setOnGroup(n, o); if (n === "canvas") for (; i--;)this._objects[i]._set(n, o); r.Object.prototype._set.call(this, n, o) }, toObject: function (n) { var o = this.includeDefaultValues, i = this._objects.filter(function (u) { return !u.excludeFromExport }).map(function (u) { var l = u.includeDefaultValues; u.includeDefaultValues = o; var d = u.toObject(n); return u.includeDefaultValues = l, d }), s = r.Object.prototype.toObject.call(this, n); return s.objects = i, s }, toDatalessObject: function (n) { var o, i = this.sourcePath; if (i) o = i; else { var s = this.includeDefaultValues; o = this._objects.map(function (l) { var d = l.includeDefaultValues; l.includeDefaultValues = s; var g = l.toDatalessObject(n); return l.includeDefaultValues = d, g }) } var u = r.Object.prototype.toDatalessObject.call(this, n); return u.objects = o, u }, render: function (n) { this._transformDone = !0, this.callSuper("render", n), this._transformDone = !1 }, shouldCache: function () { var n = r.Object.prototype.shouldCache.call(this); if (n) { for (var o = 0, i = this._objects.length; o < i; o++)if (this._objects[o].willDrawShadow()) return this.ownCaching = !1, !1 } return n }, willDrawShadow: function () { if (r.Object.prototype.willDrawShadow.call(this)) return !0; for (var n = 0, o = this._objects.length; n < o; n++)if (this._objects[n].willDrawShadow()) return !0; return !1 }, isOnACache: function () { return this.ownCaching || this.group && this.group.isOnACache() }, drawObject: function (n) { for (var o = 0, i = this._objects.length; o < i; o++)this._objects[o].render(n); this._drawClipPath(n, this.clipPath) }, isCacheDirty: function (n) { if (this.callSuper("isCacheDirty", n)) return !0; if (!this.statefullCache) return !1; for (var o = 0, i = this._objects.length; o < i; o++)if (this._objects[o].isCacheDirty(!0)) { if (this._cacheCanvas) { var s = this.cacheWidth / this.zoomX, u = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-s / 2, -u / 2, s, u) } return !0 } return !1 }, _restoreObjectsState: function () { var n = this.calcOwnMatrix(); return this._objects.forEach(function (o) { r.util.addTransformToObject(o, n), delete o.group, o.setCoords() }), this }, destroy: function () { return this._objects.forEach(function (n) { n.set("dirty", !0) }), this._restoreObjectsState() }, dispose: function () { this.callSuper("dispose"), this.forEachObject(function (n) { n.dispose && n.dispose() }), this._objects = [] }, toActiveSelection: function () { if (this.canvas) { var n = this._objects, o = this.canvas; this._objects = []; var i = this.toObject(); delete i.objects; var s = new r.ActiveSelection([]); return s.set(i), s.type = "activeSelection", o.remove(this), n.forEach(function (u) { u.group = s, u.dirty = !0, o.add(u) }), s.canvas = o, s._objects = n, o._activeObject = s, s.setCoords(), s } }, ungroupOnCanvas: function () { return this._restoreObjectsState() }, setObjectsCoords: function () { var n = !0; return this.forEachObject(function (o) { o.setCoords(n) }), this }, _calcBounds: function (n) { for (var o = [], i = [], s, u, l, d = ["tr", "br", "bl", "tl"], g = 0, m = this._objects.length, y, w = d.length; g < m; ++g) { for (s = this._objects[g], l = s.calcACoords(), y = 0; y < w; y++)u = d[y], o.push(l[u].x), i.push(l[u].y); s.aCoords = l } this._getBounds(o, i, n) }, _getBounds: function (n, o, i) { var s = new r.Point(c(n), c(o)), u = new r.Point(h(n), h(o)), l = s.y || 0, d = s.x || 0, g = u.x - s.x || 0, m = u.y - s.y || 0; this.width = g, this.height = m, i || this.setPositionByOrigin({ x: d, y: l }, "left", "top") }, _toSVG: function (n) {
			for (var o = ["<g ", "COMMON_PARTS", ` >
`], i = 0, s = this._objects.length; i < s; i++)o.push("		", this._objects[i].toSVG(n)); return o.push(`</g>
`), o
		}, getSvgStyles: function () { var n = typeof this.opacity != "undefined" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", o = this.visible ? "" : " visibility: hidden;"; return [n, this.getSvgFilter(), o].join("") }, toClipPathSVG: function (n) { for (var o = [], i = 0, s = this._objects.length; i < s; i++)o.push("	", this._objects[i].toClipPathSVG(n)); return this._createBaseClipPathSVGMarkup(o, { reviver: n }) }
	}), r.Group.fromObject = function (n, o) { var i = n.objects, s = r.util.object.clone(n, !0); if (delete s.objects, typeof i == "string") { r.loadSVGFromURL(i, function (u) { var l = r.util.groupSVGElements(u, n, i), d = s.clipPath; delete s.clipPath, l.set(s), d ? r.util.enlivenObjects([d], function (g) { l.clipPath = g[0], o && o(l) }) : o && o(l) }); return } r.util.enlivenObjects(i, function (u) { r.util.enlivenObjectEnlivables(n, s, function () { o && o(new r.Group(u, s, !0)) }) }) })
}(e), function (f) { var r = f.fabric || (f.fabric = {}); r.ActiveSelection || (r.ActiveSelection = r.util.createClass(r.Group, { type: "activeSelection", initialize: function (c, h) { h = h || {}, this._objects = c || []; for (var n = this._objects.length; n--;)this._objects[n].group = this; h.originX && (this.originX = h.originX), h.originY && (this.originY = h.originY), this._calcBounds(), this._updateObjectsCoords(), r.Object.prototype.initialize.call(this, h), this.setCoords() }, toGroup: function () { var c = this._objects.concat(); this._objects = []; var h = r.Object.prototype.toObject.call(this), n = new r.Group([]); if (delete h.type, n.set(h), c.forEach(function (i) { i.canvas.remove(i), i.group = n }), n._objects = c, !this.canvas) return n; var o = this.canvas; return o.add(n), o._activeObject = n, n.setCoords(), n }, onDeselect: function () { return this.destroy(), !1 }, toString: function () { return "#<fabric.ActiveSelection: (" + this.complexity() + ")>" }, shouldCache: function () { return !1 }, isOnACache: function () { return !1 }, _renderControls: function (c, h, n) { c.save(), c.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", c, h), n = n || {}, typeof n.hasControls == "undefined" && (n.hasControls = !1), n.forActiveSelection = !0; for (var o = 0, i = this._objects.length; o < i; o++)this._objects[o]._renderControls(c, n); c.restore() } }), r.ActiveSelection.fromObject = function (c, h) { r.util.enlivenObjects(c.objects, function (n) { delete c.objects, h && h(new r.ActiveSelection(n, c, !0)) }) }) }(e), function (f) {
	var r = t.util.object.extend; if (f.fabric || (f.fabric = {}), f.fabric.Image) { t.warn("fabric.Image is already defined."); return } t.Image = t.util.createClass(t.Object, {
		type: "image", strokeWidth: 0, srcFromAttribute: !1, _lastScaleX: 1, _lastScaleY: 1, _filterScalingX: 1, _filterScalingY: 1, minimumScaleTrigger: .5, stateProperties: t.Object.prototype.stateProperties.concat("cropX", "cropY"), cacheProperties: t.Object.prototype.cacheProperties.concat("cropX", "cropY"), cacheKey: "", cropX: 0, cropY: 0, imageSmoothing: !0, initialize: function (c, h) { h || (h = {}), this.filters = [], this.cacheKey = "texture" + t.Object.__uid++, this.callSuper("initialize", h), this._initElement(c, h) }, getElement: function () { return this._element || {} }, setElement: function (c, h) { return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = c, this._originalElement = c, this._initConfig(h), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this }, removeTexture: function (c) { var h = t.filterBackend; h && h.evictCachesForKey && h.evictCachesForKey(c) }, dispose: function () { this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function (c) { t.util.cleanUpJsdomNode(this[c]), this[c] = void 0 }.bind(this)) }, getCrossOrigin: function () { return this._originalElement && (this._originalElement.crossOrigin || null) }, getOriginalSize: function () { var c = this.getElement(); return { width: c.naturalWidth || c.width, height: c.naturalHeight || c.height } }, _stroke: function (c) { if (!(!this.stroke || this.strokeWidth === 0)) { var h = this.width / 2, n = this.height / 2; c.beginPath(), c.moveTo(-h, -n), c.lineTo(h, -n), c.lineTo(h, n), c.lineTo(-h, n), c.lineTo(-h, -n), c.closePath() } }, toObject: function (c) { var h = []; this.filters.forEach(function (o) { o && h.push(o.toObject()) }); var n = r(this.callSuper("toObject", ["cropX", "cropY"].concat(c)), { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: h }); return this.resizeFilter && (n.resizeFilter = this.resizeFilter.toObject()), n }, hasCrop: function () { return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height }, _toSVG: function () {
			var c = [], h = [], n, o = this._element, i = -this.width / 2, s = -this.height / 2, u = "", l = ""; if (!o) return []; if (this.hasCrop()) {
				var d = t.Object.__uid++; c.push('<clipPath id="imageCrop_' + d + `">
`, '	<rect x="' + i + '" y="' + s + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), u = ' clip-path="url(#imageCrop_' + d + ')" '
			} if (this.imageSmoothing || (l = '" image-rendering="optimizeSpeed'), h.push("	<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(!0), '" x="', i - this.cropX, '" y="', s - this.cropY, '" width="', o.width || o.naturalWidth, '" height="', o.height || o.height, l, '"', u, `></image>
`), this.stroke || this.strokeDashArray) {
				var g = this.fill; this.fill = null, n = ["	<rect ", 'x="', i, '" y="', s, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), `"/>
`], this.fill = g
			} return this.paintFirst !== "fill" ? c = c.concat(n, h) : c = c.concat(h, n), c
		}, getSrc: function (c) { var h = c ? this._element : this._originalElement; return h ? h.toDataURL ? h.toDataURL() : this.srcFromAttribute ? h.getAttribute("src") : h.src : this.src || "" }, setSrc: function (c, h, n) { return t.util.loadImage(c, function (o, i) { this.setElement(o, n), this._setWidthHeight(), h && h(this, i) }, this, n && n.crossOrigin), this }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyResizeFilters: function () { var c = this.resizeFilter, h = this.minimumScaleTrigger, n = this.getTotalObjectScaling(), o = n.scaleX, i = n.scaleY, s = this._filteredEl || this._originalElement; if (this.group && this.set("dirty", !0), !c || o > h && i > h) { this._element = s, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = o, this._lastScaleY = i; return } t.filterBackend || (t.filterBackend = t.initFilterBackend()); var u = t.util.createCanvasElement(), l = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, d = s.width, g = s.height; u.width = d, u.height = g, this._element = u, this._lastScaleX = c.scaleX = o, this._lastScaleY = c.scaleY = i, t.filterBackend.applyFilters([c], s, d, g, this._element, l), this._filterScalingX = u.width / this._originalElement.width, this._filterScalingY = u.height / this._originalElement.height }, applyFilters: function (c) { if (c = c || this.filters || [], c = c.filter(function (s) { return s && !s.isNeutralState() }), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), c.length === 0) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this; var h = this._originalElement, n = h.naturalWidth || h.width, o = h.naturalHeight || h.height; if (this._element === this._originalElement) { var i = t.util.createCanvasElement(); i.width = n, i.height = o, this._element = i, this._filteredEl = i } else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, n, o), this._lastScaleX = 1, this._lastScaleY = 1; return t.filterBackend || (t.filterBackend = t.initFilterBackend()), t.filterBackend.applyFilters(c, this._originalElement, n, o, this._element, this.cacheKey), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this }, _render: function (c) { t.util.setImageSmoothing(c, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(c), this._renderPaintInOrder(c) }, drawCacheOnCanvas: function (c) { t.util.setImageSmoothing(c, this.imageSmoothing), t.Object.prototype.drawCacheOnCanvas.call(this, c) }, shouldCache: function () { return this.needsItsOwnCache() }, _renderFill: function (c) { var h = this._element; if (h) { var n = this._filterScalingX, o = this._filterScalingY, i = this.width, s = this.height, u = Math.min, l = Math.max, d = l(this.cropX, 0), g = l(this.cropY, 0), m = h.naturalWidth || h.width, y = h.naturalHeight || h.height, w = d * n, C = g * o, T = u(i * n, m - w), A = u(s * o, y - C), U = -i / 2, R = -s / 2, $ = u(i, m / n - d), L = u(s, y / o - g); h && c.drawImage(h, w, C, T, A, U, R, $, L) } }, _needsResize: function () { var c = this.getTotalObjectScaling(); return c.scaleX !== this._lastScaleX || c.scaleY !== this._lastScaleY }, _resetWidthHeight: function () { this.set(this.getOriginalSize()) }, _initElement: function (c, h) { this.setElement(t.util.getById(c), h), t.util.addClass(this.getElement(), t.Image.CSS_CANVAS) }, _initConfig: function (c) { c || (c = {}), this.setOptions(c), this._setWidthHeight(c) }, _initFilters: function (c, h) { c && c.length ? t.util.enlivenObjects(c, function (n) { h && h(n) }, "fabric.Image.filters") : h && h() }, _setWidthHeight: function (c) { c || (c = {}); var h = this.getElement(); this.width = c.width || h.naturalWidth || h.width || 0, this.height = c.height || h.naturalHeight || h.height || 0 }, parsePreserveAspectRatioAttribute: function () { var c = t.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), h = this._element.width, n = this._element.height, o = 1, i = 1, s = 0, u = 0, l = 0, d = 0, g, m = this.width, y = this.height, w = { width: m, height: y }; return c && (c.alignX !== "none" || c.alignY !== "none") ? (c.meetOrSlice === "meet" && (o = i = t.util.findScaleToFit(this._element, w), g = (m - h * o) / 2, c.alignX === "Min" && (s = -g), c.alignX === "Max" && (s = g), g = (y - n * i) / 2, c.alignY === "Min" && (u = -g), c.alignY === "Max" && (u = g)), c.meetOrSlice === "slice" && (o = i = t.util.findScaleToCover(this._element, w), g = h - m / o, c.alignX === "Mid" && (l = g / 2), c.alignX === "Max" && (l = g), g = n - y / i, c.alignY === "Mid" && (d = g / 2), c.alignY === "Max" && (d = g), h = m / o, n = y / i)) : (o = m / h, i = y / n), { width: h, height: n, scaleX: o, scaleY: i, offsetLeft: s, offsetTop: u, cropX: l, cropY: d } }
	}), t.Image.CSS_CANVAS = "canvas-img", t.Image.prototype.getSvgSrc = t.Image.prototype.getSrc, t.Image.fromObject = function (c, h) { var n = t.util.object.clone(c); t.util.loadImage(n.src, function (o, i) { if (i) { h && h(null, !0); return } t.Image.prototype._initFilters.call(n, n.filters, function (s) { n.filters = s || [], t.Image.prototype._initFilters.call(n, [n.resizeFilter], function (u) { n.resizeFilter = u[0], t.util.enlivenObjectEnlivables(n, n, function () { var l = new t.Image(o, n); h(l, !1) }) }) }) }, null, n.crossOrigin) }, t.Image.fromURL = function (c, h, n) { t.util.loadImage(c, function (o, i) { h && h(new t.Image(o, n), i) }, null, n && n.crossOrigin) }, t.Image.ATTRIBUTE_NAMES = t.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), t.Image.fromElement = function (c, h, n) { var o = t.parseAttributes(c, t.Image.ATTRIBUTE_NAMES); t.Image.fromURL(o["xlink:href"], h, r(n ? t.util.object.clone(n) : {}, o)) }
}(e), t.util.object.extend(t.Object.prototype, { _getAngleValueForStraighten: function () { var f = this.angle % 360; return f > 0 ? Math.round((f - 1) / 90) * 90 : Math.round(f / 90) * 90 }, straighten: function () { return this.rotate(this._getAngleValueForStraighten()) }, fxStraighten: function (f) { f = f || {}; var r = function () { }, c = f.onComplete || r, h = f.onChange || r, n = this; return t.util.animate({ target: this, startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function (o) { n.rotate(o), h() }, onComplete: function () { n.setCoords(), c() } }) } }), t.util.object.extend(t.StaticCanvas.prototype, { straightenObject: function (f) { return f.straighten(), this.requestRenderAll(), this }, fxStraightenObject: function (f) { return f.fxStraighten({ onChange: this.requestRenderAllBound }) } }), function () {
	function f(c, h) {
		var n = "precision " + h + ` float;
void main(){}`, o = c.createShader(c.FRAGMENT_SHADER); return c.shaderSource(o, n), c.compileShader(o), !!c.getShaderParameter(o, c.COMPILE_STATUS)
	} t.isWebglSupported = function (c) { if (t.isLikelyNode) return !1; c = c || t.WebglFilterBackend.prototype.tileSize; var h = document.createElement("canvas"), n = h.getContext("webgl") || h.getContext("experimental-webgl"), o = !1; if (n) { t.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), o = t.maxTextureSize >= c; for (var i = ["highp", "mediump", "lowp"], s = 0; s < 3; s++)if (f(n, i[s])) { t.webGlPrecision = i[s]; break } } return this.isSupported = o, o }, t.WebglFilterBackend = r; function r(c) { c && c.tileSize && (this.tileSize = c.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo() } r.prototype = { tileSize: 2048, resources: {}, setupGLContext: function (c, h) { this.dispose(), this.createWebGLCanvas(c, h), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(c, h) }, chooseFastestCopyGLTo2DMethod: function (c, h) { var n = typeof window.performance != "undefined", o; try { new ImageData(1, 1), o = !0 } catch (w) { o = !1 } var i = typeof ArrayBuffer != "undefined", s = typeof Uint8ClampedArray != "undefined"; if (n && o && i && s) { var u = t.util.createCanvasElement(), l = new ArrayBuffer(c * h * 4); if (t.forceGLPutImageData) { this.imageBuffer = l, this.copyGLTo2D = b; return } var d = { imageBuffer: l, destinationWidth: c, destinationHeight: h, targetCanvas: u }, g, m, y; u.width = c, u.height = h, g = window.performance.now(), _.call(d, this.gl, d), m = window.performance.now() - g, g = window.performance.now(), b.call(d, this.gl, d), y = window.performance.now() - g, m > y ? (this.imageBuffer = l, this.copyGLTo2D = b) : this.copyGLTo2D = _ } }, createWebGLCanvas: function (c, h) { var n = t.util.createCanvasElement(); n.width = c, n.height = h; var o = { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 }, i = n.getContext("webgl", o); i || (i = n.getContext("experimental-webgl", o)), i && (i.clearColor(0, 0, 0, 0), this.canvas = n, this.gl = i) }, applyFilters: function (c, h, n, o, i, s) { var u = this.gl, l; s && (l = this.getCachedTexture(s, h)); var d = { originalWidth: h.width || h.originalWidth, originalHeight: h.height || h.originalHeight, sourceWidth: n, sourceHeight: o, destinationWidth: n, destinationHeight: o, context: u, sourceTexture: this.createTexture(u, n, o, !l && h), targetTexture: this.createTexture(u, n, o), originalTexture: l || this.createTexture(u, n, o, !l && h), passes: c.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: i }, g = u.createFramebuffer(); return u.bindFramebuffer(u.FRAMEBUFFER, g), c.forEach(function (m) { m && m.applyTo(d) }), v(d), this.copyGLTo2D(u, d), u.bindTexture(u.TEXTURE_2D, null), u.deleteTexture(d.sourceTexture), u.deleteTexture(d.targetTexture), u.deleteFramebuffer(g), i.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), d }, dispose: function () { this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches() }, clearWebGLCaches: function () { this.programCache = {}, this.textureCache = {} }, createTexture: function (c, h, n, o, i) { var s = c.createTexture(); return c.bindTexture(c.TEXTURE_2D, s), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, i || c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, i || c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), o ? c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, o) : c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, h, n, 0, c.RGBA, c.UNSIGNED_BYTE, null), s }, getCachedTexture: function (c, h) { if (this.textureCache[c]) return this.textureCache[c]; var n = this.createTexture(this.gl, h.width, h.height, h); return this.textureCache[c] = n, n }, evictCachesForKey: function (c) { this.textureCache[c] && (this.gl.deleteTexture(this.textureCache[c]), delete this.textureCache[c]) }, copyGLTo2D: _, captureGPUInfo: function () { if (this.gpuInfo) return this.gpuInfo; var c = this.gl, h = { renderer: "", vendor: "" }; if (!c) return h; var n = c.getExtension("WEBGL_debug_renderer_info"); if (n) { var o = c.getParameter(n.UNMASKED_RENDERER_WEBGL), i = c.getParameter(n.UNMASKED_VENDOR_WEBGL); o && (h.renderer = o.toLowerCase()), i && (h.vendor = i.toLowerCase()) } return this.gpuInfo = h, h } }
}(); function v(f) { var r = f.targetCanvas, c = r.width, h = r.height, n = f.destinationWidth, o = f.destinationHeight; (c !== n || h !== o) && (r.width = n, r.height = o) } function _(f, r) { var c = f.canvas, h = r.targetCanvas, n = h.getContext("2d"); n.translate(0, h.height), n.scale(1, -1); var o = c.height - h.height; n.drawImage(c, 0, o, h.width, h.height, 0, 0, h.width, h.height) } function b(f, r) { var c = r.targetCanvas, h = c.getContext("2d"), n = r.destinationWidth, o = r.destinationHeight, i = n * o * 4, s = new Uint8Array(this.imageBuffer, 0, i), u = new Uint8ClampedArray(this.imageBuffer, 0, i); f.readPixels(0, 0, n, o, f.RGBA, f.UNSIGNED_BYTE, s); var l = new ImageData(u, n, o); h.putImageData(l, 0, 0) } (function () { var f = function () { }; t.Canvas2dFilterBackend = r; function r() { } r.prototype = { evictCachesForKey: f, dispose: f, clearWebGLCaches: f, resources: {}, applyFilters: function (c, h, n, o, i) { var s = i.getContext("2d"); s.drawImage(h, 0, 0, n, o); var u = s.getImageData(0, 0, n, o), l = s.getImageData(0, 0, n, o), d = { sourceWidth: n, sourceHeight: o, imageData: u, originalEl: h, originalImageData: l, canvasEl: i, ctx: s, filterBackend: this }; return c.forEach(function (g) { g.applyTo(d) }), (d.imageData.width !== n || d.imageData.height !== o) && (i.width = d.imageData.width, i.height = d.imageData.height), s.putImageData(d.imageData, 0, 0), d } } })(), t.Image = t.Image || {}, t.Image.filters = t.Image.filters || {}, t.Image.filters.BaseFilter = t.util.createClass({
	type: "BaseFilter", vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
void main() {
vTexCoord = aPosition;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D uTexture;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
}`, initialize: function (f) { f && this.setOptions(f) }, setOptions: function (f) { for (var r in f) this[r] = f[r] }, createProgram: function (f, r, c) { r = r || this.fragmentSource, c = c || this.vertexSource, t.webGlPrecision !== "highp" && (r = r.replace(/precision highp float/g, "precision " + t.webGlPrecision + " float")); var h = f.createShader(f.VERTEX_SHADER); if (f.shaderSource(h, c), f.compileShader(h), !f.getShaderParameter(h, f.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + f.getShaderInfoLog(h)); var n = f.createShader(f.FRAGMENT_SHADER); if (f.shaderSource(n, r), f.compileShader(n), !f.getShaderParameter(n, f.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + f.getShaderInfoLog(n)); var o = f.createProgram(); if (f.attachShader(o, h), f.attachShader(o, n), f.linkProgram(o), !f.getProgramParameter(o, f.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + f.getProgramInfoLog(o)); var i = this.getAttributeLocations(f, o), s = this.getUniformLocations(f, o) || {}; return s.uStepW = f.getUniformLocation(o, "uStepW"), s.uStepH = f.getUniformLocation(o, "uStepH"), { program: o, attributeLocations: i, uniformLocations: s } }, getAttributeLocations: function (f, r) { return { aPosition: f.getAttribLocation(r, "aPosition") } }, getUniformLocations: function () { return {} }, sendAttributeData: function (f, r, c) { var h = r.aPosition, n = f.createBuffer(); f.bindBuffer(f.ARRAY_BUFFER, n), f.enableVertexAttribArray(h), f.vertexAttribPointer(h, 2, f.FLOAT, !1, 0, 0), f.bufferData(f.ARRAY_BUFFER, c, f.STATIC_DRAW) }, _setupFrameBuffer: function (f) { var r = f.context, c, h; f.passes > 1 ? (c = f.destinationWidth, h = f.destinationHeight, (f.sourceWidth !== c || f.sourceHeight !== h) && (r.deleteTexture(f.targetTexture), f.targetTexture = f.filterBackend.createTexture(r, c, h)), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, f.targetTexture, 0)) : (r.bindFramebuffer(r.FRAMEBUFFER, null), r.finish()) }, _swapTextures: function (f) { f.passes--, f.pass++; var r = f.targetTexture; f.targetTexture = f.sourceTexture, f.sourceTexture = r }, isNeutralState: function () { var f = this.mainParameter, r = t.Image.filters[this.type].prototype; if (f) if (Array.isArray(r[f])) { for (var c = r[f].length; c--;)if (this[f][c] !== r[f][c]) return !1; return !0 } else return r[f] === this[f]; else return !1 }, applyTo: function (f) { f.webgl ? (this._setupFrameBuffer(f), this.applyToWebGL(f), this._swapTextures(f)) : this.applyTo2d(f) }, retrieveShader: function (f) { return f.programCache.hasOwnProperty(this.type) || (f.programCache[this.type] = this.createProgram(f.context)), f.programCache[this.type] }, applyToWebGL: function (f) { var r = f.context, c = this.retrieveShader(f); f.pass === 0 && f.originalTexture ? r.bindTexture(r.TEXTURE_2D, f.originalTexture) : r.bindTexture(r.TEXTURE_2D, f.sourceTexture), r.useProgram(c.program), this.sendAttributeData(r, c.attributeLocations, f.aPosition), r.uniform1f(c.uniformLocations.uStepW, 1 / f.sourceWidth), r.uniform1f(c.uniformLocations.uStepH, 1 / f.sourceHeight), this.sendUniformData(r, c.uniformLocations), r.viewport(0, 0, f.destinationWidth, f.destinationHeight), r.drawArrays(r.TRIANGLE_STRIP, 0, 4) }, bindAdditionalTexture: function (f, r, c) { f.activeTexture(c), f.bindTexture(f.TEXTURE_2D, r), f.activeTexture(f.TEXTURE0) }, unbindAdditionalTexture: function (f, r) { f.activeTexture(r), f.bindTexture(f.TEXTURE_2D, null), f.activeTexture(f.TEXTURE0) }, getMainParameter: function () { return this[this.mainParameter] }, setMainParameter: function (f) { this[this.mainParameter] = f }, sendUniformData: function () { }, createHelpLayer: function (f) { if (!f.helpLayer) { var r = document.createElement("canvas"); r.width = f.sourceWidth, r.height = f.sourceHeight, f.helpLayer = r } }, toObject: function () { var f = { type: this.type }, r = this.mainParameter; return r && (f[r] = this[r]), f }, toJSON: function () { return this.toObject() }
}), t.Image.filters.BaseFilter.fromObject = function (f, r) { var c = new t.Image.filters[f.type](f); return r && r(c), c }, function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.ColorMatrix = h(c.BaseFilter, {
		type: "ColorMatrix", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
uniform mat4 uColorMatrix;
uniform vec4 uConstants;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color *= uColorMatrix;
color += uConstants;
gl_FragColor = color;
}`, matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: !0, initialize: function (n) { this.callSuper("initialize", n), this.matrix = this.matrix.slice(0) }, applyTo2d: function (n) { var o = n.imageData, i = o.data, s = i.length, u = this.matrix, l, d, g, m, y, w = this.colorsOnly; for (y = 0; y < s; y += 4)l = i[y], d = i[y + 1], g = i[y + 2], w ? (i[y] = l * u[0] + d * u[1] + g * u[2] + u[4] * 255, i[y + 1] = l * u[5] + d * u[6] + g * u[7] + u[9] * 255, i[y + 2] = l * u[10] + d * u[11] + g * u[12] + u[14] * 255) : (m = i[y + 3], i[y] = l * u[0] + d * u[1] + g * u[2] + m * u[3] + u[4] * 255, i[y + 1] = l * u[5] + d * u[6] + g * u[7] + m * u[8] + u[9] * 255, i[y + 2] = l * u[10] + d * u[11] + g * u[12] + m * u[13] + u[14] * 255, i[y + 3] = l * u[15] + d * u[16] + g * u[17] + m * u[18] + u[19] * 255) }, getUniformLocations: function (n, o) { return { uColorMatrix: n.getUniformLocation(o, "uColorMatrix"), uConstants: n.getUniformLocation(o, "uConstants") } }, sendUniformData: function (n, o) { var i = this.matrix, s = [i[0], i[1], i[2], i[3], i[5], i[6], i[7], i[8], i[10], i[11], i[12], i[13], i[15], i[16], i[17], i[18]], u = [i[4], i[9], i[14], i[19]]; n.uniformMatrix4fv(o.uColorMatrix, !1, s), n.uniform4fv(o.uConstants, u) }
	}), r.Image.filters.ColorMatrix.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Brightness = h(c.BaseFilter, {
		type: "Brightness", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBrightness;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += uBrightness;
gl_FragColor = color;
}`, brightness: 0, mainParameter: "brightness", applyTo2d: function (n) { if (this.brightness !== 0) { var o = n.imageData, i = o.data, s, u = i.length, l = Math.round(this.brightness * 255); for (s = 0; s < u; s += 4)i[s] = i[s] + l, i[s + 1] = i[s + 1] + l, i[s + 2] = i[s + 2] + l } }, getUniformLocations: function (n, o) { return { uBrightness: n.getUniformLocation(o, "uBrightness") } }, sendUniformData: function (n, o) { n.uniform1f(o.uBrightness, this.brightness) }
	}), r.Image.filters.Brightness.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.Image.filters, n = r.util.createClass; h.Convolute = n(h.BaseFilter, {
		type: "Convolute", opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0], fragmentSource: {
			Convolute_3_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_3_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_5_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_5_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_7_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_7_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_9_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_9_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`}, retrieveShader: function (o) { var i = Math.sqrt(this.matrix.length), s = this.type + "_" + i + "_" + (this.opaque ? 1 : 0), u = this.fragmentSource[s]; return o.programCache.hasOwnProperty(s) || (o.programCache[s] = this.createProgram(o.context, u)), o.programCache[s] }, applyTo2d: function (o) { var i = o.imageData, s = i.data, u = this.matrix, l = Math.round(Math.sqrt(u.length)), d = Math.floor(l / 2), g = i.width, m = i.height, y = o.ctx.createImageData(g, m), w = y.data, C = this.opaque ? 1 : 0, T, A, U, R, $, L, B, N, K, st, ft, ht, k; for (ft = 0; ft < m; ft++)for (st = 0; st < g; st++) { for ($ = (ft * g + st) * 4, T = 0, A = 0, U = 0, R = 0, k = 0; k < l; k++)for (ht = 0; ht < l; ht++)B = ft + k - d, L = st + ht - d, !(B < 0 || B >= m || L < 0 || L >= g) && (N = (B * g + L) * 4, K = u[k * l + ht], T += s[N] * K, A += s[N + 1] * K, U += s[N + 2] * K, C || (R += s[N + 3] * K)); w[$] = T, w[$ + 1] = A, w[$ + 2] = U, C ? w[$ + 3] = s[$ + 3] : w[$ + 3] = R } o.imageData = y }, getUniformLocations: function (o, i) { return { uMatrix: o.getUniformLocation(i, "uMatrix"), uOpaque: o.getUniformLocation(i, "uOpaque"), uHalfSize: o.getUniformLocation(i, "uHalfSize"), uSize: o.getUniformLocation(i, "uSize") } }, sendUniformData: function (o, i) { o.uniform1fv(i.uMatrix, this.matrix) }, toObject: function () { return c(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix }) }
	}), r.Image.filters.Convolute.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Grayscale = h(c.BaseFilter, {
		type: "Grayscale", fragmentSource: {
			average: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float average = (color.r + color.b + color.g) / 3.0;
gl_FragColor = vec4(average, average, average, color.a);
}`, lightness: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
gl_FragColor = vec4(average, average, average, col.a);
}`, luminosity: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
gl_FragColor = vec4(average, average, average, col.a);
}`}, mode: "average", mainParameter: "mode", applyTo2d: function (n) { var o = n.imageData, i = o.data, s, u = i.length, l, d = this.mode; for (s = 0; s < u; s += 4)d === "average" ? l = (i[s] + i[s + 1] + i[s + 2]) / 3 : d === "lightness" ? l = (Math.min(i[s], i[s + 1], i[s + 2]) + Math.max(i[s], i[s + 1], i[s + 2])) / 2 : d === "luminosity" && (l = .21 * i[s] + .72 * i[s + 1] + .07 * i[s + 2]), i[s] = l, i[s + 1] = l, i[s + 2] = l }, retrieveShader: function (n) { var o = this.type + "_" + this.mode; if (!n.programCache.hasOwnProperty(o)) { var i = this.fragmentSource[this.mode]; n.programCache[o] = this.createProgram(n.context, i) } return n.programCache[o] }, getUniformLocations: function (n, o) { return { uMode: n.getUniformLocation(o, "uMode") } }, sendUniformData: function (n, o) { var i = 1; n.uniform1i(o.uMode, i) }, isNeutralState: function () { return !1 }
	}), r.Image.filters.Grayscale.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Invert = h(c.BaseFilter, {
		type: "Invert", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform int uInvert;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
if (uInvert == 1) {
gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
} else {
gl_FragColor = color;
}
}`, invert: !0, mainParameter: "invert", applyTo2d: function (n) { var o = n.imageData, i = o.data, s, u = i.length; for (s = 0; s < u; s += 4)i[s] = 255 - i[s], i[s + 1] = 255 - i[s + 1], i[s + 2] = 255 - i[s + 2] }, isNeutralState: function () { return !this.invert }, getUniformLocations: function (n, o) { return { uInvert: n.getUniformLocation(o, "uInvert") } }, sendUniformData: function (n, o) { n.uniform1i(o.uInvert, this.invert) }
	}), r.Image.filters.Invert.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.Image.filters, n = r.util.createClass; h.Noise = n(h.BaseFilter, {
		type: "Noise", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uStepH;
uniform float uNoise;
uniform float uSeed;
varying vec2 vTexCoord;
float rand(vec2 co, float seed, float vScale) {
return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
}
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
gl_FragColor = color;
}`, mainParameter: "noise", noise: 0, applyTo2d: function (o) { if (this.noise !== 0) { var i = o.imageData, s = i.data, u, l = s.length, d = this.noise, g; for (u = 0, l = s.length; u < l; u += 4)g = (.5 - Math.random()) * d, s[u] += g, s[u + 1] += g, s[u + 2] += g } }, getUniformLocations: function (o, i) { return { uNoise: o.getUniformLocation(i, "uNoise"), uSeed: o.getUniformLocation(i, "uSeed") } }, sendUniformData: function (o, i) { o.uniform1f(i.uNoise, this.noise / 255), o.uniform1f(i.uSeed, Math.random()) }, toObject: function () { return c(this.callSuper("toObject"), { noise: this.noise }) }
	}), r.Image.filters.Noise.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Pixelate = h(c.BaseFilter, {
		type: "Pixelate", blocksize: 4, mainParameter: "blocksize", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBlocksize;
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
float blockW = uBlocksize * uStepW;
float blockH = uBlocksize * uStepW;
int posX = int(vTexCoord.x / blockW);
int posY = int(vTexCoord.y / blockH);
float fposX = float(posX);
float fposY = float(posY);
vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
vec4 color = texture2D(uTexture, squareCoords);
gl_FragColor = color;
}`, applyTo2d: function (n) { var o = n.imageData, i = o.data, s = o.height, u = o.width, l, d, g, m, y, w, C, T, A, U, R; for (d = 0; d < s; d += this.blocksize)for (g = 0; g < u; g += this.blocksize)for (l = d * 4 * u + g * 4, m = i[l], y = i[l + 1], w = i[l + 2], C = i[l + 3], U = Math.min(d + this.blocksize, s), R = Math.min(g + this.blocksize, u), T = d; T < U; T++)for (A = g; A < R; A++)l = T * 4 * u + A * 4, i[l] = m, i[l + 1] = y, i[l + 2] = w, i[l + 3] = C }, isNeutralState: function () { return this.blocksize === 1 }, getUniformLocations: function (n, o) { return { uBlocksize: n.getUniformLocation(o, "uBlocksize"), uStepW: n.getUniformLocation(o, "uStepW"), uStepH: n.getUniformLocation(o, "uStepH") } }, sendUniformData: function (n, o) { n.uniform1f(o.uBlocksize, this.blocksize) }
	}), r.Image.filters.Pixelate.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.extend, h = r.Image.filters, n = r.util.createClass; h.RemoveColor = n(h.BaseFilter, {
		type: "RemoveColor", color: "#FFFFFF", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
gl_FragColor.a = 0.0;
}
}`, distance: .02, useAlpha: !1, applyTo2d: function (o) { var i = o.imageData, s = i.data, u, l = this.distance * 255, d, g, m, y = new r.Color(this.color).getSource(), w = [y[0] - l, y[1] - l, y[2] - l], C = [y[0] + l, y[1] + l, y[2] + l]; for (u = 0; u < s.length; u += 4)d = s[u], g = s[u + 1], m = s[u + 2], d > w[0] && g > w[1] && m > w[2] && d < C[0] && g < C[1] && m < C[2] && (s[u + 3] = 0) }, getUniformLocations: function (o, i) { return { uLow: o.getUniformLocation(i, "uLow"), uHigh: o.getUniformLocation(i, "uHigh") } }, sendUniformData: function (o, i) { var s = new r.Color(this.color).getSource(), u = parseFloat(this.distance), l = [0 + s[0] / 255 - u, 0 + s[1] / 255 - u, 0 + s[2] / 255 - u, 1], d = [s[0] / 255 + u, s[1] / 255 + u, s[2] / 255 + u, 1]; o.uniform4fv(i.uLow, l), o.uniform4fv(i.uHigh, d) }, toObject: function () { return c(this.callSuper("toObject"), { color: this.color, distance: this.distance }) }
	}), r.Image.filters.RemoveColor.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) { var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass, n = { Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0], Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0], Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0], Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0], Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0], BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0] }; for (var o in n) c[o] = h(c.ColorMatrix, { type: o, matrix: n[o], mainParameter: !1, colorsOnly: !0 }), r.Image.filters[o].fromObject = r.Image.filters.BaseFilter.fromObject }(e), function (f) {
	var r = f.fabric, c = r.Image.filters, h = r.util.createClass; c.BlendColor = h(c.BaseFilter, {
		type: "BlendColor", color: "#F95C63", mode: "multiply", alpha: 1, fragmentSource: {
			multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, diff: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `if (uColor.r < 0.5) {
gl_FragColor.r *= 2.0 * uColor.r;
} else {
gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
}
if (uColor.g < 0.5) {
gl_FragColor.g *= 2.0 * uColor.g;
} else {
gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
}
if (uColor.b < 0.5) {
gl_FragColor.b *= 2.0 * uColor.b;
} else {
gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
}
`, tint: `gl_FragColor.rgb *= (1.0 - uColor.a);
gl_FragColor.rgb += uColor.rgb;
`}, buildSource: function (n) {
			return `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uColor;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
gl_FragColor = color;
if (color.a > 0.0) {
`+ this.fragmentSource[n] + `}
}`}, retrieveShader: function (n) { var o = this.type + "_" + this.mode, i; return n.programCache.hasOwnProperty(o) || (i = this.buildSource(this.mode), n.programCache[o] = this.createProgram(n.context, i)), n.programCache[o] }, applyTo2d: function (n) { var o = n.imageData, i = o.data, s = i.length, u, l, d, g, m, y, w, C = 1 - this.alpha; w = new r.Color(this.color).getSource(), u = w[0] * this.alpha, l = w[1] * this.alpha, d = w[2] * this.alpha; for (var T = 0; T < s; T += 4)switch (g = i[T], m = i[T + 1], y = i[T + 2], this.mode) { case "multiply": i[T] = g * u / 255, i[T + 1] = m * l / 255, i[T + 2] = y * d / 255; break; case "screen": i[T] = 255 - (255 - g) * (255 - u) / 255, i[T + 1] = 255 - (255 - m) * (255 - l) / 255, i[T + 2] = 255 - (255 - y) * (255 - d) / 255; break; case "add": i[T] = g + u, i[T + 1] = m + l, i[T + 2] = y + d; break; case "diff": case "difference": i[T] = Math.abs(g - u), i[T + 1] = Math.abs(m - l), i[T + 2] = Math.abs(y - d); break; case "subtract": i[T] = g - u, i[T + 1] = m - l, i[T + 2] = y - d; break; case "darken": i[T] = Math.min(g, u), i[T + 1] = Math.min(m, l), i[T + 2] = Math.min(y, d); break; case "lighten": i[T] = Math.max(g, u), i[T + 1] = Math.max(m, l), i[T + 2] = Math.max(y, d); break; case "overlay": i[T] = u < 128 ? 2 * g * u / 255 : 255 - 2 * (255 - g) * (255 - u) / 255, i[T + 1] = l < 128 ? 2 * m * l / 255 : 255 - 2 * (255 - m) * (255 - l) / 255, i[T + 2] = d < 128 ? 2 * y * d / 255 : 255 - 2 * (255 - y) * (255 - d) / 255; break; case "exclusion": i[T] = u + g - 2 * u * g / 255, i[T + 1] = l + m - 2 * l * m / 255, i[T + 2] = d + y - 2 * d * y / 255; break; case "tint": i[T] = u + g * C, i[T + 1] = l + m * C, i[T + 2] = d + y * C } }, getUniformLocations: function (n, o) { return { uColor: n.getUniformLocation(o, "uColor") } }, sendUniformData: function (n, o) { var i = new r.Color(this.color).getSource(); i[0] = this.alpha * i[0] / 255, i[1] = this.alpha * i[1] / 255, i[2] = this.alpha * i[2] / 255, i[3] = this.alpha, n.uniform4fv(o.uColor, i) }, toObject: function () { return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha } }
	}), r.Image.filters.BlendColor.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric, c = r.Image.filters, h = r.util.createClass; c.BlendImage = h(c.BaseFilter, {
		type: "BlendImage", image: null, mode: "multiply", alpha: 1, vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
uniform mat3 uTransformMatrix;
void main() {
vTexCoord = aPosition;
vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: {
			multiply: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.rgba *= color2.rgba;
gl_FragColor = color;
}`, mask: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.a = color2.a;
gl_FragColor = color;
}`}, retrieveShader: function (n) { var o = this.type + "_" + this.mode, i = this.fragmentSource[this.mode]; return n.programCache.hasOwnProperty(o) || (n.programCache[o] = this.createProgram(n.context, i)), n.programCache[o] }, applyToWebGL: function (n) { var o = n.context, i = this.createTexture(n.filterBackend, this.image); this.bindAdditionalTexture(o, i, o.TEXTURE1), this.callSuper("applyToWebGL", n), this.unbindAdditionalTexture(o, o.TEXTURE1) }, createTexture: function (n, o) { return n.getCachedTexture(o.cacheKey, o._element) }, calculateMatrix: function () { var n = this.image, o = n._element.width, i = n._element.height; return [1 / n.scaleX, 0, 0, 0, 1 / n.scaleY, 0, -n.left / o, -n.top / i, 1] }, applyTo2d: function (n) { var o = n.imageData, i = n.filterBackend.resources, s = o.data, u = s.length, l = o.width, d = o.height, g, m, y, w, C, T, A, U, R, $, L = this.image, B; i.blendImage || (i.blendImage = r.util.createCanvasElement()), R = i.blendImage, $ = R.getContext("2d"), R.width !== l || R.height !== d ? (R.width = l, R.height = d) : $.clearRect(0, 0, l, d), $.setTransform(L.scaleX, 0, 0, L.scaleY, L.left, L.top), $.drawImage(L._element, 0, 0, l, d), B = $.getImageData(0, 0, l, d).data; for (var N = 0; N < u; N += 4)switch (C = s[N], T = s[N + 1], A = s[N + 2], U = s[N + 3], g = B[N], m = B[N + 1], y = B[N + 2], w = B[N + 3], this.mode) { case "multiply": s[N] = C * g / 255, s[N + 1] = T * m / 255, s[N + 2] = A * y / 255, s[N + 3] = U * w / 255; break; case "mask": s[N + 3] = w; break } }, getUniformLocations: function (n, o) { return { uTransformMatrix: n.getUniformLocation(o, "uTransformMatrix"), uImage: n.getUniformLocation(o, "uImage") } }, sendUniformData: function (n, o) { var i = this.calculateMatrix(); n.uniform1i(o.uImage, 1), n.uniformMatrix3fv(o.uTransformMatrix, !1, i) }, toObject: function () { return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha } }
	}), r.Image.filters.BlendImage.fromObject = function (n, o) { r.Image.fromObject(n.image, function (i) { var s = r.util.object.clone(n); s.image = i, o(new r.Image.filters.BlendImage(s)) }) }
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = Math.pow, h = Math.floor, n = Math.sqrt, o = Math.abs, i = Math.round, s = Math.sin, u = Math.ceil, l = r.Image.filters, d = r.util.createClass; l.Resize = d(l.BaseFilter, {
		type: "Resize", resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, getUniformLocations: function (g, m) { return { uDelta: g.getUniformLocation(m, "uDelta"), uTaps: g.getUniformLocation(m, "uTaps") } }, sendUniformData: function (g, m) { g.uniform2fv(m.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), g.uniform1fv(m.uTaps, this.taps) }, retrieveShader: function (g) { var m = this.getFilterWindow(), y = this.type + "_" + m; if (!g.programCache.hasOwnProperty(y)) { var w = this.generateShader(m); g.programCache[y] = this.createProgram(g.context, w) } return g.programCache[y] }, getFilterWindow: function () { var g = this.tempScale; return Math.ceil(this.lanczosLobes / g) }, getTaps: function () { for (var g = this.lanczosCreate(this.lanczosLobes), m = this.tempScale, y = this.getFilterWindow(), w = new Array(y), C = 1; C <= y; C++)w[C - 1] = g(C * m); return w }, generateShader: function (w) {
			for (var m = new Array(w), y = this.fragmentSourceTOP, w, C = 1; C <= w; C++)m[C - 1] = C + ".0 * uDelta"; return y += "uniform float uTaps[" + w + `];
`, y += `void main() {
`, y += `  vec4 color = texture2D(uTexture, vTexCoord);
`, y += `  float sum = 1.0;
`, m.forEach(function (T, A) {
				y += "  color += texture2D(uTexture, vTexCoord + " + T + ") * uTaps[" + A + `];
`, y += "  color += texture2D(uTexture, vTexCoord - " + T + ") * uTaps[" + A + `];
`, y += "  sum += 2.0 * uTaps[" + A + `];
`}), y += `  gl_FragColor = color / sum;
`, y += "}", y
		}, fragmentSourceTOP: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
`, applyTo: function (g) { g.webgl ? (g.passes++, this.width = g.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = g.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), g.destinationWidth = this.dW, this._setupFrameBuffer(g), this.applyToWebGL(g), this._swapTextures(g), g.sourceWidth = g.destinationWidth, this.height = g.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), g.destinationHeight = this.dH, this._setupFrameBuffer(g), this.applyToWebGL(g), this._swapTextures(g), g.sourceHeight = g.destinationHeight) : this.applyTo2d(g) }, isNeutralState: function () { return this.scaleX === 1 && this.scaleY === 1 }, lanczosCreate: function (g) { return function (m) { if (m >= g || m <= -g) return 0; if (m < 11920929e-14 && m > -11920929e-14) return 1; m *= Math.PI; var y = m / g; return s(m) / m * s(y) / y } }, applyTo2d: function (g) { var m = g.imageData, y = this.scaleX, w = this.scaleY; this.rcpScaleX = 1 / y, this.rcpScaleY = 1 / w; var C = m.width, T = m.height, A = i(C * y), U = i(T * w), R; this.resizeType === "sliceHack" ? R = this.sliceByTwo(g, C, T, A, U) : this.resizeType === "hermite" ? R = this.hermiteFastResize(g, C, T, A, U) : this.resizeType === "bilinear" ? R = this.bilinearFiltering(g, C, T, A, U) : this.resizeType === "lanczos" && (R = this.lanczosResize(g, C, T, A, U)), g.imageData = R }, sliceByTwo: function (g, m, y, w, C) { var T = g.imageData, A = .5, U = !1, R = !1, $ = m * A, L = y * A, B = r.filterBackend.resources, N, K, st = 0, ft = 0, ht = m, k = 0; for (B.sliceByTwo || (B.sliceByTwo = document.createElement("canvas")), N = B.sliceByTwo, (N.width < m * 1.5 || N.height < y) && (N.width = m * 1.5, N.height = y), K = N.getContext("2d"), K.clearRect(0, 0, m * 1.5, y), K.putImageData(T, 0, 0), w = h(w), C = h(C); !U || !R;)m = $, y = L, w < h($ * A) ? $ = h($ * A) : ($ = w, U = !0), C < h(L * A) ? L = h(L * A) : (L = C, R = !0), K.drawImage(N, st, ft, m, y, ht, k, $, L), st = ht, ft = k, k += L; return K.getImageData(st, ft, w, C) }, lanczosResize: function (g, m, y, w, C) { function T(E) { var P, W, O, x, F, z, q, X, ot, ct, gt; for (k.x = (E + .5) * L, M.x = h(k.x), P = 0; P < C; P++) { for (k.y = (P + .5) * B, M.y = h(k.y), F = 0, z = 0, q = 0, X = 0, ot = 0, W = M.x - st; W <= M.x + st; W++)if (!(W < 0 || W >= m)) { ct = h(1e3 * o(W - k.x)), ht[ct] || (ht[ct] = {}); for (var J = M.y - ft; J <= M.y + ft; J++)J < 0 || J >= y || (gt = h(1e3 * o(J - k.y)), ht[ct][gt] || (ht[ct][gt] = $(n(c(ct * N, 2) + c(gt * K, 2)) / 1e3)), O = ht[ct][gt], O > 0 && (x = (J * m + W) * 4, F += O, z += O * A[x], q += O * A[x + 1], X += O * A[x + 2], ot += O * A[x + 3])) } x = (P * w + E) * 4, R[x] = z / F, R[x + 1] = q / F, R[x + 2] = X / F, R[x + 3] = ot / F } return ++E < w ? T(E) : U } var A = g.imageData.data, U = g.ctx.createImageData(w, C), R = U.data, $ = this.lanczosCreate(this.lanczosLobes), L = this.rcpScaleX, B = this.rcpScaleY, N = 2 / this.rcpScaleX, K = 2 / this.rcpScaleY, st = u(L * this.lanczosLobes / 2), ft = u(B * this.lanczosLobes / 2), ht = {}, k = {}, M = {}; return T(0) }, bilinearFiltering: function (g, m, y, w, C) { var T, A, U, R, $, L, B, N, K, st, ft, ht, k = 0, M, E = this.rcpScaleX, P = this.rcpScaleY, W = 4 * (m - 1), O = g.imageData, x = O.data, F = g.ctx.createImageData(w, C), z = F.data; for (B = 0; B < C; B++)for (N = 0; N < w; N++)for ($ = h(E * N), L = h(P * B), K = E * N - $, st = P * B - L, M = 4 * (L * m + $), ft = 0; ft < 4; ft++)T = x[M + ft], A = x[M + 4 + ft], U = x[M + W + ft], R = x[M + W + 4 + ft], ht = T * (1 - K) * (1 - st) + A * K * (1 - st) + U * st * (1 - K) + R * K * st, z[k++] = ht; return F }, hermiteFastResize: function (g, m, y, w, C) { for (var T = this.rcpScaleX, A = this.rcpScaleY, U = u(T / 2), R = u(A / 2), $ = g.imageData, L = $.data, B = g.ctx.createImageData(w, C), N = B.data, K = 0; K < C; K++)for (var st = 0; st < w; st++) { for (var ft = (st + K * w) * 4, ht = 0, k = 0, M = 0, E = 0, P = 0, W = 0, O = 0, x = (K + .5) * A, F = h(K * A); F < (K + 1) * A; F++)for (var z = o(x - (F + .5)) / R, q = (st + .5) * T, X = z * z, ot = h(st * T); ot < (st + 1) * T; ot++) { var ct = o(q - (ot + .5)) / U, gt = n(X + ct * ct); gt > 1 && gt < -1 || (ht = 2 * gt * gt * gt - 3 * gt * gt + 1, ht > 0 && (ct = 4 * (ot + F * m), O += ht * L[ct + 3], M += ht, L[ct + 3] < 255 && (ht = ht * L[ct + 3] / 250), E += ht * L[ct], P += ht * L[ct + 1], W += ht * L[ct + 2], k += ht)) } N[ft] = E / k, N[ft + 1] = P / k, N[ft + 2] = W / k, N[ft + 3] = O / M } return B }, toObject: function () { return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes } }
	}), r.Image.filters.Resize.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Contrast = h(c.BaseFilter, {
		type: "Contrast", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uContrast;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
gl_FragColor = color;
}`, contrast: 0, mainParameter: "contrast", applyTo2d: function (n) { if (this.contrast !== 0) { var o = n.imageData, i, u, s = o.data, u = s.length, l = Math.floor(this.contrast * 255), d = 259 * (l + 255) / (255 * (259 - l)); for (i = 0; i < u; i += 4)s[i] = d * (s[i] - 128) + 128, s[i + 1] = d * (s[i + 1] - 128) + 128, s[i + 2] = d * (s[i + 2] - 128) + 128 } }, getUniformLocations: function (n, o) { return { uContrast: n.getUniformLocation(o, "uContrast") } }, sendUniformData: function (n, o) { n.uniform1f(o.uContrast, this.contrast) }
	}), r.Image.filters.Contrast.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Saturation = h(c.BaseFilter, {
		type: "Saturation", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uSaturation;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float rgMax = max(color.r, color.g);
float rgbMax = max(rgMax, color.b);
color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
gl_FragColor = color;
}`, saturation: 0, mainParameter: "saturation", applyTo2d: function (n) { if (this.saturation !== 0) { var o = n.imageData, i = o.data, s = i.length, u = -this.saturation, l, d; for (l = 0; l < s; l += 4)d = Math.max(i[l], i[l + 1], i[l + 2]), i[l] += d !== i[l] ? (d - i[l]) * u : 0, i[l + 1] += d !== i[l + 1] ? (d - i[l + 1]) * u : 0, i[l + 2] += d !== i[l + 2] ? (d - i[l + 2]) * u : 0 } }, getUniformLocations: function (n, o) { return { uSaturation: n.getUniformLocation(o, "uSaturation") } }, sendUniformData: function (n, o) { n.uniform1f(o.uSaturation, -this.saturation) }
	}), r.Image.filters.Saturation.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Vibrance = h(c.BaseFilter, {
		type: "Vibrance", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uVibrance;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float max = max(color.r, max(color.g, color.b));
float avg = (color.r + color.g + color.b) / 3.0;
float amt = (abs(max - avg) * 2.0) * uVibrance;
color.r += max != color.r ? (max - color.r) * amt : 0.00;
color.g += max != color.g ? (max - color.g) * amt : 0.00;
color.b += max != color.b ? (max - color.b) * amt : 0.00;
gl_FragColor = color;
}`, vibrance: 0, mainParameter: "vibrance", applyTo2d: function (n) { if (this.vibrance !== 0) { var o = n.imageData, i = o.data, s = i.length, u = -this.vibrance, l, d, g, m; for (l = 0; l < s; l += 4)d = Math.max(i[l], i[l + 1], i[l + 2]), g = (i[l] + i[l + 1] + i[l + 2]) / 3, m = Math.abs(d - g) * 2 / 255 * u, i[l] += d !== i[l] ? (d - i[l]) * m : 0, i[l + 1] += d !== i[l + 1] ? (d - i[l + 1]) * m : 0, i[l + 2] += d !== i[l + 2] ? (d - i[l + 2]) * m : 0 } }, getUniformLocations: function (n, o) { return { uVibrance: n.getUniformLocation(o, "uVibrance") } }, sendUniformData: function (n, o) { n.uniform1f(o.uVibrance, -this.vibrance) }
	}), r.Image.filters.Vibrance.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Blur = h(c.BaseFilter, {
		type: "Blur", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
const float nSamples = 15.0;
vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
float random(vec3 scale) {
return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
}
void main() {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(v3offset);
for (float t = -nSamples; t <= nSamples; t++) {
float percent = (t + offset - 0.5) / nSamples;
float weight = 1.0 - abs(percent);
color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
total += weight;
}
gl_FragColor = color / total;
}`, blur: 0, mainParameter: "blur", applyTo: function (n) { n.webgl ? (this.aspectRatio = n.sourceWidth / n.sourceHeight, n.passes++, this._setupFrameBuffer(n), this.horizontal = !0, this.applyToWebGL(n), this._swapTextures(n), this._setupFrameBuffer(n), this.horizontal = !1, this.applyToWebGL(n), this._swapTextures(n)) : this.applyTo2d(n) }, applyTo2d: function (n) { n.imageData = this.simpleBlur(n) }, simpleBlur: function (n) { var o = n.filterBackend.resources, i, s, u = n.imageData.width, l = n.imageData.height; o.blurLayer1 || (o.blurLayer1 = r.util.createCanvasElement(), o.blurLayer2 = r.util.createCanvasElement()), i = o.blurLayer1, s = o.blurLayer2, (i.width !== u || i.height !== l) && (s.width = i.width = u, s.height = i.height = l); var d = i.getContext("2d"), g = s.getContext("2d"), m = 15, y, w, C, T, A = this.blur * .06 * .5; for (d.putImageData(n.imageData, 0, 0), g.clearRect(0, 0, u, l), T = -m; T <= m; T++)y = (Math.random() - .5) / 4, w = T / m, C = A * w * u + y, g.globalAlpha = 1 - Math.abs(w), g.drawImage(i, C, y), d.drawImage(s, 0, 0), g.globalAlpha = 1, g.clearRect(0, 0, s.width, s.height); for (T = -m; T <= m; T++)y = (Math.random() - .5) / 4, w = T / m, C = A * w * l + y, g.globalAlpha = 1 - Math.abs(w), g.drawImage(i, y, C), d.drawImage(s, 0, 0), g.globalAlpha = 1, g.clearRect(0, 0, s.width, s.height); n.ctx.drawImage(i, 0, 0); var U = n.ctx.getImageData(0, 0, i.width, i.height); return d.globalAlpha = 1, d.clearRect(0, 0, i.width, i.height), U }, getUniformLocations: function (n, o) { return { delta: n.getUniformLocation(o, "uDelta") } }, sendUniformData: function (n, o) { var i = this.chooseRightDelta(); n.uniform2fv(o.delta, i) }, chooseRightDelta: function () { var n = 1, o = [0, 0], i; return this.horizontal ? this.aspectRatio > 1 && (n = 1 / this.aspectRatio) : this.aspectRatio < 1 && (n = this.aspectRatio), i = n * this.blur * .12, this.horizontal ? o[0] = i : o[1] = i, o }
	}), c.Blur.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Gamma = h(c.BaseFilter, {
		type: "Gamma", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec3 uGamma;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec3 correction = (1.0 / uGamma);
color.r = pow(color.r, correction.r);
color.g = pow(color.g, correction.g);
color.b = pow(color.b, correction.b);
gl_FragColor = color;
gl_FragColor.rgb *= color.a;
}`, gamma: [1, 1, 1], mainParameter: "gamma", initialize: function (n) { this.gamma = [1, 1, 1], c.BaseFilter.prototype.initialize.call(this, n) }, applyTo2d: function (n) { var o = n.imageData, i = o.data, s = this.gamma, u = i.length, l = 1 / s[0], d = 1 / s[1], g = 1 / s[2], m; for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), m = 0, u = 256; m < u; m++)this.rVals[m] = Math.pow(m / 255, l) * 255, this.gVals[m] = Math.pow(m / 255, d) * 255, this.bVals[m] = Math.pow(m / 255, g) * 255; for (m = 0, u = i.length; m < u; m += 4)i[m] = this.rVals[i[m]], i[m + 1] = this.gVals[i[m + 1]], i[m + 2] = this.bVals[i[m + 2]] }, getUniformLocations: function (n, o) { return { uGamma: n.getUniformLocation(o, "uGamma") } }, sendUniformData: function (n, o) { n.uniform3fv(o.uGamma, this.gamma) }
	}), r.Image.filters.Gamma.fromObject = r.Image.filters.BaseFilter.fromObject
}(e), function (f) { var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.Composed = h(c.BaseFilter, { type: "Composed", subFilters: [], initialize: function (n) { this.callSuper("initialize", n), this.subFilters = this.subFilters.slice(0) }, applyTo: function (n) { n.passes += this.subFilters.length - 1, this.subFilters.forEach(function (o) { o.applyTo(n) }) }, toObject: function () { return r.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function (n) { return n.toObject() }) }) }, isNeutralState: function () { return !this.subFilters.some(function (n) { return !n.isNeutralState() }) } }), r.Image.filters.Composed.fromObject = function (n, o) { var i = n.subFilters || [], s = i.map(function (l) { return new r.Image.filters[l.type](l) }), u = new r.Image.filters.Composed({ subFilters: s }); return o && o(u), u } }(e), function (f) { var r = f.fabric || (f.fabric = {}), c = r.Image.filters, h = r.util.createClass; c.HueRotation = h(c.ColorMatrix, { type: "HueRotation", rotation: 0, mainParameter: "rotation", calculateMatrix: function () { var n = this.rotation * Math.PI, o = r.util.cos(n), i = r.util.sin(n), s = 1 / 3, u = Math.sqrt(s) * i, l = 1 - o; this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = o + l / 3, this.matrix[1] = s * l - u, this.matrix[2] = s * l + u, this.matrix[5] = s * l + u, this.matrix[6] = o + s * l, this.matrix[7] = s * l - u, this.matrix[10] = s * l - u, this.matrix[11] = s * l + u, this.matrix[12] = o + s * l }, isNeutralState: function (n) { return this.calculateMatrix(), c.BaseFilter.prototype.isNeutralState.call(this, n) }, applyTo: function (n) { this.calculateMatrix(), c.BaseFilter.prototype.applyTo.call(this, n) } }), r.Image.filters.HueRotation.fromObject = r.Image.filters.BaseFilter.fromObject }(e), function (f) {
	var r = f.fabric || (f.fabric = {}), c = r.util.object.clone; if (r.Text) { r.warn("fabric.Text is already defined"); return } var h = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" "); r.Text = r.util.createClass(r.Object, {
		_dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: "left", fontStyle: "normal", lineHeight: 1.16, superscript: { size: .6, baseline: -.35 }, subscript: { size: .6, baseline: .11 }, textBackgroundColor: "", stateProperties: r.Object.prototype.stateProperties.concat(h), cacheProperties: r.Object.prototype.cacheProperties.concat(h), stroke: null, shadow: null, path: null, pathStartOffset: 0, pathSide: "left", pathAlign: "baseline", _fontSizeFraction: .222, offsets: { underline: .1, linethrough: -.315, overline: -.88 }, _fontSizeMult: 1.13, charSpacing: 0, styles: null, _measuringContext: null, deltaY: 0, direction: "ltr", _styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"], __charBounds: [], CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, initialize: function (n, o) { this.styles = o ? o.styles || {} : {}, this.text = n, this.__skipDimension = !0, this.callSuper("initialize", o), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" }) }, setPathInfo: function () { var n = this.path; n && (n.segmentsInfo = r.util.getPathSegmentsInfo(n.path)) }, getMeasuringContext: function () { return r._measuringContext || (r._measuringContext = this.canvas && this.canvas.contextCache || r.util.createCanvasElement().getContext("2d")), r._measuringContext }, _splitText: function () { var n = this._splitTextIntoLines(this.text); return this.textLines = n.lines, this._textLines = n.graphemeLines, this._unwrappedTextLines = n._unwrappedLines, this._text = n.graphemeText, n }, initDimensions: function () { this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, enlargeSpaces: function () { for (var n, o, i, s, u, l, d, g = 0, m = this._textLines.length; g < m; g++)if (!(this.textAlign !== "justify" && (g === m - 1 || this.isEndOfWrapping(g))) && (s = 0, u = this._textLines[g], o = this.getLineWidth(g), o < this.width && (d = this.textLines[g].match(this._reSpacesAndTabs)))) { i = d.length, n = (this.width - o) / i; for (var y = 0, w = u.length; y <= w; y++)l = this.__charBounds[g][y], this._reSpaceAndTab.test(u[y]) ? (l.width += n, l.kernedWidth += n, l.left += s, s += n) : l.left += s } }, isEndOfWrapping: function (n) { return n === this._textLines.length - 1 }, missingNewlineOffset: function () { return 1 }, toString: function () { return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>' }, _getCacheCanvasDimensions: function () { var n = this.callSuper("_getCacheCanvasDimensions"), o = this.fontSize; return n.width += o * n.zoomX, n.height += o * n.zoomY, n }, _render: function (n) { var o = this.path; o && !o.isNotVisible() && o._render(n), this._setTextStyles(n), this._renderTextLinesBackground(n), this._renderTextDecoration(n, "underline"), this._renderText(n), this._renderTextDecoration(n, "overline"), this._renderTextDecoration(n, "linethrough") }, _renderText: function (n) { this.paintFirst === "stroke" ? (this._renderTextStroke(n), this._renderTextFill(n)) : (this._renderTextFill(n), this._renderTextStroke(n)) }, _setTextStyles: function (n, o, i) { if (n.textBaseline = "alphabetical", this.path) switch (this.pathAlign) { case "center": n.textBaseline = "middle"; break; case "ascender": n.textBaseline = "top"; break; case "descender": n.textBaseline = "bottom"; break }n.font = this._getFontDeclaration(o, i) }, calcTextWidth: function () { for (var n = this.getLineWidth(0), o = 1, i = this._textLines.length; o < i; o++) { var s = this.getLineWidth(o); s > n && (n = s) } return n }, _renderTextLine: function (n, o, i, s, u, l) { this._renderChars(n, o, i, s, u, l) }, _renderTextLinesBackground: function (n) { if (!(!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))) { for (var o, i, s = n.fillStyle, u, l, d = this._getLeftOffset(), g = this._getTopOffset(), m = 0, y = 0, w, C, T = this.path, A, U = 0, R = this._textLines.length; U < R; U++) { if (o = this.getHeightOfLine(U), !this.textBackgroundColor && !this.styleHas("textBackgroundColor", U)) { g += o; continue } u = this._textLines[U], i = this._getLineLeftOffset(U), y = 0, m = 0, l = this.getValueOfPropertyAt(U, 0, "textBackgroundColor"); for (var $ = 0, L = u.length; $ < L; $++)w = this.__charBounds[U][$], C = this.getValueOfPropertyAt(U, $, "textBackgroundColor"), T ? (n.save(), n.translate(w.renderLeft, w.renderTop), n.rotate(w.angle), n.fillStyle = C, C && n.fillRect(-w.width / 2, -o / this.lineHeight * (1 - this._fontSizeFraction), w.width, o / this.lineHeight), n.restore()) : C !== l ? (A = d + i + m, this.direction === "rtl" && (A = this.width - A - y), n.fillStyle = l, l && n.fillRect(A, g, y, o / this.lineHeight), m = w.left, y = w.width, l = C) : y += w.kernedWidth; C && !T && (A = d + i + m, this.direction === "rtl" && (A = this.width - A - y), n.fillStyle = C, n.fillRect(A, g, y, o / this.lineHeight)), g += o } n.fillStyle = s, this._removeShadow(n) } }, getFontCache: function (n) { var o = n.fontFamily.toLowerCase(); r.charWidthsCache[o] || (r.charWidthsCache[o] = {}); var i = r.charWidthsCache[o], s = n.fontStyle.toLowerCase() + "_" + (n.fontWeight + "").toLowerCase(); return i[s] || (i[s] = {}), i[s] }, _measureChar: function (n, o, i, s) { var u = this.getFontCache(o), l = this._getFontDeclaration(o), d = this._getFontDeclaration(s), g = i + n, m = l === d, y, w, C, T = o.fontSize / this.CACHE_FONT_SIZE, A; if (i && u[i] !== void 0 && (C = u[i]), u[n] !== void 0 && (A = y = u[n]), m && u[g] !== void 0 && (w = u[g], A = w - C), y === void 0 || C === void 0 || w === void 0) { var U = this.getMeasuringContext(); this._setTextStyles(U, o, !0) } return y === void 0 && (A = y = U.measureText(n).width, u[n] = y), C === void 0 && m && i && (C = U.measureText(i).width, u[i] = C), m && w === void 0 && (w = U.measureText(g).width, u[g] = w, A = w - C), { width: y * T, kernedWidth: A * T } }, getHeightOfChar: function (n, o) { return this.getValueOfPropertyAt(n, o, "fontSize") }, measureLine: function (n) { var o = this._measureLine(n); return this.charSpacing !== 0 && (o.width -= this._getWidthOfCharSpacing()), o.width < 0 && (o.width = 0), o }, _measureLine: function (n) { var o = 0, i, s, u = this._textLines[n], l, d, g = 0, m = new Array(u.length), y = 0, w, C, T = this.path, A = this.pathSide === "right"; for (this.__charBounds[n] = m, i = 0; i < u.length; i++)s = u[i], d = this._getGraphemeBox(s, n, i, l), m[i] = d, o += d.kernedWidth, l = s; if (m[i] = { left: d ? d.left + d.width : 0, width: 0, kernedWidth: 0, height: this.fontSize }, T) { switch (C = T.segmentsInfo[T.segmentsInfo.length - 1].length, w = r.util.getPointOnPath(T.path, 0, T.segmentsInfo), w.x += T.pathOffset.x, w.y += T.pathOffset.y, this.textAlign) { case "left": y = A ? C - o : 0; break; case "center": y = (C - o) / 2; break; case "right": y = A ? 0 : C - o; break }for (y += this.pathStartOffset * (A ? -1 : 1), i = A ? u.length - 1 : 0; A ? i >= 0 : i < u.length; A ? i-- : i++)d = m[i], y > C ? y %= C : y < 0 && (y += C), this._setGraphemeOnPath(y, d, w), y += d.kernedWidth } return { width: o, numOfSpaces: g } }, _setGraphemeOnPath: function (n, o, i) { var s = n + o.kernedWidth / 2, u = this.path, l = r.util.getPointOnPath(u.path, s, u.segmentsInfo); o.renderLeft = l.x - i.x, o.renderTop = l.y - i.y, o.angle = l.angle + (this.pathSide === "right" ? Math.PI : 0) }, _getGraphemeBox: function (n, o, i, s, u) { var l = this.getCompleteStyleDeclaration(o, i), d = s ? this.getCompleteStyleDeclaration(o, i - 1) : {}, g = this._measureChar(n, l, s, d), m = g.kernedWidth, y = g.width, w; this.charSpacing !== 0 && (w = this._getWidthOfCharSpacing(), y += w, m += w); var C = { width: y, left: 0, height: l.fontSize, kernedWidth: m, deltaY: l.deltaY }; if (i > 0 && !u) { var T = this.__charBounds[o][i - 1]; C.left = T.left + T.width + g.kernedWidth - g.width } return C }, getHeightOfLine: function (n) { if (this.__lineHeights[n]) return this.__lineHeights[n]; for (var o = this._textLines[n], i = this.getHeightOfChar(n, 0), s = 1, u = o.length; s < u; s++)i = Math.max(this.getHeightOfChar(n, s), i); return this.__lineHeights[n] = i * this.lineHeight * this._fontSizeMult }, calcTextHeight: function () { for (var n, o = 0, i = 0, s = this._textLines.length; i < s; i++)n = this.getHeightOfLine(i), o += i === s - 1 ? n / this.lineHeight : n; return o }, _getLeftOffset: function () { return this.direction === "ltr" ? -this.width / 2 : this.width / 2 }, _getTopOffset: function () { return -this.height / 2 }, _renderTextCommon: function (n, o) { n.save(); for (var i = 0, s = this._getLeftOffset(), u = this._getTopOffset(), l = 0, d = this._textLines.length; l < d; l++) { var g = this.getHeightOfLine(l), m = g / this.lineHeight, y = this._getLineLeftOffset(l); this._renderTextLine(o, n, this._textLines[l], s + y, u + i + m, l), i += g } n.restore() }, _renderTextFill: function (n) { !this.fill && !this.styleHas("fill") || this._renderTextCommon(n, "fillText") }, _renderTextStroke: function (n) { (!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles() || (this.shadow && !this.shadow.affectStroke && this._removeShadow(n), n.save(), this._setLineDash(n, this.strokeDashArray), n.beginPath(), this._renderTextCommon(n, "strokeText"), n.closePath(), n.restore()) }, _renderChars: function (n, o, i, s, u, l) { var d = this.getHeightOfLine(l), g = this.textAlign.indexOf("justify") !== -1, m, y, w = "", C, T = 0, A, U = this.path, R = !g && this.charSpacing === 0 && this.isEmptyStyles(l) && !U, $ = this.direction === "ltr", L = this.direction === "ltr" ? 1 : -1, B, N = o.canvas.getAttribute("dir"); if (o.save(), N !== this.direction && (o.canvas.setAttribute("dir", $ ? "ltr" : "rtl"), o.direction = $ ? "ltr" : "rtl", o.textAlign = $ ? "left" : "right"), u -= d * this._fontSizeFraction / this.lineHeight, R) { this._renderChar(n, o, l, 0, i.join(""), s, u, d), o.restore(); return } for (var K = 0, st = i.length - 1; K <= st; K++)A = K === st || this.charSpacing || U, w += i[K], C = this.__charBounds[l][K], T === 0 ? (s += L * (C.kernedWidth - C.width), T += C.width) : T += C.kernedWidth, g && !A && this._reSpaceAndTab.test(i[K]) && (A = !0), A || (m = m || this.getCompleteStyleDeclaration(l, K), y = this.getCompleteStyleDeclaration(l, K + 1), A = r.util.hasStyleChanged(m, y, !1)), A && (U ? (o.save(), o.translate(C.renderLeft, C.renderTop), o.rotate(C.angle), this._renderChar(n, o, l, K, w, -T / 2, 0, d), o.restore()) : (B = s, this._renderChar(n, o, l, K, w, B, u, d)), w = "", m = y, s += L * T, T = 0); o.restore() }, _applyPatternGradientTransformText: function (n) { var o = r.util.createCanvasElement(), i, s = this.width + this.strokeWidth, u = this.height + this.strokeWidth; return o.width = s, o.height = u, i = o.getContext("2d"), i.beginPath(), i.moveTo(0, 0), i.lineTo(s, 0), i.lineTo(s, u), i.lineTo(0, u), i.closePath(), i.translate(s / 2, u / 2), i.fillStyle = n.toLive(i), this._applyPatternGradientTransform(i, n), i.fill(), i.createPattern(o, "no-repeat") }, handleFiller: function (n, o, i) { var s, u; return i.toLive ? i.gradientUnits === "percentage" || i.gradientTransform || i.patternTransform ? (s = -this.width / 2, u = -this.height / 2, n.translate(s, u), n[o] = this._applyPatternGradientTransformText(i), { offsetX: s, offsetY: u }) : (n[o] = i.toLive(n, this), this._applyPatternGradientTransform(n, i)) : (n[o] = i, { offsetX: 0, offsetY: 0 }) }, _setStrokeStyles: function (n, o) { return n.lineWidth = o.strokeWidth, n.lineCap = this.strokeLineCap, n.lineDashOffset = this.strokeDashOffset, n.lineJoin = this.strokeLineJoin, n.miterLimit = this.strokeMiterLimit, this.handleFiller(n, "strokeStyle", o.stroke) }, _setFillStyles: function (n, o) { return this.handleFiller(n, "fillStyle", o.fill) }, _renderChar: function (n, o, i, s, u, l, d) { var g = this._getStyleDeclaration(i, s), m = this.getCompleteStyleDeclaration(i, s), y = n === "fillText" && m.fill, w = n === "strokeText" && m.stroke && m.strokeWidth, C, T; !w && !y || (o.save(), y && (C = this._setFillStyles(o, m)), w && (T = this._setStrokeStyles(o, m)), o.font = this._getFontDeclaration(m), g && g.textBackgroundColor && this._removeShadow(o), g && g.deltaY && (d += g.deltaY), y && o.fillText(u, l - C.offsetX, d - C.offsetY), w && o.strokeText(u, l - T.offsetX, d - T.offsetY), o.restore()) }, setSuperscript: function (n, o) { return this._setScript(n, o, this.superscript) }, setSubscript: function (n, o) { return this._setScript(n, o, this.subscript) }, _setScript: function (n, o, i) { var s = this.get2DCursorLocation(n, !0), u = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "fontSize"), l = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "deltaY"), d = { fontSize: u * i.size, deltaY: l + u * i.baseline }; return this.setSelectionStyles(d, n, o), this }, _getLineLeftOffset: function (n) { var o = this.getLineWidth(n), i = this.width - o, s = this.textAlign, u = this.direction, d, l = 0, d = this.isEndOfWrapping(n); return s === "justify" || s === "justify-center" && !d || s === "justify-right" && !d || s === "justify-left" && !d ? 0 : (s === "center" && (l = i / 2), s === "right" && (l = i), s === "justify-center" && (l = i / 2), s === "justify-right" && (l = i), u === "rtl" && (l -= i), l) }, _clearCache: function () { this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [] }, _shouldClearDimensionCache: function () { var n = this._forceClearCache; return n || (n = this.hasStateChanged("_dimensionAffectingProps")), n && (this.dirty = !0, this._forceClearCache = !1), n }, getLineWidth: function (n) { if (this.__lineWidths[n] !== void 0) return this.__lineWidths[n]; var o = this.measureLine(n), i = o.width; return this.__lineWidths[n] = i, i }, _getWidthOfCharSpacing: function () { return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0 }, getValueOfPropertyAt: function (n, o, i) { var s = this._getStyleDeclaration(n, o); return s && typeof s[i] != "undefined" ? s[i] : this[i] }, _renderTextDecoration: function (n, o) { if (!(!this[o] && !this.styleHas(o))) { for (var i, s, u, l, d, g, m, y, w = this._getLeftOffset(), C = this._getTopOffset(), T, A, U, R, $, L, B, N, K = this.path, st = this._getWidthOfCharSpacing(), ft = this.offsets[o], ht = 0, k = this._textLines.length; ht < k; ht++) { if (i = this.getHeightOfLine(ht), !this[o] && !this.styleHas(o, ht)) { C += i; continue } m = this._textLines[ht], L = i / this.lineHeight, l = this._getLineLeftOffset(ht), A = 0, U = 0, y = this.getValueOfPropertyAt(ht, 0, o), N = this.getValueOfPropertyAt(ht, 0, "fill"), T = C + L * (1 - this._fontSizeFraction), s = this.getHeightOfChar(ht, 0), d = this.getValueOfPropertyAt(ht, 0, "deltaY"); for (var M = 0, E = m.length; M < E; M++)if (R = this.__charBounds[ht][M], $ = this.getValueOfPropertyAt(ht, M, o), B = this.getValueOfPropertyAt(ht, M, "fill"), u = this.getHeightOfChar(ht, M), g = this.getValueOfPropertyAt(ht, M, "deltaY"), K && $ && B) n.save(), n.fillStyle = N, n.translate(R.renderLeft, R.renderTop), n.rotate(R.angle), n.fillRect(-R.kernedWidth / 2, ft * u + g, R.kernedWidth, this.fontSize / 15), n.restore(); else if (($ !== y || B !== N || u !== s || g !== d) && U > 0) { var P = w + l + A; this.direction === "rtl" && (P = this.width - P - U), y && N && (n.fillStyle = N, n.fillRect(P, T + ft * s + d, U, this.fontSize / 15)), A = R.left, U = R.width, y = $, N = B, s = u, d = g } else U += R.kernedWidth; var P = w + l + A; this.direction === "rtl" && (P = this.width - P - U), n.fillStyle = B, $ && B && n.fillRect(P, T + ft * s + d, U - st, this.fontSize / 15), C += i } this._removeShadow(n) } }, _getFontDeclaration: function (n, o) { var i = n || this, s = this.fontFamily, u = r.Text.genericFonts.indexOf(s.toLowerCase()) > -1, l = s === void 0 || s.indexOf("'") > -1 || s.indexOf(",") > -1 || s.indexOf('"') > -1 || u ? i.fontFamily : '"' + i.fontFamily + '"'; return [r.isLikelyNode ? i.fontWeight : i.fontStyle, r.isLikelyNode ? i.fontStyle : i.fontWeight, o ? this.CACHE_FONT_SIZE + "px" : i.fontSize + "px", l].join(" ") }, render: function (n) { this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", n))) }, _splitTextIntoLines: function (n) {
			for (var o = n.split(this._reNewline), i = new Array(o.length), s = [`
`], u = [], l = 0; l < o.length; l++)i[l] = r.util.string.graphemeSplit(o[l]), u = u.concat(i[l], s); return u.pop(), { _unwrappedLines: i, lines: o, graphemeText: u, graphemeLines: i }
		}, toObject: function (n) { var o = h.concat(n), i = this.callSuper("toObject", o); return i.styles = r.util.stylesToArray(this.styles, this.text), i.path && (i.path = this.path.toObject()), i }, set: function (n, o) { this.callSuper("set", n, o); var i = !1, s = !1; if (typeof n == "object") for (var u in n) u === "path" && this.setPathInfo(), i = i || this._dimensionAffectingProps.indexOf(u) !== -1, s = s || u === "path"; else i = this._dimensionAffectingProps.indexOf(n) !== -1, s = n === "path"; return s && this.setPathInfo(), i && (this.initDimensions(), this.setCoords()), this }, complexity: function () { return 1 }
	}), r.Text.ATTRIBUTE_NAMES = r.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), r.Text.DEFAULT_SVG_FONT_SIZE = 16, r.Text.fromElement = function (n, o, i) { if (!n) return o(null); var s = r.parseAttributes(n, r.Text.ATTRIBUTE_NAMES), u = s.textAnchor || "left"; if (i = r.util.object.extend(i ? c(i) : {}, s), i.top = i.top || 0, i.left = i.left || 0, s.textDecoration) { var l = s.textDecoration; l.indexOf("underline") !== -1 && (i.underline = !0), l.indexOf("overline") !== -1 && (i.overline = !0), l.indexOf("line-through") !== -1 && (i.linethrough = !0), delete i.textDecoration } "dx" in s && (i.left += s.dx), "dy" in s && (i.top += s.dy), "fontSize" in i || (i.fontSize = r.Text.DEFAULT_SVG_FONT_SIZE); var d = ""; "textContent" in n ? d = n.textContent : "firstChild" in n && n.firstChild !== null && "data" in n.firstChild && n.firstChild.data !== null && (d = n.firstChild.data), d = d.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "); var g = i.strokeWidth; i.strokeWidth = 0; var m = new r.Text(d, i), y = m.getScaledHeight() / m.height, w = (m.height + m.strokeWidth) * m.lineHeight - m.height, C = w * y, T = m.getScaledHeight() + C, A = 0; u === "center" && (A = m.getScaledWidth() / 2), u === "right" && (A = m.getScaledWidth()), m.set({ left: m.left - A, top: m.top - (T - m.fontSize * (.07 + m._fontSizeFraction)) / m.lineHeight, strokeWidth: typeof g != "undefined" ? g : 1 }), o(m) }, r.Text.fromObject = function (n, o) { var i = c(n), s = n.path; return delete i.path, r.Object._fromObject("Text", i, function (u) { u.styles = r.util.stylesFromArray(n.styles, n.text), s ? r.Object._fromObject("Path", s, function (l) { u.set("path", l), o(u) }, "path") : o(u) }, "text") }, r.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], r.util.createAccessors && r.util.createAccessors(r.Text)
}(e), function () { t.util.object.extend(t.Text.prototype, { isEmptyStyles: function (f) { if (!this.styles || typeof f != "undefined" && !this.styles[f]) return !0; var r = typeof f == "undefined" ? this.styles : { line: this.styles[f] }; for (var c in r) for (var h in r[c]) for (var n in r[c][h]) return !1; return !0 }, styleHas: function (f, r) { if (!this.styles || !f || f === "" || typeof r != "undefined" && !this.styles[r]) return !1; var c = typeof r == "undefined" ? this.styles : { 0: this.styles[r] }; for (var h in c) for (var n in c[h]) if (typeof c[h][n][f] != "undefined") return !0; return !1 }, cleanStyle: function (f) { if (!this.styles || !f || f === "") return !1; var r = this.styles, c = 0, h, n, o = !0, i = 0, s; for (var u in r) { h = 0; for (var l in r[u]) { var s = r[u][l], d = s.hasOwnProperty(f); c++, d ? (n ? s[f] !== n && (o = !1) : n = s[f], s[f] === this[f] && delete s[f]) : o = !1, Object.keys(s).length !== 0 ? h++ : delete r[u][l] } h === 0 && delete r[u] } for (var g = 0; g < this._textLines.length; g++)i += this._textLines[g].length; o && c === i && (this[f] = n, this.removeStyle(f)) }, removeStyle: function (f) { if (!(!this.styles || !f || f === "")) { var r = this.styles, c, h, n; for (h in r) { c = r[h]; for (n in c) delete c[n][f], Object.keys(c[n]).length === 0 && delete c[n]; Object.keys(c).length === 0 && delete r[h] } } }, _extendStyles: function (f, r) { var c = this.get2DCursorLocation(f); this._getLineStyle(c.lineIndex) || this._setLineStyle(c.lineIndex), this._getStyleDeclaration(c.lineIndex, c.charIndex) || this._setStyleDeclaration(c.lineIndex, c.charIndex, {}), t.util.object.extend(this._getStyleDeclaration(c.lineIndex, c.charIndex), r) }, get2DCursorLocation: function (f, r) { typeof f == "undefined" && (f = this.selectionStart); for (var c = r ? this._unwrappedTextLines : this._textLines, h = c.length, n = 0; n < h; n++) { if (f <= c[n].length) return { lineIndex: n, charIndex: f }; f -= c[n].length + this.missingNewlineOffset(n) } return { lineIndex: n - 1, charIndex: c[n - 1].length < f ? c[n - 1].length : f } }, getSelectionStyles: function (f, r, c) { typeof f == "undefined" && (f = this.selectionStart || 0), typeof r == "undefined" && (r = this.selectionEnd || f); for (var h = [], n = f; n < r; n++)h.push(this.getStyleAtPosition(n, c)); return h }, getStyleAtPosition: function (f, r) { var c = this.get2DCursorLocation(f), h = r ? this.getCompleteStyleDeclaration(c.lineIndex, c.charIndex) : this._getStyleDeclaration(c.lineIndex, c.charIndex); return h || {} }, setSelectionStyles: function (f, r, c) { typeof r == "undefined" && (r = this.selectionStart || 0), typeof c == "undefined" && (c = this.selectionEnd || r); for (var h = r; h < c; h++)this._extendStyles(h, f); return this._forceClearCache = !0, this }, _getStyleDeclaration: function (f, r) { var c = this.styles && this.styles[f]; return c ? c[r] : null }, getCompleteStyleDeclaration: function (f, r) { for (var c = this._getStyleDeclaration(f, r) || {}, h = {}, n, o = 0; o < this._styleProperties.length; o++)n = this._styleProperties[o], h[n] = typeof c[n] == "undefined" ? this[n] : c[n]; return h }, _setStyleDeclaration: function (f, r, c) { this.styles[f][r] = c }, _deleteStyleDeclaration: function (f, r) { delete this.styles[f][r] }, _getLineStyle: function (f) { return !!this.styles[f] }, _setLineStyle: function (f) { this.styles[f] = {} }, _deleteLineStyle: function (f) { delete this.styles[f] } }) }(), function () { function f(r) { r.textDecoration && (r.textDecoration.indexOf("underline") > -1 && (r.underline = !0), r.textDecoration.indexOf("line-through") > -1 && (r.linethrough = !0), r.textDecoration.indexOf("overline") > -1 && (r.overline = !0), delete r.textDecoration) } t.IText = t.util.createClass(t.Text, t.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: !1, __widthOfSpace: [], inCompositionMode: !1, initialize: function (r, c) { this.callSuper("initialize", r, c), this.initBehavior() }, setSelectionStart: function (r) { r = Math.max(r, 0), this._updateAndFire("selectionStart", r) }, setSelectionEnd: function (r) { r = Math.min(r, this.text.length), this._updateAndFire("selectionEnd", r) }, _updateAndFire: function (r, c) { this[r] !== c && (this._fireSelectionChanged(), this[r] = c), this._updateTextarea() }, _fireSelectionChanged: function () { this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this }) }, initDimensions: function () { this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions") }, render: function (r) { this.clearContextTop(), this.callSuper("render", r), this.cursorOffsetCache = {}, this.renderCursorOrSelection() }, _render: function (r) { this.callSuper("_render", r) }, clearContextTop: function (r) { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var c = this.canvas.contextTop, h = this.canvas.viewportTransform; c.save(), c.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this.transform(c), this._clearTextArea(c), r || c.restore() } }, renderCursorOrSelection: function () { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var r = this._getCursorBoundaries(), c = this.canvas.contextTop; this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(r, c) : this.renderSelection(r, c), c.restore() } }, _clearTextArea: function (r) { var c = this.width + 4, h = this.height + 4; r.clearRect(-c / 2, -h / 2, c, h) }, _getCursorBoundaries: function (r) { typeof r == "undefined" && (r = this.selectionStart); var c = this._getLeftOffset(), h = this._getTopOffset(), n = this._getCursorBoundariesOffsets(r); return { left: c, top: h, leftOffset: n.left, topOffset: n.top } }, _getCursorBoundariesOffsets: function (r) { if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache; var c, h, n, o = 0, i = 0, s, u = this.get2DCursorLocation(r); n = u.charIndex, h = u.lineIndex; for (var l = 0; l < h; l++)o += this.getHeightOfLine(l); c = this._getLineLeftOffset(h); var d = this.__charBounds[h][n]; return d && (i = d.left), this.charSpacing !== 0 && n === this._textLines[h].length && (i -= this._getWidthOfCharSpacing()), s = { top: o, left: c + (i > 0 ? i : 0) }, this.direction === "rtl" && (s.left *= -1), this.cursorOffsetCache = s, this.cursorOffsetCache }, renderCursor: function (r, c) { var h = this.get2DCursorLocation(), n = h.lineIndex, o = h.charIndex > 0 ? h.charIndex - 1 : 0, i = this.getValueOfPropertyAt(n, o, "fontSize"), s = this.scaleX * this.canvas.getZoom(), u = this.cursorWidth / s, l = r.topOffset, d = this.getValueOfPropertyAt(n, o, "deltaY"); l += (1 - this._fontSizeFraction) * this.getHeightOfLine(n) / this.lineHeight - i * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(r, c), c.fillStyle = this.cursorColor || this.getValueOfPropertyAt(n, o, "fill"), c.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, c.fillRect(r.left + r.leftOffset - u / 2, l + r.top + d, u, i) }, renderSelection: function (r, c) { for (var h = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, n = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, o = this.textAlign.indexOf("justify") !== -1, i = this.get2DCursorLocation(h), s = this.get2DCursorLocation(n), u = i.lineIndex, l = s.lineIndex, d = i.charIndex < 0 ? 0 : i.charIndex, g = s.charIndex < 0 ? 0 : s.charIndex, m = u; m <= l; m++) { var y = this._getLineLeftOffset(m) || 0, w = this.getHeightOfLine(m), C = 0, T = 0, A = 0; if (m === u && (T = this.__charBounds[u][d].left), m >= u && m < l) A = o && !this.isEndOfWrapping(m) ? this.width : this.getLineWidth(m) || 5; else if (m === l) if (g === 0) A = this.__charBounds[l][g].left; else { var U = this._getWidthOfCharSpacing(); A = this.__charBounds[l][g - 1].left + this.__charBounds[l][g - 1].width - U } C = w, (this.lineHeight < 1 || m === l && this.lineHeight > 1) && (w /= this.lineHeight); var R = r.left + y + T, $ = A - T, L = w, B = 0; this.inCompositionMode ? (c.fillStyle = this.compositionColor || "black", L = 1, B = w) : c.fillStyle = this.selectionColor, this.direction === "rtl" && (R = this.width - R - $), c.fillRect(R, r.top + r.topOffset + B, $, L), r.topOffset += C } }, getCurrentCharFontSize: function () { var r = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(r.l, r.c, "fontSize") }, getCurrentCharColor: function () { var r = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(r.l, r.c, "fill") }, _getCurrentCharIndex: function () { var r = this.get2DCursorLocation(this.selectionStart, !0), c = r.charIndex > 0 ? r.charIndex - 1 : 0; return { l: r.lineIndex, c } } }), t.IText.fromObject = function (r, c) { var h = t.util.stylesFromArray(r.styles, r.text), n = Object.assign({}, r, { styles: h }); if (f(n), n.styles) for (var o in n.styles) for (var i in n.styles[o]) f(n.styles[o][i]); t.Object._fromObject("IText", n, c, "text") } }(), function () {
	var f = t.util.object.clone; t.util.object.extend(t.IText.prototype, {
		initBehavior: function () { this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this) }, onDeselect: function () { this.isEditing && this.exitEditing(), this.selected = !1 }, initAddedHandler: function () { var r = this; this.on("added", function () { var c = r.canvas; c && (c._hasITextHandlers || (c._hasITextHandlers = !0, r._initCanvasHandlers(c)), c._iTextInstances = c._iTextInstances || [], c._iTextInstances.push(r)) }) }, initRemovedHandler: function () { var r = this; this.on("removed", function () { var c = r.canvas; c && (c._iTextInstances = c._iTextInstances || [], t.util.removeFromArray(c._iTextInstances, r), c._iTextInstances.length === 0 && (c._hasITextHandlers = !1, r._removeCanvasHandlers(c))) }) }, _initCanvasHandlers: function (r) { r._mouseUpITextHandler = function () { r._iTextInstances && r._iTextInstances.forEach(function (c) { c.__isMousedown = !1 }) }, r.on("mouse:up", r._mouseUpITextHandler) }, _removeCanvasHandlers: function (r) { r.off("mouse:up", r._mouseUpITextHandler) }, _tick: function () { this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete") }, _animateCursor: function (r, c, h, n) { var o; return o = { isAborted: !1, abort: function () { this.isAborted = !0 } }, r.animate("_currentCursorOpacity", c, { duration: h, onComplete: function () { o.isAborted || r[n]() }, onChange: function () { r.canvas && r.selectionStart === r.selectionEnd && r.renderCursorOrSelection() }, abort: function () { return o.isAborted } }), o }, _onTickComplete: function () { var r = this; this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () { r._currentTickCompleteState = r._animateCursor(r, 0, this.cursorDuration / 2, "_tick") }, 100) }, initDelayedCursor: function (r) { var c = this, h = r ? 0 : this.cursorDelay; this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () { c._tick() }, h) }, abortCursorAnimation: function () { var r = this._currentTickState || this._currentTickCompleteState, c = this.canvas; this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, r && c && c.clearContext(c.contextTop || c.contextContainer) }, selectAll: function () { return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this }, getSelectedText: function () { return this._text.slice(this.selectionStart, this.selectionEnd).join("") }, findWordBoundaryLeft: function (r) { var c = 0, h = r - 1; if (this._reSpace.test(this._text[h])) for (; this._reSpace.test(this._text[h]);)c++, h--; for (; /\S/.test(this._text[h]) && h > -1;)c++, h--; return r - c }, findWordBoundaryRight: function (r) { var c = 0, h = r; if (this._reSpace.test(this._text[h])) for (; this._reSpace.test(this._text[h]);)c++, h++; for (; /\S/.test(this._text[h]) && h < this._text.length;)c++, h++; return r + c }, findLineBoundaryLeft: function (r) { for (var c = 0, h = r - 1; !/\n/.test(this._text[h]) && h > -1;)c++, h--; return r - c }, findLineBoundaryRight: function (r) { for (var c = 0, h = r; !/\n/.test(this._text[h]) && h < this._text.length;)c++, h++; return r + c }, searchWordBoundary: function (r, c) { for (var h = this._text, n = this._reSpace.test(h[r]) ? r - 1 : r, o = h[n], i = t.reNonWord; !i.test(o) && n > 0 && n < h.length;)n += c, o = h[n]; return i.test(o) && (n += c === 1 ? 0 : 1), n }, selectWord: function (r) { r = r || this.selectionStart; var c = this.searchWordBoundary(r, -1), h = this.searchWordBoundary(r, 1); this.selectionStart = c, this.selectionEnd = h, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection() }, selectLine: function (r) { r = r || this.selectionStart; var c = this.findLineBoundaryLeft(r), h = this.findLineBoundaryRight(r); return this.selectionStart = c, this.selectionEnd = h, this._fireSelectionChanged(), this._updateTextarea(), this }, enterEditing: function (r) { if (!(this.isEditing || !this.editable)) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(r), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this }, exitEditingOnOthers: function (r) { r._iTextInstances && r._iTextInstances.forEach(function (c) { c.selected = !1, c.isEditing && c.exitEditing() }) }, initMouseMoveHandler: function () { this.canvas.on("mouse:move", this.mouseMoveHandler) }, mouseMoveHandler: function (r) { if (!(!this.__isMousedown || !this.isEditing)) { document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus(); var c = this.getSelectionStartFromPointer(r.e), h = this.selectionStart, n = this.selectionEnd; (c !== this.__selectionStartOnMouseDown || h === n) && (h === c || n === c) || (c > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = c) : (this.selectionStart = c, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== h || this.selectionEnd !== n) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection())) } }, _setEditingProps: function () { this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0 }, fromStringToGraphemeSelection: function (r, c, h) { var n = h.slice(0, r), o = t.util.string.graphemeSplit(n).length; if (r === c) return { selectionStart: o, selectionEnd: o }; var i = h.slice(r, c), s = t.util.string.graphemeSplit(i).length; return { selectionStart: o, selectionEnd: o + s } }, fromGraphemeToStringSelection: function (r, c, h) { var n = h.slice(0, r), o = n.join("").length; if (r === c) return { selectionStart: o, selectionEnd: o }; var i = h.slice(r, c), s = i.join("").length; return { selectionStart: o, selectionEnd: o + s } }, _updateTextarea: function () { if (this.cursorOffsetCache = {}, !!this.hiddenTextarea) { if (!this.inCompositionMode) { var r = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text); this.hiddenTextarea.selectionStart = r.selectionStart, this.hiddenTextarea.selectionEnd = r.selectionEnd } this.updateTextareaPosition() } }, updateFromTextArea: function () { if (this.hiddenTextarea) { this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()); var r = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value); this.selectionEnd = this.selectionStart = r.selectionEnd, this.inCompositionMode || (this.selectionStart = r.selectionStart), this.updateTextareaPosition() } }, updateTextareaPosition: function () { if (this.selectionStart === this.selectionEnd) { var r = this._calcTextareaPosition(); this.hiddenTextarea.style.left = r.left, this.hiddenTextarea.style.top = r.top } }, _calcTextareaPosition: function () { if (!this.canvas) return { x: 1, y: 1 }; var r = this.inCompositionMode ? this.compositionStart : this.selectionStart, c = this._getCursorBoundaries(r), h = this.get2DCursorLocation(r), n = h.lineIndex, o = h.charIndex, i = this.getValueOfPropertyAt(n, o, "fontSize") * this.lineHeight, s = c.leftOffset, u = this.calcTransformMatrix(), l = { x: c.left + s, y: c.top + c.topOffset + i }, d = this.canvas.getRetinaScaling(), g = this.canvas.upperCanvasEl, m = g.width / d, y = g.height / d, w = m - i, C = y - i, T = g.clientWidth / m, A = g.clientHeight / y; return l = t.util.transformPoint(l, u), l = t.util.transformPoint(l, this.canvas.viewportTransform), l.x *= T, l.y *= A, l.x < 0 && (l.x = 0), l.x > w && (l.x = w), l.y < 0 && (l.y = 0), l.y > C && (l.y = C), l.x += this.canvas._offset.left, l.y += this.canvas._offset.top, { left: l.x + "px", top: l.y + "px", fontSize: i + "px", charHeight: i } }, _saveEditingProps: function () { this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor } }, _restoreEditingProps: function () { this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor)) }, exitEditing: function () { var r = this._textBeforeEdit !== this.text, c = this.hiddenTextarea; return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, c && (c.blur && c.blur(), c.parentNode && c.parentNode.removeChild(c)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), r && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), r && this.canvas.fire("object:modified", { target: this })), this }, _removeExtraneousStyles: function () { for (var r in this.styles) this._textLines[r] || delete this.styles[r] }, removeStyleFromTo: function (r, c) { var h = this.get2DCursorLocation(r, !0), n = this.get2DCursorLocation(c, !0), o = h.lineIndex, i = h.charIndex, s = n.lineIndex, u = n.charIndex, l, d; if (o !== s) { if (this.styles[o]) for (l = i; l < this._unwrappedTextLines[o].length; l++)delete this.styles[o][l]; if (this.styles[s]) for (l = u; l < this._unwrappedTextLines[s].length; l++)d = this.styles[s][l], d && (this.styles[o] || (this.styles[o] = {}), this.styles[o][i + l - u] = d); for (l = o + 1; l <= s; l++)delete this.styles[l]; this.shiftLineStyles(s, o - s) } else if (this.styles[o]) { d = this.styles[o]; var g = u - i, m, y; for (l = i; l < u; l++)delete d[l]; for (y in this.styles[o]) m = parseInt(y, 10), m >= u && (d[m - g] = d[y], delete d[y]) } }, shiftLineStyles: function (r, c) { var h = f(this.styles); for (var n in this.styles) { var o = parseInt(n, 10); o > r && (this.styles[o + c] = h[o], h[o - c] || delete this.styles[o]) } }, restartCursorIfNeeded: function () { (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor() }, insertNewlineStyleObject: function (r, c, h, n) { var o, i = {}, s = !1, u = this._unwrappedTextLines[r].length === c; h || (h = 1), this.shiftLineStyles(r, h), this.styles[r] && (o = this.styles[r][c === 0 ? c : c - 1]); for (var l in this.styles[r]) { var d = parseInt(l, 10); d >= c && (s = !0, i[d - c] = this.styles[r][l], u && c === 0 || delete this.styles[r][l]) } var g = !1; for (s && !u && (this.styles[r + h] = i, g = !0), g && h--; h > 0;)n && n[h - 1] ? this.styles[r + h] = { 0: f(n[h - 1]) } : o ? this.styles[r + h] = { 0: f(o) } : delete this.styles[r + h], h--; this._forceClearCache = !0 }, insertCharStyleObject: function (r, c, h, n) { this.styles || (this.styles = {}); var o = this.styles[r], i = o ? f(o) : {}; h || (h = 1); for (var s in i) { var u = parseInt(s, 10); u >= c && (o[u + h] = i[u], i[u - h] || delete o[u]) } if (this._forceClearCache = !0, n) { for (; h--;)Object.keys(n[h]).length && (this.styles[r] || (this.styles[r] = {}), this.styles[r][c + h] = f(n[h])); return } if (o) for (var l = o[c ? c - 1 : 1]; l && h--;)this.styles[r][c + h] = f(l) }, insertNewStyleBlock: function (r, c, h) {
			for (var n = this.get2DCursorLocation(c, !0), o = [0], i = 0, s = 0; s < r.length; s++)r[s] === `
`? (i++, o[i] = 0) : o[i]++; o[0] > 0 && (this.insertCharStyleObject(n.lineIndex, n.charIndex, o[0], h), h = h && h.slice(o[0] + 1)), i && this.insertNewlineStyleObject(n.lineIndex, n.charIndex + o[0], i); for (var s = 1; s < i; s++)o[s] > 0 ? this.insertCharStyleObject(n.lineIndex + s, 0, o[s], h) : h && this.styles[n.lineIndex + s] && h[0] && (this.styles[n.lineIndex + s][0] = h[0]), h = h && h.slice(o[s] + 1); o[s] > 0 && this.insertCharStyleObject(n.lineIndex + s, 0, o[s], h)
		}, setSelectionStartEndWithShift: function (r, c, h) { h <= r ? (c === r ? this._selectionDirection = "left" : this._selectionDirection === "right" && (this._selectionDirection = "left", this.selectionEnd = r), this.selectionStart = h) : h > r && h < c ? this._selectionDirection === "right" ? this.selectionEnd = h : this.selectionStart = h : (c === r ? this._selectionDirection = "right" : this._selectionDirection === "left" && (this._selectionDirection = "right", this.selectionStart = c), this.selectionEnd = h) }, setSelectionInBoundaries: function () { var r = this.text.length; this.selectionStart > r ? this.selectionStart = r : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > r ? this.selectionEnd = r : this.selectionEnd < 0 && (this.selectionEnd = 0) }
	})
}(), t.util.object.extend(t.IText.prototype, { initDoubleClickSimulation: function () { this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown) }, onMouseDown: function (f) { if (this.canvas) { this.__newClickTime = +new Date; var r = f.pointer; this.isTripleClick(r) && (this.fire("tripleclick", f), this._stopEvent(f.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = r, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected } }, isTripleClick: function (f) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === f.x && this.__lastPointer.y === f.y }, _stopEvent: function (f) { f.preventDefault && f.preventDefault(), f.stopPropagation && f.stopPropagation() }, initCursorSelectionHandlers: function () { this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks() }, doubleClickHandler: function (f) { this.isEditing && this.selectWord(this.getSelectionStartFromPointer(f.e)) }, tripleClickHandler: function (f) { this.isEditing && this.selectLine(this.getSelectionStartFromPointer(f.e)) }, initClicks: function () { this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler) }, _mouseDownHandler: function (f) { !this.canvas || !this.editable || f.e.button && f.e.button !== 1 || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(f.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())) }, _mouseDownHandlerBefore: function (f) { !this.canvas || !this.editable || f.e.button && f.e.button !== 1 || (this.selected = this === this.canvas._activeObject) }, initMousedownHandler: function () { this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore) }, initMouseupHandler: function () { this.on("mouseup", this.mouseUpHandler) }, mouseUpHandler: function (f) { if (this.__isMousedown = !1, !(!this.editable || this.group || f.transform && f.transform.actionPerformed || f.e.button && f.e.button !== 1)) { if (this.canvas) { var r = this.canvas._activeObject; if (r && r !== this) return } this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(f.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0 } }, setCursorByClick: function (f) { var r = this.getSelectionStartFromPointer(f), c = this.selectionStart, h = this.selectionEnd; f.shiftKey ? this.setSelectionStartEndWithShift(c, h, r) : (this.selectionStart = r, this.selectionEnd = r), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea()) }, getSelectionStartFromPointer: function (f) { for (var r = this.getLocalPointer(f), c = 0, h = 0, n = 0, o = 0, i = 0, s, u, l = 0, d = this._textLines.length; l < d && n <= r.y; l++)n += this.getHeightOfLine(l) * this.scaleY, i = l, l > 0 && (o += this._textLines[l - 1].length + this.missingNewlineOffset(l - 1)); s = this._getLineLeftOffset(i), h = s * this.scaleX, u = this._textLines[i], this.direction === "rtl" && (r.x = this.width * this.scaleX - r.x + h); for (var g = 0, m = u.length; g < m && (c = h, h += this.__charBounds[i][g].kernedWidth * this.scaleX, h <= r.x); g++)o++; return this._getNewSelectionStartFromOffset(r, c, h, o, m) }, _getNewSelectionStartFromOffset: function (f, r, c, h, n) { var o = f.x - r, i = c - f.x, s = i > o || i < 0 ? 0 : 1, u = h + s; return this.flipX && (u = n - u), u > this._text.length && (u = this._text.length), u } }), t.util.object.extend(t.IText.prototype, { initHiddenTextarea: function () { this.hiddenTextarea = t.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off"); var f = this._calcTextareaPosition(); this.hiddenTextarea.style.cssText = "position: absolute; top: " + f.top + "; left: " + f.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + f.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : t.document.body.appendChild(this.hiddenTextarea), t.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), t.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), t.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), t.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), t.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), t.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (t.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0) }, keysMap: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown" }, keysMapRtl: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorLeft", 36: "moveCursorRight", 37: "moveCursorRight", 38: "moveCursorUp", 39: "moveCursorLeft", 40: "moveCursorDown" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function () { this.hiddenTextarea && this.hiddenTextarea.focus() }, onKeyDown: function (f) { if (this.isEditing) { var r = this.direction === "rtl" ? this.keysMapRtl : this.keysMap; if (f.keyCode in r) this[r[f.keyCode]](f); else if (f.keyCode in this.ctrlKeysMapDown && (f.ctrlKey || f.metaKey)) this[this.ctrlKeysMapDown[f.keyCode]](f); else return; f.stopImmediatePropagation(), f.preventDefault(), f.keyCode >= 33 && f.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll() } }, onKeyUp: function (f) { if (!this.isEditing || this._copyDone || this.inCompositionMode) { this._copyDone = !1; return } if (f.keyCode in this.ctrlKeysMapUp && (f.ctrlKey || f.metaKey)) this[this.ctrlKeysMapUp[f.keyCode]](f); else return; f.stopImmediatePropagation(), f.preventDefault(), this.canvas && this.canvas.requestRenderAll() }, onInput: function (f) { var r = this.fromPaste; if (this.fromPaste = !1, f && f.stopPropagation(), !!this.isEditing) { var c = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, h = this._text.length, n = c.length, o, i, s = n - h, u = this.selectionStart, l = this.selectionEnd, d = u !== l, g, m, y; if (this.hiddenTextarea.value === "") { this.styles = {}, this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()); return } var w = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), C = u > w.selectionStart; d ? (o = this._text.slice(u, l), s += l - u) : n < h && (C ? o = this._text.slice(l + s, l) : o = this._text.slice(u, u - s)), i = c.slice(w.selectionEnd - s, w.selectionEnd), o && o.length && (i.length && (g = this.getSelectionStyles(u, u + 1, !1), g = i.map(function () { return g[0] })), d ? (m = u, y = l) : C ? (m = l - o.length, y = l) : (m = l, y = l + o.length), this.removeStyleFromTo(m, y)), i.length && (r && i.join("") === t.copiedText && !t.disableStyleCopyPaste && (g = t.copiedTextStyle), this.insertNewStyleBlock(i, u, g)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()) } }, onCompositionStart: function () { this.inCompositionMode = !0 }, onCompositionEnd: function () { this.inCompositionMode = !1 }, onCompositionUpdate: function (f) { this.compositionStart = f.target.selectionStart, this.compositionEnd = f.target.selectionEnd, this.updateTextareaPosition() }, copy: function () { this.selectionStart !== this.selectionEnd && (t.copiedText = this.getSelectedText(), t.disableStyleCopyPaste ? t.copiedTextStyle = null : t.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0) }, paste: function () { this.fromPaste = !0 }, _getClipboardData: function (f) { return f && f.clipboardData || t.window.clipboardData }, _getWidthBeforeCursor: function (f, r) { var c = this._getLineLeftOffset(f), h; return r > 0 && (h = this.__charBounds[f][r - 1], c += h.left + h.width), c }, getDownCursorOffset: function (f, r) { var c = this._getSelectionForOffset(f, r), h = this.get2DCursorLocation(c), n = h.lineIndex; if (n === this._textLines.length - 1 || f.metaKey || f.keyCode === 34) return this._text.length - c; var o = h.charIndex, i = this._getWidthBeforeCursor(n, o), s = this._getIndexOnLine(n + 1, i), u = this._textLines[n].slice(o); return u.length + s + 1 + this.missingNewlineOffset(n) }, _getSelectionForOffset: function (f, r) { return f.shiftKey && this.selectionStart !== this.selectionEnd && r ? this.selectionEnd : this.selectionStart }, getUpCursorOffset: function (f, r) { var c = this._getSelectionForOffset(f, r), h = this.get2DCursorLocation(c), n = h.lineIndex; if (n === 0 || f.metaKey || f.keyCode === 33) return -c; var o = h.charIndex, i = this._getWidthBeforeCursor(n, o), s = this._getIndexOnLine(n - 1, i), u = this._textLines[n].slice(0, o), l = this.missingNewlineOffset(n - 1); return -this._textLines[n - 1].length + s - u.length + (1 - l) }, _getIndexOnLine: function (f, r) { for (var c = this._textLines[f], h = this._getLineLeftOffset(f), n = h, o = 0, i, s, u = 0, l = c.length; u < l; u++)if (i = this.__charBounds[f][u].width, n += i, n > r) { s = !0; var d = n - i, g = n, m = Math.abs(d - r), y = Math.abs(g - r); o = y < m ? u : u - 1; break } return s || (o = c.length - 1), o }, moveCursorDown: function (f) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", f) }, moveCursorUp: function (f) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", f) }, _moveCursorUpOrDown: function (f, r) { var c = "get" + f + "CursorOffset", h = this[c](r, this._selectionDirection === "right"); r.shiftKey ? this.moveCursorWithShift(h) : this.moveCursorWithoutShift(h), h !== 0 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorWithShift: function (f) { var r = this._selectionDirection === "left" ? this.selectionStart + f : this.selectionEnd + f; return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, r), f !== 0 }, moveCursorWithoutShift: function (f) { return f < 0 ? (this.selectionStart += f, this.selectionEnd = this.selectionStart) : (this.selectionEnd += f, this.selectionStart = this.selectionEnd), f !== 0 }, moveCursorLeft: function (f) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", f) }, _move: function (f, r, c) { var h; if (f.altKey) h = this["findWordBoundary" + c](this[r]); else if (f.metaKey || f.keyCode === 35 || f.keyCode === 36) h = this["findLineBoundary" + c](this[r]); else return this[r] += c === "Left" ? -1 : 1, !0; if (typeof h != "undefined" && this[r] !== h) return this[r] = h, !0 }, _moveLeft: function (f, r) { return this._move(f, r, "Left") }, _moveRight: function (f, r) { return this._move(f, r, "Right") }, moveCursorLeftWithoutShift: function (f) { var r = !0; return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (r = this._moveLeft(f, "selectionStart")), this.selectionEnd = this.selectionStart, r }, moveCursorLeftWithShift: function (f) { if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) return this._moveLeft(f, "selectionEnd"); if (this.selectionStart !== 0) return this._selectionDirection = "left", this._moveLeft(f, "selectionStart") }, moveCursorRight: function (f) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", f) }, _moveCursorLeftOrRight: function (f, r) { var c = "moveCursor" + f + "With"; this._currentCursorOpacity = 1, r.shiftKey ? c += "Shift" : c += "outShift", this[c](r) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorRightWithShift: function (f) { if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) return this._moveRight(f, "selectionStart"); if (this.selectionEnd !== this._text.length) return this._selectionDirection = "right", this._moveRight(f, "selectionEnd") }, moveCursorRightWithoutShift: function (f) { var r = !0; return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (r = this._moveRight(f, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, r }, removeChars: function (f, r) { typeof r == "undefined" && (r = f + 1), this.removeStyleFromTo(f, r), this._text.splice(f, r - f), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() }, insertChars: function (f, r, c, h) { typeof h == "undefined" && (h = c), h > c && this.removeStyleFromTo(c, h); var n = t.util.string.graphemeSplit(f); this.insertNewStyleBlock(n, c, r), this._text = [].concat(this._text.slice(0, c), n, this._text.slice(h)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() } }), function () {
	var f = t.util.toFixed, r = /  +/g; t.util.object.extend(t.Text.prototype, {
		_toSVG: function () { var c = this._getSVGLeftTopOffsets(), h = this._getSVGTextAndBg(c.textTop, c.textLeft); return this._wrapSVGTextAndBg(h) }, toSVG: function (c) { return this._createBaseSVGMarkup(this._toSVG(), { reviver: c, noStyle: !0, withShadow: !0 }) }, _getSVGLeftTopOffsets: function () { return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) } }, _wrapSVGTextAndBg: function (c) {
			var h = !0, n = this.getSvgTextDecoration(this); return [c.textBgRects.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", n ? 'text-decoration="' + n + '" ' : "", 'style="', this.getSvgStyles(h), '"', this.addPaintOrder(), " >", c.textSpans.join(""), `</text>
`]
		}, _getSVGTextAndBg: function (c, h) { var n = [], o = [], i = c, s; this._setSVGBg(o); for (var u = 0, l = this._textLines.length; u < l; u++)s = this._getLineLeftOffset(u), (this.textBackgroundColor || this.styleHas("textBackgroundColor", u)) && this._setSVGTextLineBg(o, u, h + s, i), this._setSVGTextLineText(n, u, h + s, i), i += this.getHeightOfLine(u); return { textSpans: n, textBgRects: o } }, _createTextCharSpan: function (c, h, n, o) { var i = c !== c.trim() || c.match(r), s = this.getSvgSpanStyles(h, i), u = s ? 'style="' + s + '"' : "", l = h.deltaY, d = "", g = t.Object.NUM_FRACTION_DIGITS; return l && (d = ' dy="' + f(l, g) + '" '), ['<tspan x="', f(n, g), '" y="', f(o, g), '" ', d, u, ">", t.util.string.escapeXml(c), "</tspan>"].join("") }, _setSVGTextLineText: function (c, h, n, o) { var i = this.getHeightOfLine(h), s = this.textAlign.indexOf("justify") !== -1, u, l, d = "", g, m, y = 0, w = this._textLines[h], C; o += i * (1 - this._fontSizeFraction) / this.lineHeight; for (var T = 0, A = w.length - 1; T <= A; T++)C = T === A || this.charSpacing, d += w[T], g = this.__charBounds[h][T], y === 0 ? (n += g.kernedWidth - g.width, y += g.width) : y += g.kernedWidth, s && !C && this._reSpaceAndTab.test(w[T]) && (C = !0), C || (u = u || this.getCompleteStyleDeclaration(h, T), l = this.getCompleteStyleDeclaration(h, T + 1), C = t.util.hasStyleChanged(u, l, !0)), C && (m = this._getStyleDeclaration(h, T) || {}, c.push(this._createTextCharSpan(d, m, n, o)), d = "", u = l, n += y, y = 0) }, _pushTextBgRect: function (c, h, n, o, i, s) {
			var u = t.Object.NUM_FRACTION_DIGITS; c.push("		<rect ", this._getFillAttributes(h), ' x="', f(n, u), '" y="', f(o, u), '" width="', f(i, u), '" height="', f(s, u), `"></rect>
`)
		}, _setSVGTextLineBg: function (c, h, n, o) { for (var i = this._textLines[h], s = this.getHeightOfLine(h) / this.lineHeight, u = 0, l = 0, d, g, m = this.getValueOfPropertyAt(h, 0, "textBackgroundColor"), y = 0, w = i.length; y < w; y++)d = this.__charBounds[h][y], g = this.getValueOfPropertyAt(h, y, "textBackgroundColor"), g !== m ? (m && this._pushTextBgRect(c, m, n + l, o, u, s), l = d.left, u = d.width, m = g) : u += d.kernedWidth; g && this._pushTextBgRect(c, g, n + l, o, u, s) }, _getFillAttributes: function (c) { var h = c && typeof c == "string" ? new t.Color(c) : ""; return !h || !h.getSource() || h.getAlpha() === 1 ? 'fill="' + c + '"' : 'opacity="' + h.getAlpha() + '" fill="' + h.setAlpha(1).toRgb() + '"' }, _getSVGLineTopOffset: function (c) { for (var h = 0, n = 0, o = 0; o < c; o++)h += this.getHeightOfLine(o); return n = this.getHeightOfLine(o), { lineTop: h, offset: (this._fontSizeMult - this._fontSizeFraction) * n / (this.lineHeight * this._fontSizeMult) } }, getSvgStyles: function (c) { var h = t.Object.prototype.getSvgStyles.call(this, c); return h + " white-space: pre;" }
	})
}(), function (f) {
	var r = f.fabric || (f.fabric = {}); r.Textbox = r.util.createClass(r.IText, r.Observable, {
		type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingFlip: !0, noScaleCache: !1, _dimensionAffectingProps: r.Text.prototype._dimensionAffectingProps.concat("width"), _wordJoiners: /[ \t\r]/, splitByGrapheme: !1, initDimensions: function () { this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, _generateStyleMap: function (c) {
			for (var h = 0, n = 0, o = 0, i = {}, s = 0; s < c.graphemeLines.length; s++)c.graphemeText[o] === `
`&& s > 0 ? (n = 0, o++, h++) : !this.splitByGrapheme && this._reSpaceAndTab.test(c.graphemeText[o]) && s > 0 && (n++, o++), i[s] = { line: h, offset: n }, o += c.graphemeLines[s].length, n += c.graphemeLines[s].length; return i
		}, styleHas: function (c, h) { if (this._styleMap && !this.isWrapping) { var n = this._styleMap[h]; n && (h = n.line) } return r.Text.prototype.styleHas.call(this, c, h) }, isEmptyStyles: function (c) { if (!this.styles) return !0; var h = 0, n = c + 1, o, i, s = !1, u = this._styleMap[c], l = this._styleMap[c + 1]; u && (c = u.line, h = u.offset), l && (n = l.line, s = n === c, o = l.offset), i = typeof c == "undefined" ? this.styles : { line: this.styles[c] }; for (var d in i) for (var g in i[d]) if (g >= h && (!s || g < o)) for (var m in i[d][g]) return !1; return !0 }, _getStyleDeclaration: function (c, h) { if (this._styleMap && !this.isWrapping) { var n = this._styleMap[c]; if (!n) return null; c = n.line, h = n.offset + h } return this.callSuper("_getStyleDeclaration", c, h) }, _setStyleDeclaration: function (c, h, n) { var o = this._styleMap[c]; c = o.line, h = o.offset + h, this.styles[c][h] = n }, _deleteStyleDeclaration: function (c, h) { var n = this._styleMap[c]; c = n.line, h = n.offset + h, delete this.styles[c][h] }, _getLineStyle: function (c) { var h = this._styleMap[c]; return !!this.styles[h.line] }, _setLineStyle: function (c) { var h = this._styleMap[c]; this.styles[h.line] = {} }, _wrapText: function (c, h) { var n = [], o; for (this.isWrapping = !0, o = 0; o < c.length; o++)n = n.concat(this._wrapLine(c[o], o, h)); return this.isWrapping = !1, n }, _measureWord: function (c, h, n) { var o = 0, i, s = !0; n = n || 0; for (var u = 0, l = c.length; u < l; u++) { var d = this._getGraphemeBox(c[u], h, u + n, i, s); o += d.kernedWidth, i = c[u] } return o }, _wrapLine: function (c, h, n, R) { var i = 0, s = this.splitByGrapheme, u = [], l = [], d = s ? r.util.string.graphemeSplit(c) : c.split(this._wordJoiners), g = "", m = 0, y = s ? "" : " ", w = 0, C = 0, T = 0, A = !0, U = this._getWidthOfCharSpacing(), R = R || 0; d.length === 0 && d.push([]), n -= R; for (var $ = 0; $ < d.length; $++)g = s ? d[$] : r.util.string.graphemeSplit(d[$]), w = this._measureWord(g, h, m), m += g.length, i += C + w - U, i > n && !A ? (u.push(l), l = [], i = w, A = !0) : i += U, !A && !s && l.push(y), l = l.concat(g), C = s ? 0 : this._measureWord([y], h, m), m++, A = !1, w > T && (T = w); return $ && u.push(l), T + R > this.dynamicMinWidth && (this.dynamicMinWidth = T - U + R), u }, isEndOfWrapping: function (c) { return !this._styleMap[c + 1] || this._styleMap[c + 1].line !== this._styleMap[c].line }, missingNewlineOffset: function (c) { return this.splitByGrapheme ? this.isEndOfWrapping(c) ? 1 : 0 : 1 }, _splitTextIntoLines: function (c) { for (var h = r.Text.prototype._splitTextIntoLines.call(this, c), n = this._wrapText(h.lines, this.width), o = new Array(n.length), i = 0; i < n.length; i++)o[i] = n[i].join(""); return h.lines = o, h.graphemeLines = n, h }, getMinWidth: function () { return Math.max(this.minWidth, this.dynamicMinWidth) }, _removeExtraneousStyles: function () { var c = {}; for (var h in this._styleMap) this._textLines[h] && (c[this._styleMap[h].line] = 1); for (var h in this.styles) c[h] || delete this.styles[h] }, toObject: function (c) { return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(c)) }
	}), r.Textbox.fromObject = function (c, h) { var n = r.util.stylesFromArray(c.styles, c.text), o = Object.assign({}, c, { styles: n }); return r.Object._fromObject("Textbox", o, h, "text") }
}(e), function () { var f = t.controlsUtils, r = f.scaleSkewCursorStyleHandler, c = f.scaleCursorStyleHandler, h = f.scalingEqually, n = f.scalingYOrSkewingX, o = f.scalingXOrSkewingY, i = f.scaleOrSkewActionName, s = t.Object.prototype.controls; if (s.ml = new t.Control({ x: -.5, y: 0, cursorStyleHandler: r, actionHandler: o, getActionName: i }), s.mr = new t.Control({ x: .5, y: 0, cursorStyleHandler: r, actionHandler: o, getActionName: i }), s.mb = new t.Control({ x: 0, y: .5, cursorStyleHandler: r, actionHandler: n, getActionName: i }), s.mt = new t.Control({ x: 0, y: -.5, cursorStyleHandler: r, actionHandler: n, getActionName: i }), s.tl = new t.Control({ x: -.5, y: -.5, cursorStyleHandler: c, actionHandler: h }), s.tr = new t.Control({ x: .5, y: -.5, cursorStyleHandler: c, actionHandler: h }), s.bl = new t.Control({ x: -.5, y: .5, cursorStyleHandler: c, actionHandler: h }), s.br = new t.Control({ x: .5, y: .5, cursorStyleHandler: c, actionHandler: h }), s.mtr = new t.Control({ x: 0, y: -.5, actionHandler: f.rotationWithSnapping, cursorStyleHandler: f.rotationStyleHandler, offsetY: -40, withConnection: !0, actionName: "rotate" }), t.Textbox) { var u = t.Textbox.prototype.controls = {}; u.mtr = s.mtr, u.tr = s.tr, u.br = s.br, u.tl = s.tl, u.bl = s.bl, u.mt = s.mt, u.mb = s.mb, u.mr = new t.Control({ x: .5, y: 0, actionHandler: f.changeWidth, cursorStyleHandler: r, actionName: "resizing" }), u.ml = new t.Control({ x: -.5, y: 0, actionHandler: f.changeWidth, cursorStyleHandler: r, actionName: "resizing" }) } }()
})(Q); const zh = { style: { display: "inline-block" } }, Uh = ["alt", "onClick"], Hh = Dt({ name: "ImportFile" }), Vh = Dt(Ut(Et({}, Hh), { setup(e) { const t = { insertImg: function () { kn({ accept: "image/*", multiple: !0 }).then(r => { Array.from(r).forEach(c => { li(c).then(h => { v(h, c.name) }) }) }) } }, a = r => { const c = t[r]; c && typeof c == "function" && c() }; function p(r) { if (!r) throw new Error("file is undefined"); const c = document.createElement("img"); c.src = r, document.body.appendChild(c), c.onload = () => { const h = new Q.fabric.Image(c, { id: Jt(), name: "Image", scaleX: 1, scaleY: 1, left: 1, top: 1 }); _.canvas.add(h), _.canvas.setActiveObject(h), _.canvas.renderAll(), c.remove() } } function v(r, c) { _.uploadImage(r, c) } const { canvasEditor: _ } = zt(), b = ee({ materialType: [""], materialTypelist: [], materialist: [] }); _.getUserUploads().then(r => { b.materialist = r }); const f = r => ie(this, null, function* () { qt.Spin.show(); try { let c = yield Te.get(`127.0.0.1:8000/api/template/getImage/${r}`); console.log(c.data.image), p(c.data.image), qt.Spin.hide() } catch (c) { console.error("Error fetching data:", c) } }); return (r, c) => { const h = ut("Divider"), n = ut("Tooltip"), o = pi("lazy"); return lt(), mt("div", null, [S("div", zh, [S("button", { id: "imageUploadButton", onClick: c[0] || (c[0] = i => a("insertImg")), class: "ivu-btn ivu-btn-primary" }, yt(r.$t("insertFile.upload_image")), 1)]), (lt(!0), mt(te, null, ce(j(b).materialist, i => (lt(), mt("div", { key: i.value }, [I(h, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(i.label), 1)]), _: 2 }, 1024), (lt(!0), mt(te, null, ce(i.list, (s, u) => (lt(), Rt(n, { id: "uploadedImageContainer", content: s.label, key: `${u}-bai1-button`, placement: "top" }, { default: G(() => [Ct(S("img", { class: "tmpl-img", alt: s.label, onClick: l => f(s.image_id) }, null, 8, Uh), [[o, s.src]])]), _: 2 }, 1032, ["content"]))), 128))]))), 128))]) } } })); const Nh = Yt(Vh, [["__scopeId", "data-v-18210757"]]); const Wh = { key: 0, class: "box attr-item" }, Yh = Dt({ name: "Align" }), Gh = Object.assign(Yh, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(), p = Wt(() => t.mSelectMode !== "multiple"), v = () => { a.left() }, _ = () => { a.right() }, b = () => { a.xcenter() }, f = () => { a.ycenter() }, r = () => { a.top() }, c = () => { a.bottom() }, h = () => { a.xequation() }, n = () => { a.yequation() }; return (o, i) => { const s = ut("Button"), u = ut("Tooltip"); return j(t).mSelectMode === "multiple" ? (lt(), mt("div", Wh, [I(u, { content: o.$t("group_align.left") }, { default: G(() => [I(s, { disabled: j(p), onClick: v, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.centerX") }, { default: G(() => [I(s, { disabled: j(p), onClick: b, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.right") }, { default: G(() => [I(s, { disabled: j(p), onClick: _, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.top") }, { default: G(() => [I(s, { disabled: j(p), onClick: r, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.centerY") }, { default: G(() => [I(s, { disabled: j(p), onClick: f, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.bottom") }, { default: G(() => [I(s, { disabled: j(p), onClick: c, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.averageX") }, { default: G(() => [I(s, { disabled: j(p), onClick: h, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(u, { content: o.$t("group_align.averageY") }, { default: G(() => [I(s, { disabled: j(p), onClick: n, size: "small", type: "text" }, null, 8, ["disabled"])]), _: 1 }, 8, ["content"])])) : At("", !0) } } }), Xh = Yt(Gh, [["__scopeId", "data-v-6cc0f9bf"]]); const Lr = e => (me("data-v-bb1984eb"), e = e(), ve(), e), Kh = { key: 0, class: "box attr-item" }, qh = Lr(() => S("svg", { t: "1650442559691", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "3787", width: "14", height: "14" }, [S("path", { d: "M885 607H544V417h192V227H544V24h-64v203H288v190h192v190H139v190h341v203h64V797h341z", "p-id": "3788" })], -1)), Jh = Lr(() => S("svg", { t: "1650852784867", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "2351", width: "14", height: "14" }, [S("path", { d: "M544 480V64h-64v416H64v64h416v416h64V544h416v-64z", fill: "#727272", "p-id": "2352" }), S("path", { d: "M123.7 241.1h119.5v64H123.7zM302.9 241.1h119.5v64H302.9zM601.6 241.1h119.5v64H601.6zM780.8 241.1h119.5v64H780.8zM123.7 718.9h119.5v64H123.7zM302.9 718.9h119.5v64H302.9zM601.6 718.9h119.5v64H601.6zM780.8 718.9h119.5v64H780.8z", fill: "#B2B2B2", "p-id": "2353" })], -1)), Zh = Lr(() => S("svg", { t: "1650442510967", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "3412", width: "14", height: "14" }, [S("path", { d: "M859.9 474H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8z m-353.6-74.7c2.9 3.7 8.5 3.7 11.3 0l100.8-127.5c3.7-4.7 0.4-11.7-5.7-11.7H550V104c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v156h-62.8c-6 0-9.4 7-5.7 11.7l100.8 127.6z m11.4 225.4c-2.9-3.7-8.5-3.7-11.3 0L405.6 752.3c-3.7 4.7-0.4 11.7 5.7 11.7H474v156c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V764h62.8c6 0 9.4-7 5.7-11.7L517.7 624.7z", "p-id": "3413" })], -1)), Qh = Dt({ name: "CenterAlign" }), tf = Object.assign(Qh, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(), p = v => { a.position(v) }; return (v, _) => { const b = ut("Button"), f = ut("Tooltip"); return j(t).mSelectMode ? (lt(), mt("div", Kh, [I(f, { content: v.$t("center_align.centerX") }, { default: G(() => [I(b, { disabled: !j(t).mSelectMode, onClick: _[0] || (_[0] = r => p("centerH")), type: "text" }, { default: G(() => [qh]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(f, { content: v.$t("center_align.center") }, { default: G(() => [I(b, { disabled: !j(t).mSelectMode, onClick: _[1] || (_[1] = r => p("center")), type: "text" }, { default: G(() => [Jh]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(f, { content: v.$t("center_align.centerY") }, { default: G(() => [I(b, { disabled: !j(t).mSelectMode, onClick: _[2] || (_[2] = r => p("centerV")), type: "text" }, { default: G(() => [Zh]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"])])) : At("", !0) } } }), ef = Yt(tf, [["__scopeId", "data-v-bb1984eb"]]); const Ca = e => (me("data-v-51b4c2de"), e = e(), ve(), e), nf = { key: 0, class: "box attr-item" }, rf = Ca(() => S("svg", { t: "1650443094178", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "1549", width: "14", height: "14" }, [S("path", { d: "M252.76928 299.904l146.2784 0 0 472.42752-146.2784 0 0-472.42752Z", "p-id": "1550" }), S("path", { d: "M477.48096 85.34528l70.87104 0 0 885.80608-70.87104 0 0-885.80608Z", "p-id": "1551" }), S("path", { d: "M629.80096 284.8l31.0016 0 0 502.88128-31.0016 0L629.80096 284.8zM776.42752 284.8l31.0016 0 0 502.88128-31.0016 0L776.42752 284.8zM657.09056 315.8016l0-31.0016 123.04896 0 0 31.0016L657.09056 315.8016zM657.27488 787.64544l0-31.0016 123.04896 0 0 31.0016L657.27488 787.64544z", "p-id": "1552" })], -1)), sf = Ca(() => S("svg", { t: "1650443104385", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "1749", width: "14", height: "14" }, [S("path", { d: "M286.01856 250.91584l472.4224 0 0 146.2784-472.4224 0 0-146.2784Z", "p-id": "1750" }), S("path", { d: "M87.19872 475.62752l885.80096 0 0 70.87104-885.80096 0 0-70.87104Z", "p-id": "1751" }), S("path", { d: "M773.55008 627.94752l0 31.0016L270.6688 658.94912l0-31.0016L773.55008 627.94752zM773.55008 774.5792l0 31.0016L270.6688 805.5808l0-31.0016L773.55008 774.5792zM742.54848 655.24224l31.0016 0 0 123.04896-31.0016 0L742.54848 655.24224zM270.70464 655.42144l31.0016 0 0 123.04896-31.0016 0L270.70464 655.42144z", "p-id": "1752" })], -1)), of = Dt({ name: "Flip" }), af = Object.assign(of, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(), p = () => t.mSelectMode !== "one", v = _ => { const b = a.canvas.getActiveObject(); b.set(`flip${_}`, !b[`flip${_}`]).setCoords(), a.canvas.requestRenderAll() }; return (_, b) => { const f = ut("Button"), r = ut("Tooltip"); return j(t).mSelectMode === "one" ? (lt(), mt("div", nf, [I(r, { content: _.$t("flip.x") }, { default: G(() => [I(f, { disabled: p(), onClick: b[0] || (b[0] = c => v("X")), type: "text" }, { default: G(() => [rf]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(r, { content: _.$t("flip.y") }, { default: G(() => [I(f, { disabled: p(), onClick: b[1] || (b[1] = c => v("Y")), type: "text" }, { default: G(() => [sf]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"])])) : At("", !0) } } }), lf = Yt(af, [["__scopeId", "data-v-51b4c2de"]]), cf = Dt({ __name: "previewCurrent", setup(e) { const t = Ue("canvasEditor"), a = () => { t.preview().then(p => { qt.ImagePreview.show({ previewList: [p] }) }) }; return (p, v) => { const _ = ut("Button"); return lt(), Rt(_, { type: "text", onClick: a }, { default: G(() => [xt(yt(p.$t("preview")), 1)]), _: 1 }) } } }); var uf = typeof global == "object" && global && global.Object === Object && global; const Sa = uf; var hf = typeof self == "object" && self && self.Object === Object && self, ff = Sa || hf || Function("return this")(); const _e = ff; var df = _e.Symbol; const an = df; var xa = Object.prototype, pf = xa.hasOwnProperty, gf = xa.toString, wn = an ? an.toStringTag : void 0; function mf(e) { var t = pf.call(e, wn), a = e[wn]; try { e[wn] = void 0; var p = !0 } catch (_) { } var v = gf.call(e); return p && (t ? e[wn] = a : delete e[wn]), v } var vf = Object.prototype, _f = vf.toString; function yf(e) { return _f.call(e) } var bf = "[object Null]", wf = "[object Undefined]", Ss = an ? an.toStringTag : void 0; function qe(e) { return e == null ? e === void 0 ? wf : bf : Ss && Ss in Object(e) ? mf(e) : yf(e) } function Je(e) { return e != null && typeof e == "object" } var Cf = "[object Symbol]"; function Sf(e) { return typeof e == "symbol" || Je(e) && qe(e) == Cf } var xf = Array.isArray; const Fr = xf; var Tf = /\s/; function Of(e) { for (var t = e.length; t-- && Tf.test(e.charAt(t));); return t } var kf = /^\s+/; function Af(e) { return e && e.slice(0, Of(e) + 1).replace(kf, "") } function De(e) { var t = typeof e; return e != null && (t == "object" || t == "function") } var xs = 0 / 0, Ef = /^[-+]0x[0-9a-f]+$/i, Pf = /^0b[01]+$/i, Mf = /^0o[0-7]+$/i, jf = parseInt; function Ts(e) { if (typeof e == "number") return e; if (Sf(e)) return xs; if (De(e)) { var t = typeof e.valueOf == "function" ? e.valueOf() : e; e = De(t) ? t + "" : t } if (typeof e != "string") return e === 0 ? e : +e; e = Af(e); var a = Pf.test(e); return a || Mf.test(e) ? jf(e.slice(2), a ? 2 : 8) : Ef.test(e) ? xs : +e } var Df = "[object AsyncFunction]", Lf = "[object Function]", Ff = "[object GeneratorFunction]", $f = "[object Proxy]"; function Ta(e) { if (!De(e)) return !1; var t = qe(e); return t == Lf || t == Ff || t == Df || t == $f } var If = _e["__core-js_shared__"]; const $i = If; var Os = function () { var e = /[^.]+$/.exec($i && $i.keys && $i.keys.IE_PROTO || ""); return e ? "Symbol(src)_1." + e : "" }(); function Rf(e) { return !!Os && Os in e } var Bf = Function.prototype, zf = Bf.toString; function Ze(e) { if (e != null) { try { return zf.call(e) } catch (t) { } try { return e + "" } catch (t) { } } return "" } var Uf = /[\\^$.*+?()[\]{}|]/g, Hf = /^\[object .+?Constructor\]$/, Vf = Function.prototype, Nf = Object.prototype, Wf = Vf.toString, Yf = Nf.hasOwnProperty, Gf = RegExp("^" + Wf.call(Yf).replace(Uf, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function Xf(e) { if (!De(e) || Rf(e)) return !1; var t = Ta(e) ? Gf : Hf; return t.test(Ze(e)) } function Kf(e, t) { return e == null ? void 0 : e[t] } function Qe(e, t) { var a = Kf(e, t); return Xf(a) ? a : void 0 } var qf = Qe(_e, "WeakMap"); const ir = qf; var ks = Object.create, Jf = function () { function e() { } return function (t) { if (!De(t)) return {}; if (ks) return ks(t); e.prototype = t; var a = new e; return e.prototype = void 0, a } }(); const Zf = Jf; function Qf(e, t) { var a = -1, p = e.length; for (t || (t = Array(p)); ++a < p;)t[a] = e[a]; return t } var td = function () { try { var e = Qe(Object, "defineProperty"); return e({}, "", {}), e } catch (t) { } }(); const As = td; function ed(e, t) { for (var a = -1, p = e == null ? 0 : e.length; ++a < p && t(e[a], a, e) !== !1;); return e } var nd = 9007199254740991, id = /^(?:0|[1-9]\d*)$/; function rd(e, t) { var a = typeof e; return t = t == null ? nd : t, !!t && (a == "number" || a != "symbol" && id.test(e)) && e > -1 && e % 1 == 0 && e < t } function Oa(e, t, a) { t == "__proto__" && As ? As(e, t, { configurable: !0, enumerable: !0, value: a, writable: !0 }) : e[t] = a } function ka(e, t) { return e === t || e !== e && t !== t } var sd = Object.prototype, od = sd.hasOwnProperty; function Aa(e, t, a) { var p = e[t]; (!(od.call(e, t) && ka(p, a)) || a === void 0 && !(t in e)) && Oa(e, t, a) } function bi(e, t, a, p) { var v = !a; a || (a = {}); for (var _ = -1, b = t.length; ++_ < b;) { var f = t[_], r = p ? p(a[f], e[f], f, a, e) : void 0; r === void 0 && (r = e[f]), v ? Oa(a, f, r) : Aa(a, f, r) } return a } var ad = 9007199254740991; function Ea(e) { return typeof e == "number" && e > -1 && e % 1 == 0 && e <= ad } function Pa(e) { return e != null && Ea(e.length) && !Ta(e) } var ld = Object.prototype; function $r(e) { var t = e && e.constructor, a = typeof t == "function" && t.prototype || ld; return e === a } function cd(e, t) { for (var a = -1, p = Array(e); ++a < e;)p[a] = t(a); return p } var ud = "[object Arguments]"; function Es(e) { return Je(e) && qe(e) == ud } var Ma = Object.prototype, hd = Ma.hasOwnProperty, fd = Ma.propertyIsEnumerable, dd = Es(function () { return arguments }()) ? Es : function (e) { return Je(e) && hd.call(e, "callee") && !fd.call(e, "callee") }; const pd = dd; function gd() { return !1 } var ja = typeof exports == "object" && exports && !exports.nodeType && exports, Ps = ja && typeof module == "object" && module && !module.nodeType && module, md = Ps && Ps.exports === ja, Ms = md ? _e.Buffer : void 0, vd = Ms ? Ms.isBuffer : void 0, _d = vd || gd; const Da = _d; var yd = "[object Arguments]", bd = "[object Array]", wd = "[object Boolean]", Cd = "[object Date]", Sd = "[object Error]", xd = "[object Function]", Td = "[object Map]", Od = "[object Number]", kd = "[object Object]", Ad = "[object RegExp]", Ed = "[object Set]", Pd = "[object String]", Md = "[object WeakMap]", jd = "[object ArrayBuffer]", Dd = "[object DataView]", Ld = "[object Float32Array]", Fd = "[object Float64Array]", $d = "[object Int8Array]", Id = "[object Int16Array]", Rd = "[object Int32Array]", Bd = "[object Uint8Array]", zd = "[object Uint8ClampedArray]", Ud = "[object Uint16Array]", Hd = "[object Uint32Array]", Xt = {}; Xt[Ld] = Xt[Fd] = Xt[$d] = Xt[Id] = Xt[Rd] = Xt[Bd] = Xt[zd] = Xt[Ud] = Xt[Hd] = !0; Xt[yd] = Xt[bd] = Xt[jd] = Xt[wd] = Xt[Dd] = Xt[Cd] = Xt[Sd] = Xt[xd] = Xt[Td] = Xt[Od] = Xt[kd] = Xt[Ad] = Xt[Ed] = Xt[Pd] = Xt[Md] = !1; function Vd(e) { return Je(e) && Ea(e.length) && !!Xt[qe(e)] } function Ir(e) { return function (t) { return e(t) } } var La = typeof exports == "object" && exports && !exports.nodeType && exports, Tn = La && typeof module == "object" && module && !module.nodeType && module, Nd = Tn && Tn.exports === La, Ii = Nd && Sa.process, Wd = function () { try { var e = Tn && Tn.require && Tn.require("util").types; return e || Ii && Ii.binding && Ii.binding("util") } catch (t) { } }(); const ln = Wd; var js = ln && ln.isTypedArray, Yd = js ? Ir(js) : Vd; const Gd = Yd; var Xd = Object.prototype, Kd = Xd.hasOwnProperty; function Fa(e, t) { var a = Fr(e), p = !a && pd(e), v = !a && !p && Da(e), _ = !a && !p && !v && Gd(e), b = a || p || v || _, f = b ? cd(e.length, String) : [], r = f.length; for (var c in e) (t || Kd.call(e, c)) && !(b && (c == "length" || v && (c == "offset" || c == "parent") || _ && (c == "buffer" || c == "byteLength" || c == "byteOffset") || rd(c, r))) && f.push(c); return f } function $a(e, t) { return function (a) { return e(t(a)) } } var qd = $a(Object.keys, Object); const Jd = qd; var Zd = Object.prototype, Qd = Zd.hasOwnProperty; function tp(e) { if (!$r(e)) return Jd(e); var t = []; for (var a in Object(e)) Qd.call(e, a) && a != "constructor" && t.push(a); return t } function Rr(e) { return Pa(e) ? Fa(e) : tp(e) } function ep(e) { var t = []; if (e != null) for (var a in Object(e)) t.push(a); return t } var np = Object.prototype, ip = np.hasOwnProperty; function rp(e) { if (!De(e)) return ep(e); var t = $r(e), a = []; for (var p in e) p == "constructor" && (t || !ip.call(e, p)) || a.push(p); return a } function Br(e) { return Pa(e) ? Fa(e, !0) : rp(e) } var sp = Qe(Object, "create"); const En = sp; function op() { this.__data__ = En ? En(null) : {}, this.size = 0 } function ap(e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } var lp = "__lodash_hash_undefined__", cp = Object.prototype, up = cp.hasOwnProperty; function hp(e) { var t = this.__data__; if (En) { var a = t[e]; return a === lp ? void 0 : a } return up.call(t, e) ? t[e] : void 0 } var fp = Object.prototype, dp = fp.hasOwnProperty; function pp(e) { var t = this.__data__; return En ? t[e] !== void 0 : dp.call(t, e) } var gp = "__lodash_hash_undefined__"; function mp(e, t) { var a = this.__data__; return this.size += this.has(e) ? 0 : 1, a[e] = En && t === void 0 ? gp : t, this } function Ge(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } Ge.prototype.clear = op; Ge.prototype.delete = ap; Ge.prototype.get = hp; Ge.prototype.has = pp; Ge.prototype.set = mp; function vp() { this.__data__ = [], this.size = 0 } function wi(e, t) { for (var a = e.length; a--;)if (ka(e[a][0], t)) return a; return -1 } var _p = Array.prototype, yp = _p.splice; function bp(e) { var t = this.__data__, a = wi(t, e); if (a < 0) return !1; var p = t.length - 1; return a == p ? t.pop() : yp.call(t, a, 1), --this.size, !0 } function wp(e) { var t = this.__data__, a = wi(t, e); return a < 0 ? void 0 : t[a][1] } function Cp(e) { return wi(this.__data__, e) > -1 } function Sp(e, t) { var a = this.__data__, p = wi(a, e); return p < 0 ? (++this.size, a.push([e, t])) : a[p][1] = t, this } function Fe(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } Fe.prototype.clear = vp; Fe.prototype.delete = bp; Fe.prototype.get = wp; Fe.prototype.has = Cp; Fe.prototype.set = Sp; var xp = Qe(_e, "Map"); const Pn = xp; function Tp() { this.size = 0, this.__data__ = { hash: new Ge, map: new (Pn || Fe), string: new Ge } } function Op(e) { var t = typeof e; return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null } function Ci(e, t) { var a = e.__data__; return Op(t) ? a[typeof t == "string" ? "string" : "hash"] : a.map } function kp(e) { var t = Ci(this, e).delete(e); return this.size -= t ? 1 : 0, t } function Ap(e) { return Ci(this, e).get(e) } function Ep(e) { return Ci(this, e).has(e) } function Pp(e, t) { var a = Ci(this, e), p = a.size; return a.set(e, t), this.size += a.size == p ? 0 : 1, this } function fn(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } fn.prototype.clear = Tp; fn.prototype.delete = kp; fn.prototype.get = Ap; fn.prototype.has = Ep; fn.prototype.set = Pp; function Ia(e, t) { for (var a = -1, p = t.length, v = e.length; ++a < p;)e[v + a] = t[a]; return e } var Mp = $a(Object.getPrototypeOf, Object); const Ra = Mp; function jp() { this.__data__ = new Fe, this.size = 0 } function Dp(e) { var t = this.__data__, a = t.delete(e); return this.size = t.size, a } function Lp(e) { return this.__data__.get(e) } function Fp(e) { return this.__data__.has(e) } var $p = 200; function Ip(e, t) { var a = this.__data__; if (a instanceof Fe) { var p = a.__data__; if (!Pn || p.length < $p - 1) return p.push([e, t]), this.size = ++a.size, this; a = this.__data__ = new fn(p) } return a.set(e, t), this.size = a.size, this } function dn(e) { var t = this.__data__ = new Fe(e); this.size = t.size } dn.prototype.clear = jp; dn.prototype.delete = Dp; dn.prototype.get = Lp; dn.prototype.has = Fp; dn.prototype.set = Ip; function Rp(e, t) { return e && bi(t, Rr(t), e) } function Bp(e, t) { return e && bi(t, Br(t), e) } var Ba = typeof exports == "object" && exports && !exports.nodeType && exports, Ds = Ba && typeof module == "object" && module && !module.nodeType && module, zp = Ds && Ds.exports === Ba, Ls = zp ? _e.Buffer : void 0, Fs = Ls ? Ls.allocUnsafe : void 0; function Up(e, t) { if (t) return e.slice(); var a = e.length, p = Fs ? Fs(a) : new e.constructor(a); return e.copy(p), p } function Hp(e, t) { for (var a = -1, p = e == null ? 0 : e.length, v = 0, _ = []; ++a < p;) { var b = e[a]; t(b, a, e) && (_[v++] = b) } return _ } function za() { return [] } var Vp = Object.prototype, Np = Vp.propertyIsEnumerable, $s = Object.getOwnPropertySymbols, Wp = $s ? function (e) { return e == null ? [] : (e = Object(e), Hp($s(e), function (t) { return Np.call(e, t) })) } : za; const zr = Wp; function Yp(e, t) { return bi(e, zr(e), t) } var Gp = Object.getOwnPropertySymbols, Xp = Gp ? function (e) { for (var t = []; e;)Ia(t, zr(e)), e = Ra(e); return t } : za; const Ua = Xp; function Kp(e, t) { return bi(e, Ua(e), t) } function Ha(e, t, a) { var p = t(e); return Fr(e) ? p : Ia(p, a(e)) } function qp(e) { return Ha(e, Rr, zr) } function Jp(e) { return Ha(e, Br, Ua) } var Zp = Qe(_e, "DataView"); const rr = Zp; var Qp = Qe(_e, "Promise"); const sr = Qp; var tg = Qe(_e, "Set"); const or = tg; var Is = "[object Map]", eg = "[object Object]", Rs = "[object Promise]", Bs = "[object Set]", zs = "[object WeakMap]", Us = "[object DataView]", ng = Ze(rr), ig = Ze(Pn), rg = Ze(sr), sg = Ze(or), og = Ze(ir), Ne = qe; (rr && Ne(new rr(new ArrayBuffer(1))) != Us || Pn && Ne(new Pn) != Is || sr && Ne(sr.resolve()) != Rs || or && Ne(new or) != Bs || ir && Ne(new ir) != zs) && (Ne = function (e) { var t = qe(e), a = t == eg ? e.constructor : void 0, p = a ? Ze(a) : ""; if (p) switch (p) { case ng: return Us; case ig: return Is; case rg: return Rs; case sg: return Bs; case og: return zs }return t }); const Ur = Ne; var ag = Object.prototype, lg = ag.hasOwnProperty; function cg(e) { var t = e.length, a = new e.constructor(t); return t && typeof e[0] == "string" && lg.call(e, "index") && (a.index = e.index, a.input = e.input), a } var ug = _e.Uint8Array; const Hs = ug; function Hr(e) { var t = new e.constructor(e.byteLength); return new Hs(t).set(new Hs(e)), t } function hg(e, t) { var a = t ? Hr(e.buffer) : e.buffer; return new e.constructor(a, e.byteOffset, e.byteLength) } var fg = /\w*$/; function dg(e) { var t = new e.constructor(e.source, fg.exec(e)); return t.lastIndex = e.lastIndex, t } var Vs = an ? an.prototype : void 0, Ns = Vs ? Vs.valueOf : void 0; function pg(e) { return Ns ? Object(Ns.call(e)) : {} } function gg(e, t) { var a = t ? Hr(e.buffer) : e.buffer; return new e.constructor(a, e.byteOffset, e.length) } var mg = "[object Boolean]", vg = "[object Date]", _g = "[object Map]", yg = "[object Number]", bg = "[object RegExp]", wg = "[object Set]", Cg = "[object String]", Sg = "[object Symbol]", xg = "[object ArrayBuffer]", Tg = "[object DataView]", Og = "[object Float32Array]", kg = "[object Float64Array]", Ag = "[object Int8Array]", Eg = "[object Int16Array]", Pg = "[object Int32Array]", Mg = "[object Uint8Array]", jg = "[object Uint8ClampedArray]", Dg = "[object Uint16Array]", Lg = "[object Uint32Array]"; function Fg(e, t, a) { var p = e.constructor; switch (t) { case xg: return Hr(e); case mg: case vg: return new p(+e); case Tg: return hg(e, a); case Og: case kg: case Ag: case Eg: case Pg: case Mg: case jg: case Dg: case Lg: return gg(e, a); case _g: return new p; case yg: case Cg: return new p(e); case bg: return dg(e); case wg: return new p; case Sg: return pg(e) } } function $g(e) { return typeof e.constructor == "function" && !$r(e) ? Zf(Ra(e)) : {} } var Ig = "[object Map]"; function Rg(e) { return Je(e) && Ur(e) == Ig } var Ws = ln && ln.isMap, Bg = Ws ? Ir(Ws) : Rg; const zg = Bg; var Ug = "[object Set]"; function Hg(e) { return Je(e) && Ur(e) == Ug } var Ys = ln && ln.isSet, Vg = Ys ? Ir(Ys) : Hg; const Ng = Vg; var Wg = 1, Yg = 2, Gg = 4, Va = "[object Arguments]", Xg = "[object Array]", Kg = "[object Boolean]", qg = "[object Date]", Jg = "[object Error]", Na = "[object Function]", Zg = "[object GeneratorFunction]", Qg = "[object Map]", tm = "[object Number]", Wa = "[object Object]", em = "[object RegExp]", nm = "[object Set]", im = "[object String]", rm = "[object Symbol]", sm = "[object WeakMap]", om = "[object ArrayBuffer]", am = "[object DataView]", lm = "[object Float32Array]", cm = "[object Float64Array]", um = "[object Int8Array]", hm = "[object Int16Array]", fm = "[object Int32Array]", dm = "[object Uint8Array]", pm = "[object Uint8ClampedArray]", gm = "[object Uint16Array]", mm = "[object Uint32Array]", Ht = {}; Ht[Va] = Ht[Xg] = Ht[om] = Ht[am] = Ht[Kg] = Ht[qg] = Ht[lm] = Ht[cm] = Ht[um] = Ht[hm] = Ht[fm] = Ht[Qg] = Ht[tm] = Ht[Wa] = Ht[em] = Ht[nm] = Ht[im] = Ht[rm] = Ht[dm] = Ht[pm] = Ht[gm] = Ht[mm] = !0; Ht[Jg] = Ht[Na] = Ht[sm] = !1; function ti(e, t, a, p, v, _) { var b, f = t & Wg, r = t & Yg, c = t & Gg; if (a && (b = v ? a(e, p, v, _) : a(e)), b !== void 0) return b; if (!De(e)) return e; var h = Fr(e); if (h) { if (b = cg(e), !f) return Qf(e, b) } else { var n = Ur(e), o = n == Na || n == Zg; if (Da(e)) return Up(e, f); if (n == Wa || n == Va || o && !v) { if (b = r || o ? {} : $g(e), !f) return r ? Kp(e, Bp(b, e)) : Yp(e, Rp(b, e)) } else { if (!Ht[n]) return v ? e : {}; b = Fg(e, n, f) } } _ || (_ = new dn); var i = _.get(e); if (i) return i; _.set(e, b), Ng(e) ? e.forEach(function (l) { b.add(ti(l, t, a, l, e, _)) }) : zg(e) && e.forEach(function (l, d) { b.set(d, ti(l, t, a, d, e, _)) }); var s = c ? r ? Jp : qp : r ? Br : Rr, u = h ? void 0 : s(e); return ed(u || e, function (l, d) { u && (d = l, l = e[d]), Aa(b, d, ti(l, t, a, d, e, _)) }), b } var vm = 1, _m = 4; function ui(e) { return ti(e, vm | _m) } var ym = function () { return _e.Date.now() }; const Ri = ym; var bm = "Expected a function", wm = Math.max, Cm = Math.min; function tn(e, t, a) { var p, v, _, b, f, r, c = 0, h = !1, n = !1, o = !0; if (typeof e != "function") throw new TypeError(bm); t = Ts(t) || 0, De(a) && (h = !!a.leading, n = "maxWait" in a, _ = n ? wm(Ts(a.maxWait) || 0, t) : _, o = "trailing" in a ? !!a.trailing : o); function i(C) { var T = p, A = v; return p = v = void 0, c = C, b = e.apply(A, T), b } function s(C) { return c = C, f = setTimeout(d, t), h ? i(C) : b } function u(C) { var T = C - r, A = C - c, U = t - T; return n ? Cm(U, _ - A) : U } function l(C) { var T = C - r, A = C - c; return r === void 0 || T >= t || T < 0 || n && A >= _ } function d() { var C = Ri(); if (l(C)) return g(C); f = setTimeout(d, u(C)) } function g(C) { return f = void 0, o && p ? i(C) : (p = v = void 0, b) } function m() { f !== void 0 && clearTimeout(f), c = 0, p = r = v = f = void 0 } function y() { return f === void 0 ? b : g(Ri()) } function w() { var C = Ri(), T = l(C); if (p = arguments, v = this, r = C, T) { if (f === void 0) return s(r); if (n) return clearTimeout(f), f = setTimeout(d, t), i(r) } return f === void 0 && (f = setTimeout(d, t)), b } return w.cancel = m, w.flush = y, w } var Sm = "[object Number]"; function ae(e) { return typeof e == "number" || Je(e) && qe(e) == Sm } function xm(e) { return e === void 0 } var Tm = "Expected a function"; function ar(e, t, a) { var p = !0, v = !0; if (typeof e != "function") throw new TypeError(Tm); return De(a) && (p = "leading" in a ? !!a.leading : p, v = "trailing" in a ? !!a.trailing : v), tn(e, t, { leading: p, maxWait: t, trailing: v }) } const Om = { class: "save-box" }, km = Dt({ name: "save-bar" }), Am = Object.assign(km, { setup(e) { const { t } = Ke(), { canvasEditor: a } = zt(), p = { clipboard() { a.clipboard() }, saveJson() { a.saveJson() }, saveTemplate() { a.saveTemplate() }, saveSvg() { a.saveSvg() }, saveImg() { a.saveImg() }, exit() { window.location.href = "/admin/product" } }, v = tn(function (f) { p[f] && typeof p[f] == "function" && p[f]() }, 300), _ = () => { a.clear() }, b = () => { qt.Modal.confirm({ title: t("tip"), content: `<p>${t("clearTip")}</p>`, okText: t("ok"), cancelText: t("cancel"), onOk: () => _() }) }; return (f, r) => { const c = ut("Button"), h = ut("Icon"), n = ut("DropdownItem"), o = ut("DropdownMenu"), i = ut("Dropdown"); return lt(), mt("div", Om, [I(c, { style: { "margin-left": "10px" }, type: "text", onClick: b }, { default: G(() => [xt(yt(f.$t("empty")), 1)]), _: 1 }), I(i, { style: { "margin-left": "10px" }, onOnClick: j(v) }, { list: G(() => [I(o, null, { default: G(() => [I(n, { name: "clipboard" }, { default: G(() => [xt(yt(f.$t("copy_to_clipboard")), 1)]), _: 1 }), I(n, { name: "saveImg" }, { default: G(() => [xt(yt(f.$t("save_as_picture")), 1)]), _: 1 }), I(n, { name: "saveSvg" }, { default: G(() => [xt(yt(f.$t("save_as_svg")), 1)]), _: 1 }), I(n, { name: "saveJson", divided: "" }, { default: G(() => [xt(yt(f.$t("save_as_json")), 1)]), _: 1 }), I(n, { name: "saveTemplate", onClick: f.triggerReload, divided: "" }, { default: G(() => [xt(yt(f.$t("save_as_template")), 1)]), _: 1 }, 8, ["onClick"]), I(n, { name: "exit", divided: "" }, { default: G(() => [xt(yt(f.$t("exit")), 1)]), _: 1 })]), _: 1 })]), default: G(() => [I(c, { type: "primary" }, { default: G(() => [xt(yt(f.$t("keep")) + " ", 1), I(h, { type: "ios-arrow-down" })]), _: 1 })]), _: 1 }, 8, ["onOnClick"])]) } } }), Em = Yt(Am, [["__scopeId", "data-v-5af453c8"]]); const Pm = { class: "save-box" }, Mm = Dt({ name: "save-bar" }), jm = Object.assign(Mm, { setup(e) { const { t } = Ke(), { canvasEditor: a } = zt(), p = { clipboard() { a.clipboard() }, saveJson() { a.saveJson() }, saveTemplate() { a.saveTemplate() }, saveSvg() { a.saveSvg() }, saveImg() { a.saveImg() }, exit() { window.location.href = "/admin/product" } }; tn(function (r) { p[r] && typeof p[r] == "function" && p[r]() }, 300); const v = () => { a.clear() }, _ = () => { a.saveTemplate() }, b = () => { qt.Modal.confirm({ title: t("tip"), content: `<p>${t("clearTip")}</p>`, okText: t("ok"), cancelText: t("cancel"), onOk: () => v() }) }, f = () => { qt.Modal.confirm({ title: t("tip"), content: `<p>${t("saveBtn")}</p>`, okText: t("ok"), cancelText: t("cancel"), onOk: () => _() }) }; return (r, c) => { const h = ut("Button"); return lt(), mt("div", Pm, [I(h, { style: { "margin-left": "10px" }, type: "text", onClick: b }, { default: G(() => [xt(yt(r.$t("empty")), 1)]), _: 1 }), I(h, { type: "primary", style: { "margin-left": "10px" }, onClick: f }, { default: G(() => [xt(yt(r.$t("saveBtn")), 1)]), _: 1 })]) } } }), Dm = Yt(jm, [["__scopeId", "data-v-ba0f9830"]]), Lm = Dt({ name: "Clone" }), Fm = Object.assign(Lm, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(), p = tn(function () { a.clone() }, 300); return (v, _) => { const b = ut("Button"), f = ut("Tooltip"); return j(t).mSelectMode === "one" ? (lt(), Rt(f, { key: 0, content: v.$t("Copy") }, { default: G(() => [I(b, { onClick: j(p), icon: "ios-copy", type: "text" }, null, 8, ["onClick"])]), _: 1 }, 8, ["content"])) : At("", !0) } } }); const Ya = e => (me("data-v-bd68aac3"), e = e(), ve(), e), $m = { key: 0, class: "attr-item box" }, Im = Ya(() => S("svg", { t: "1650848913991", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "17131", width: "14", height: "14" }, [S("path", { d: "M341.333333 341.333333 341.333333 512 554.666667 512 554.666667 341.333333 341.333333 341.333333M42.666667 42.666667 213.333333 42.666667 213.333333 85.333333 810.666667 85.333333 810.666667 42.666667 981.333333 42.666667 981.333333 213.333333 938.666667 213.333333 938.666667 810.666667 981.333333 810.666667 981.333333 981.333333 810.666667 981.333333 810.666667 938.666667 213.333333 938.666667 213.333333 981.333333 42.666667 981.333333 42.666667 810.666667 85.333333 810.666667 85.333333 213.333333 42.666667 213.333333 42.666667 42.666667M213.333333 810.666667 213.333333 853.333333 810.666667 853.333333 810.666667 810.666667 853.333333 810.666667 853.333333 213.333333 810.666667 213.333333 810.666667 170.666667 213.333333 170.666667 213.333333 213.333333 170.666667 213.333333 170.666667 810.666667 213.333333 810.666667M256 256 640 256 640 426.666667 768 426.666667 768 768 341.333333 768 341.333333 597.333333 256 597.333333 256 256M640 597.333333 426.666667 597.333333 426.666667 682.666667 682.666667 682.666667 682.666667 512 640 512 640 597.333333Z", "p-id": "17132" })], -1)), Rm = Ya(() => S("svg", { t: "1650848938557", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "17281", width: "14", height: "14" }, [S("path", { d: "M85.333333 85.333333 256 85.333333 256 128 554.666667 128 554.666667 85.333333 725.333333 85.333333 725.333333 256 682.666667 256 682.666667 384 768 384 768 341.333333 938.666667 341.333333 938.666667 512 896 512 896 768 938.666667 768 938.666667 938.666667 768 938.666667 768 896 512 896 512 938.666667 341.333333 938.666667 341.333333 768 384 768 384 682.666667 256 682.666667 256 725.333333 85.333333 725.333333 85.333333 554.666667 128 554.666667 128 256 85.333333 256 85.333333 85.333333M768 512 768 469.333333 682.666667 469.333333 682.666667 554.666667 725.333333 554.666667 725.333333 725.333333 554.666667 725.333333 554.666667 682.666667 469.333333 682.666667 469.333333 768 512 768 512 810.666667 768 810.666667 768 768 810.666667 768 810.666667 512 768 512M554.666667 256 554.666667 213.333333 256 213.333333 256 256 213.333333 256 213.333333 554.666667 256 554.666667 256 597.333333 384 597.333333 384 512 341.333333 512 341.333333 341.333333 512 341.333333 512 384 597.333333 384 597.333333 256 554.666667 256M512 512 469.333333 512 469.333333 597.333333 554.666667 597.333333 554.666667 554.666667 597.333333 554.666667 597.333333 469.333333 512 469.333333 512 512Z", "p-id": "17282" })], -1)), Bm = Dt({ name: "Group" }), zm = Object.assign(Bm, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(); let p = Wt(() => t.mSelectMode === "one" && t.mSelectOneType === "group"), v = Wt(() => t.mSelectMode === "multiple"); const _ = () => { a.unGroup() }, b = () => { a.group() }; return (f, r) => { const c = ut("Button"); return j(v) || j(p) ? (lt(), mt("div", $m, [j(v) ? (lt(), Rt(c, { key: 0, disabled: !j(v), onClick: b, type: "text" }, { default: G(() => [Im, xt(" combination ")]), _: 1 }, 8, ["disabled"])) : At("", !0), j(p) ? (lt(), Rt(c, { key: 1, disabled: !j(p), onClick: _, type: "text" }, { default: G(() => [Rm, xt(" split combination ")]), _: 1 }, 8, ["disabled"])) : At("", !0)])) : At("", !0) } } }), Um = Yt(zm, [["__scopeId", "data-v-bd68aac3"]]); const Ga = e => (me("data-v-c577efce"), e = e(), ve(), e), Hm = { class: "box" }, Vm = Ga(() => S("svg", { t: "1650853919128", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "1271", width: "14", height: "14" }, [S("path", { d: "M970.837333 919.850667l-205.696-205.653334A382.421333 382.421333 0 0 0 853.333333 469.333333a384 384 0 0 0-384-384 384 384 0 0 0-384 384 384 384 0 0 0 384 384 382.421333 382.421333 0 0 0 244.906667-88.192l205.653333 205.653334a36.053333 36.053333 0 0 0 50.986667 0 36.266667 36.266667 0 0 0-0.042667-50.944z m-380.117333-162.986667c-38.4 16.256-79.189333 24.448-121.386667 24.448a311.296 311.296 0 0 1-220.586666-91.392A311.296 311.296 0 0 1 157.312 469.333333 311.296 311.296 0 0 1 248.746667 248.746667 311.296 311.296 0 0 1 469.333333 157.354667a311.296 311.296 0 0 1 220.586667 91.392A311.296 311.296 0 0 1 781.354667 469.333333a311.296 311.296 0 0 1-91.392 220.586667 310.186667 310.186667 0 0 1-99.242667 66.901333z", fill: "#595959", "p-id": "1272" }), S("path", { d: "M652.672 431.829333h-147.84V292.010667a35.968 35.968 0 1 0-71.978667 0v139.818666H292.010667a35.968 35.968 0 1 0 0 72.021334h140.8v140.8a35.968 35.968 0 1 0 72.021333 0v-140.8h147.84a35.968 35.968 0 1 0 0-72.021334z", fill: "#595959", "p-id": "1273" })], -1)), Nm = Ga(() => S("svg", { t: "1650853934351", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "1470", width: "14", height: "14" }, [S("path", { d: "M970.837333 919.850667l-205.696-205.653334A382.421333 382.421333 0 0 0 853.333333 469.333333a384 384 0 0 0-384-384 384 384 0 0 0-384 384 384 384 0 0 0 384 384 382.421333 382.421333 0 0 0 244.906667-88.192l205.653333 205.653334a36.053333 36.053333 0 0 0 50.986667 0 36.266667 36.266667 0 0 0-0.042667-50.944z m-380.117333-162.986667c-38.4 16.256-79.189333 24.448-121.386667 24.448a311.296 311.296 0 0 1-220.586666-91.392A311.296 311.296 0 0 1 157.312 469.333333 311.296 311.296 0 0 1 248.746667 248.746667 311.296 311.296 0 0 1 469.333333 157.354667a311.296 311.296 0 0 1 220.586667 91.392A311.296 311.296 0 0 1 781.354667 469.333333a311.296 311.296 0 0 1-91.392 220.586667 310.186667 310.186667 0 0 1-99.242667 66.901333z", fill: "#595959", "p-id": "1471" }), S("path", { d: "M652.672 431.829333H292.010667a35.968 35.968 0 1 0 0 72.021334h360.661333a35.968 35.968 0 1 0 0-72.021334z", fill: "#595959", "p-id": "1472" })], -1)), Wm = Dt({ name: "Zoom" }), Ym = Object.assign(Wm, { setup(e) { const { canvasEditor: t } = zt(), a = () => { t.one() }, p = () => { t.big() }, v = () => { t.small() }, _ = () => { t.auto() }; return (b, f) => { const r = ut("Button"), c = ut("ButtonGroup"); return lt(), mt("div", Hm, [I(c, null, { default: G(() => [I(r, { onClick: p }, { default: G(() => [Vm]), _: 1 }), I(r, { onClick: v }, { default: G(() => [Nm]), _: 1 }), I(r, { onClick: a, icon: "ios-expand" }), I(r, { onClick: _, icon: "md-contract" })]), _: 1 })]) } } }), Gm = Yt(Ym, [["__scopeId", "data-v-c577efce"]]); const Xm = e => (me("data-v-052d6344"), e = e(), ve(), e), Km = { class: "box" }, qm = Xm(() => S("span", null, "Drag", -1)), Jm = Dt({ name: "Drag" }), Zm = Object.assign(Jm, { setup(e) { const t = dt(!1), { canvasEditor: a } = zt(), p = v => { v ? a.startDring() : a.endDring() }; return ue(() => { a.on("startDring", () => t.value = !0), a.on("endDring", () => t.value = !1) }), In(() => { a.off("startDring"), a.off("endDring") }), (v, _) => { const b = ut("Switch"); return lt(), mt("div", Km, [I(b, { size: "large", modelValue: j(t), "onUpdate:modelValue": _[0] || (_[0] = f => Pt(t) ? t.value = f : null), onOnChange: p }, { open: G(() => [qm]), _: 1 }, 8, ["modelValue"])]) } } }), Qm = Yt(Zm, [["__scopeId", "data-v-052d6344"]]); const tv = Dt({ name: "Lock" }), ev = Object.assign(tv, { setup(e) { const t = Ue("event"), { mixinState: a, canvasEditor: p } = zt(), v = ["lockMovementX", "lockMovementY", "lockRotation", "lockScalingX", "lockScalingY"], _ = dt(!1), b = () => { a.mSelectActive.hasControls = !1, v.forEach(h => { a.mSelectActive[h] = !0 }), a.mSelectActive.selectable = !1, _.value = !0, p.canvas.renderAll() }, f = () => { a.mSelectActive.hasControls = !0, v.forEach(h => { a.mSelectActive[h] = !1 }), a.mSelectActive.selectable = !0, _.value = !1, p.canvas.renderAll() }, r = h => { h ? b() : f() }, c = h => { _.value = !h[0].hasControls, a.mSelectActive = h[0] }; return ue(() => { t.on("selectOne", c) }), In(() => { t.off("selectOne", c) }), (h, n) => { const o = ut("Button"), i = ut("Tooltip"); return j(a).mSelectMode === "one" ? (lt(), Rt(i, { key: 0, content: h.$t("Lock") }, { default: G(() => [j(_) ? (lt(), Rt(o, { key: 0, onClick: n[0] || (n[0] = s => r(!1)), icon: "md-lock", type: "text" })) : (lt(), Rt(o, { key: 1, onClick: n[1] || (n[1] = s => r(!0)), icon: "md-unlock", type: "text" }))]), _: 1 }, 8, ["content"])) : At("", !0) } } }), nv = Yt(ev, [["__scopeId", "data-v-7c05385f"]]), iv = Dt({ name: "Del" }), rv = Object.assign(iv, { setup(e) { const { mixinState: t, canvasEditor: a } = zt(), p = tn(function () { a.del() }, 300); return (v, _) => { const b = ut("Button"), f = ut("Tooltip"); return j(t).mSelectMode ? (lt(), Rt(f, { key: 0, content: v.$t("Delete") }, { default: G(() => [I(b, { onClick: j(p), icon: "ios-trash", type: "text" }, null, 8, ["onClick"])]), _: 1 }, 8, ["content"])) : At("", !0) } } }), sv = { class: "setting-item" }, ov = { class: "mr-10px" }, av = { class: "setting-item" }, lv = { class: "mr-10px" }, cv = { class: "setting-item" }, uv = { class: "mr-10px" }, hv = { class: "setting-item" }, fv = { class: "mr-10px" }, dv = Dt({ name: "WaterMark" }), pv = Dt(Ut(Et({}, dv), { setup(e) { const { canvasEditor: t } = zt(), a = ee({ text: "", size: 24, isRotate: 0, font: "serif", color: "#ccc", position: "lt" }), p = dt(!1), v = () => { a.text = "", a.size = 24, a.font = "serif", a.color = "#ccc", a.position = "lt", a.isRotate = 0 }, _ = (c, h) => { const n = document.createElement("canvas"); return n.width = c, n.height = h, n.style.position = "fixed", n.style.opacity = "0", n.style.zIndex = "-1", n }, b = { lt: (c, h, n) => { let o = _(c, h); const i = o.width || c; let s = o.getContext("2d"); s.fillStyle = a.color, s.font = `${a.size}px ${a.font}`, s.fillText(a.text, 10, a.size + 10, i - 20), n && n(o.toDataURL()), o = null, s = null }, rt: (c, h, n) => { let o = _(c, h), i = o.getContext("2d"); const s = o.width || c; i.fillStyle = a.color, i.font = `${a.size}px ${a.font}`, i.fillText(a.text, s - i.measureText(a.text).width - 20, a.size + 10, s - 20), n && n(o.toDataURL()), o = null, i = null }, lb: (c, h, n) => { let o = _(c, h), i = o.getContext("2d"); const s = o.width || c, u = o.height || h; i.fillStyle = a.color, i.font = `${a.size}px ${a.font}`, i.fillText(a.text, 10, u - a.size, s - 20), n && n(o.toDataURL()), o = null, i = null }, rb: (c, h, n) => { let o = _(c, h), i = o.getContext("2d"); const s = o.width || c; i.fillStyle = a.color, i.font = `${a.size}px ${a.font}`, i.fillText(a.text, s - i.measureText(a.text).width - 20, h - a.size, c - 20), n && n(o.toDataURL()), o = null, i = null }, full: (c, h, n) => { let o = _(c, h), i = o.getContext("2d"); const s = i.measureText(a.text).width + 40; let u = _(a.isRotate === 0 ? s : s * 2, a.isRotate === 0 ? a.size + 20 : s + 20); document.body.appendChild(u); let l = u.getContext("2d"); l.textAlign = "left", l.textBaseline = "top", l.font = `${a.size}px ${a.font}`, l.fillStyle = `${a.color}`, a.isRotate === 0 ? l.fillText(a.text, 10, 10) : (l.translate(0, s - 10), l.rotate(-30 * Math.PI / 180), l.fillText(a.text, 0, 0)), i.fillStyle = i.createPattern(u, "repeat"), i.fillRect(0, 0, c, h), n && n(o.toDataURL()), o = null, u = null, i = null, l = null } }, f = () => { if (!a.text) return qt.Message.warning("Watermark name cannot be empty"); const c = t.canvas.getObjects().find(s => s.id === "workspace"), { width: h, height: n, left: o, top: i } = c; b[a.position](h, n, s => { t.canvas.overlayImage = null, t.canvas.setOverlayImage(s, t.canvas.renderAll.bind(t.canvas), { left: o || 0, top: i || 0, originX: "left", originY: "top" }) }), v() }, r = tn(function () { p.value = !0 }, 250); return (c, h) => { const n = ut("Button"), o = ut("Input"), i = ut("Slider"), s = ut("Radio"), u = ut("RadioGroup"), l = ut("Modal"); return lt(), mt(te, null, [I(n, { type: "text", onClick: j(r) }, { default: G(() => [xt(yt(c.$t("waterMark.text")), 1)]), _: 1 }, 8, ["onClick"]), I(l, { modelValue: j(p), "onUpdate:modelValue": h[4] || (h[4] = d => Pt(p) ? p.value = d : null), title: c.$t("waterMark.modalTitle"), onOnOk: f, onOnCancel: v }, { default: G(() => [S("div", sv, [S("span", ov, yt(c.$t("waterMark.setting.name")), 1), I(o, { class: "w-320", modelValue: j(a).text, "onUpdate:modelValue": h[0] || (h[0] = d => j(a).text = d), maxlength: "15", "show-word-limit": "", placeholder: c.$t("placeholder") }, null, 8, ["modelValue", "placeholder"])]), S("div", av, [S("span", lv, yt(c.$t("waterMark.setting.size")), 1), I(i, { class: "w-320", modelValue: j(a).size, "onUpdate:modelValue": h[1] || (h[1] = d => j(a).size = d), min: 18, max: 48 }, null, 8, ["modelValue"])]), S("div", cv, [S("span", uv, yt(c.$t("waterMark.setting.position.label")), 1), I(u, { modelValue: j(a).position, "onUpdate:modelValue": h[2] || (h[2] = d => j(a).position = d) }, { default: G(() => [I(s, { label: "lt" }, { default: G(() => [xt(yt(c.$t("waterMark.setting.position.lt")), 1)]), _: 1 }), I(s, { label: "rt" }, { default: G(() => [xt(yt(c.$t("waterMark.setting.position.rt")), 1)]), _: 1 }), I(s, { label: "lb" }, { default: G(() => [xt(yt(c.$t("waterMark.setting.position.lb")), 1)]), _: 1 }), I(s, { label: "rb" }, { default: G(() => [xt(yt(c.$t("waterMark.setting.position.rb")), 1)]), _: 1 }), I(s, { label: "full" }, { default: G(() => [xt(yt(c.$t("waterMark.setting.position.full")), 1)]), _: 1 })]), _: 1 }, 8, ["modelValue"])]), Ct(S("div", hv, [S("span", fv, yt(c.$t("waterMark.setting.angle")), 1), S("div", null, [I(u, { modelValue: j(a).isRotate, "onUpdate:modelValue": h[3] || (h[3] = d => j(a).isRotate = d) }, { default: G(() => [I(s, { label: 0 }, { default: G(() => [xt("Horizontal")]), _: 1 }), I(s, { label: 1 }, { default: G(() => [xt("Tilt")]), _: 1 })]), _: 1 }, 8, ["modelValue"])])], 512), [[pe, j(a).position === "full"]])]), _: 1 }, 8, ["modelValue", "title"])], 64) } } })); const gv = Yt(pv, [["__scopeId", "data-v-a755ea0d"]]), mv = { class: "search-box" }, vv = ["alt", "onClick"], _v = Dt({ name: "ImportTmpl" }), yv = Dt(Ut(Et({}, _v), { setup(e) { const { t } = Ke(), { canvasEditor: a } = zt(), p = { value: "", label: "all" }, v = ee({ search: "", placeholder: "", frontJson: null, backJson: null, materialType: [""], materialTypelist: [], materialist: [] }); a.getMaterialType("template").then(n => { v.materialTypelist = [...n], v.materialist = n }); const _ = n => { console.log(n), qt.Modal.confirm({ title: t("Warning"), content: `<p>${t("replaceTip")}</p>`, okText: t("ok"), cancelText: t("cancel"), onOk: () => f(n) }) }, b = () => { a.waitForSharedState() }, f = n => { qt.Spin.show({ render: i => i("div", t("alert.loading_data")) }); const o = Te.get(n); console.log(o), o.then(i => { const { data: s } = i.data; console.log(i.data), s && s.front ? (Ot.front = s.front, Ot.back = s.back, Ot.frontImgUrl = s.frontImgUrl, Ot.position = s.position, Ot.backImgUrl = s.backImgUrl, console.log(Ot.front), a.insertSvgString(Ot.front), b(), qt.Spin.hide()) : (console.error("Invalid or empty front data"), qt.Spin.hide()) }).catch(i => { console.error("Error fetching data:", i), qt.Spin.hide() }) }, r = (n, o) => { const { label: i, value: s } = o[0]; v.placeholder = i, v.search = "", c(s) }, c = n => { if (!n) v.materialist = ui(v.materialTypelist); else { const o = v.materialTypelist.filter(i => i.value === n) || []; v.materialist = o } if (v.search) { const o = ui(v.materialist); v.materialist = o.map(i => (i.list && (i.list = i.list.filter(s => s.label.includes(v.search))), i)) } }, h = () => { const [n] = v.materialType; c(n) }; return (n, o) => { const i = ut("Button"), s = ut("Cascader"), u = ut("Input"), l = ut("Divider"), d = ut("Tooltip"), g = pi("lazy"); return lt(), mt("div", null, [S("div", mv, [I(s, { data: [p, ...j(v).materialTypelist], modelValue: j(v).materialType, "onUpdate:modelValue": o[0] || (o[0] = m => j(v).materialType = m), onOnChange: r }, { default: G(() => [I(i, { icon: "ios-menu" })]), _: 1 }, 8, ["data", "modelValue"]), I(u, { class: "input", placeholder: j(v).placeholder, modelValue: j(v).search, "onUpdate:modelValue": o[1] || (o[1] = m => j(v).search = m), search: "", onOnChange: h }, null, 8, ["placeholder", "modelValue"])]), (lt(!0), mt(te, null, ce(j(v).materialist, m => (lt(), mt("div", { key: m.value }, [I(l, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(m.label), 1)]), _: 2 }, 1024), (lt(!0), mt(te, null, ce(m.list, (y, w) => (lt(), Rt(d, { content: y.label, key: `${w}-bai1-button`, placement: "top" }, { default: G(() => [Ct(S("img", { class: "tmpl-img", alt: y.label, onClick: C => _(y.tempUrl) }, null, 8, vv), [[g, y.src]])]), _: 2 }, 1032, ["content"]))), 128))]))), 128))]) } } })); const bv = Yt(yv, [["__scopeId", "data-v-b3281b05"]]), Xa = (e, t) => { const a = [], p = Math.PI * 2 / e; let v = -Math.PI / 2; e % 2 === 0 && (v += p / 2); for (let _ = 0; _ < e; _++) { const b = _ * p + v; a.push({ x: Math.cos(b) * t, y: Math.sin(b) * t }) } return a }; const en = e => (me("data-v-5ce8ff29"), e = e(), ve(), e), wv = { class: "tool-box" }, Cv = en(() => S("svg", { t: "1650875455324", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "5401", width: "26", height: "26" }, [S("path", { d: "M213.333333 209.92v128h85.333334v-42.666667h170.666666v433.493334H384.853333v85.333333h256v-85.333333H554.666667V295.253333h170.666666v42.666667h85.333334v-128H213.333333z", "p-id": "5402" })], -1)), Sv = [Cv], xv = en(() => S("svg", { t: "1650855811131", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "18499", width: "26", height: "26" }, [S("path", { d: "M864 896H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h704a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zM192 832h640V192H192v640z", "p-id": "18500" })], -1)), Tv = [xv], Ov = en(() => S("svg", { t: "1650855860236", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "19440", width: "26", height: "26" }, [S("path", { d: "M512 928C282.624 928 96 741.376 96 512S282.624 96 512 96s416 186.624 416 416-186.624 416-416 416z m0-768C317.92 160 160 317.92 160 512s157.92 352 352 352 352-157.92 352-352S706.08 160 512 160z", "p-id": "19441" })], -1)), kv = [Ov], Av = en(() => S("svg", { t: "1650874633978", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "2032", width: "26", height: "26" }, [S("path", { d: "M928.64 896a2.144 2.144 0 0 1-0.64 0H96a32.032 32.032 0 0 1-27.552-48.288l416-704c11.488-19.456 43.552-19.456 55.104 0l413.152 699.2A31.936 31.936 0 0 1 928.64 896zM152.064 832h719.84L512 222.912 152.064 832z", "p-id": "2033" })], -1)), Ev = [Av], Pv = en(() => S("svg", { t: "1650874633978", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "2032", width: "26", height: "26" }, [S("path", { d: "M161.152 398.016l134.016 412.416h433.664l134.016-412.416L512 143.104 161.152 398.08zM512 64l426.048 309.568-162.752 500.864H248.704L85.952 373.568 512 64z", "p-id": "2033" })], -1)), Mv = [Pv], jv = { class: "tool-box" }, Dv = en(() => S("svg", { t: "1673022047861", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "4206", width: "20", height: "20" }, [S("path", { d: "M187.733333 1024h-170.666666c-10.24 0-17.066667-6.826667-17.066667-17.066667v-170.666666c0-10.24 6.826667-17.066667 17.066667-17.066667h170.666666c10.24 0 17.066667 6.826667 17.066667 17.066667v170.666666c0 10.24-6.826667 17.066667-17.066667 17.066667zM34.133333 989.866667h136.533334v-136.533334H34.133333v136.533334zM1006.933333 204.8h-170.666666c-10.24 0-17.066667-6.826667-17.066667-17.066667v-170.666666c0-10.24 6.826667-17.066667 17.066667-17.066667h170.666666c10.24 0 17.066667 6.826667 17.066667 17.066667v170.666666c0 10.24-6.826667 17.066667-17.066667 17.066667zM853.333333 170.666667h136.533334V34.133333h-136.533334v136.533334z", fill: "", "p-id": "4207" }), S("path", { d: "M187.733333 853.333333c-3.413333 0-10.24 0-13.653333-3.413333-6.826667-6.826667-6.826667-17.066667 0-23.893333l648.533333-648.533334c6.826667-6.826667 17.066667-6.826667 23.893334 0s6.826667 17.066667 0 23.893334l-648.533334 648.533333c0 3.413333-6.826667 3.413333-10.24 3.413333z", fill: "", "p-id": "4208" })], -1)), Lv = [Dv], Fv = en(() => S("svg", { t: "1673026778912", class: "icon", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "2659", width: "20", height: "20" }, [S("path", { d: "M320 738.133333L827.733333 230.4l-29.866666-29.866667L290.133333 708.266667v-268.8h-42.666666v341.333333h341.333333v-42.666667H320z", fill: "#444444", "p-id": "2660" })], -1)), $v = [Fv], Iv = Dt({ name: "Tools" }), Rv = Object.assign(Iv, { setup(e) { const t = { shadow: "", fontFamily: "arial" }, a = { left: 0, top: 0 }, { t: p } = Ke(), { fabric: v, canvasEditor: _ } = zt(), b = ee({ isDrawingLineMode: !1, isArrow: !1 }), f = s => { const u = new v.IText(p("Text"), Ut(Et(Et({}, t), s), { fontSize: 500, id: Jt(), hasControls: !1 })); _.canvas.add(u), s || u.center(), _.canvas.setActiveObject(u) }, r = s => { const u = new v.Triangle(Ut(Et(Et({}, t), s), { width: 800, height: 800, fill: "transparent", stroke: "#000000", strokeWidth: 2, id: Jt(), name: "Triangle" })); _.canvas.add(u), s || u.center(), _.canvas.setActiveObject(u) }, c = s => { const u = new v.Polygon(Xa(5, 200), Ut(Et(Et({}, t), s), { fill: "transparent", stroke: "#000000", strokeWidth: 2, id: Jt(), name: "Polygon" })); u.set({ width: 800, height: 800, pathOffset: { x: 0, y: 0 } }), _.canvas.add(u), s || u.center(), _.canvas.setActiveObject(u) }, h = s => { const u = new v.Circle(Ut(Et(Et({}, t), s), { radius: 150, fill: "transparent", stroke: "#000000", strokeWidth: 2, id: Jt(), name: "Round" })); _.canvas.add(u), s || u.center(), _.canvas.setActiveObject(u) }, n = s => { const u = new v.Rect(Ut(Et(Et({}, t), s), { fill: "transparent", strokeWidth: 2, stroke: "#000000", width: 800, height: 800, id: Jt(), name: "Rectangle" })); _.canvas.add(u), s || u.center(), _.canvas.setActiveObject(u) }, o = s => { b.isArrow = s, b.isDrawingLineMode = !b.isDrawingLineMode, _.setMode(b.isDrawingLineMode), _.setArrow(s), _.canvas.forEachObject(u => { u.id !== "workspace" && (u.selectable = !b.isDrawingLineMode, u.evented = !b.isDrawingLineMode) }) }, i = s => { switch (s) { case "text": f(a); break; case "rect": n(a); break; case "circle": h(a); break; case "triangle": r(a); break; case "polygon": c(a); break } }; return ue(() => { No(() => { _.canvas.on("drop", s => { const u = { left: _.canvas.getSelectionElement().getBoundingClientRect().left, top: _.canvas.getSelectionElement().getBoundingClientRect().top }, l = { x: s.e.x - u.left, y: s.e.y - u.top }, d = _.canvas.restorePointerVpt(l); a.left = d.x, a.top = d.y }) }) }), (s, u) => { const l = ut("Divider"); return lt(), mt("div", null, [I(l, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(s.$t("common_elements")), 1)]), _: 1 }), S("div", wv, [S("span", { onClick: u[0] || (u[0] = () => f()), draggable: !0, onDragend: u[1] || (u[1] = d => i("text")) }, Sv, 32), S("span", { onClick: u[2] || (u[2] = () => n()), draggable: !0, onDragend: u[3] || (u[3] = d => i("rect")) }, Tv, 32), S("span", { onClick: u[4] || (u[4] = () => h()), draggable: !0, onDragend: u[5] || (u[5] = d => i("circle")) }, kv, 32), S("span", { onClick: u[6] || (u[6] = () => r()), draggable: !0, onDragend: u[7] || (u[7] = d => i("triangle")) }, Ev, 32), S("span", { onClick: u[8] || (u[8] = () => c()), draggable: !0, onDragend: u[9] || (u[9] = d => i("polygon")) }, Mv, 32)]), I(l, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(s.$t("draw_elements")), 1)]), _: 1 }), S("div", jv, [S("span", { onClick: u[10] || (u[10] = d => o(!1)), class: he(j(b).isDrawingLineMode && !j(b).isArrow && "bg") }, Lv, 2), S("span", { onClick: u[11] || (u[11] = d => o(!0)), class: he(j(b).isDrawingLineMode && j(b).isArrow && "bg") }, $v, 2)])]) } } }), Bv = Yt(Rv, [["__scopeId", "data-v-5ce8ff29"]]), zv = { class: "search-box" }, Uv = ["alt"], Hv = Dt({ name: "ImportSvg" }), Vv = Dt(Ut(Et({}, Hv), { setup(e) { const { fabric: t, canvasEditor: a } = zt(), p = { left: 100, top: 100, shadow: "", fontFamily: "1-1" }, v = { value: "", label: "all" }, _ = ee({ search: "", placeholder: "", jsonFile: null, materialType: [""], materialTypelist: [], materialist: [] }); a.getMaterialType("svg").then(n => { _.materialTypelist = [...n], _.materialist = n }); const b = (n, o) => { const { label: i, value: s } = o[0]; _.placeholder = i, _.search = "", f(s) }, f = n => { if (!n) _.materialist = ui(_.materialTypelist); else { const o = _.materialTypelist.filter(i => i.value === n) || []; _.materialist = o } if (_.search) { const o = ui(_.materialist); _.materialist = o.map(i => (i.list && (i.list = i.list.filter(s => s.label.includes(_.search))), i)) } }, r = () => { const [n] = _.materialType; f(n) }, c = n => { const o = n.target.src; t.loadSVGFromURL(o, i => { const s = t.util.groupSVGElements(i, { shadow: "", fontFamily: "arial", id: Jt(), name: "SVG Element" }); a.dragAddItem(n, s) }) }, h = n => { const o = n.target.src; t.loadSVGFromURL(o, (i, s) => { const u = t.util.groupSVGElements(i, Ut(Et(Et({}, s), p), { id: Jt(), name: "svg element" })); a.canvas.add(u), a.canvas.setActiveObject(u), a.canvas.requestRenderAll() }) }; return (n, o) => { const i = ut("Button"), s = ut("Cascader"), u = ut("Input"), l = ut("Divider"), d = ut("Tooltip"), g = pi("lazy"); return lt(), mt("div", null, [S("div", zv, [I(s, { data: [v, ...j(_).materialTypelist], modelValue: j(_).materialType, "onUpdate:modelValue": o[0] || (o[0] = m => j(_).materialType = m), onOnChange: b }, { default: G(() => [I(i, { icon: "ios-menu" })]), _: 1 }, 8, ["data", "modelValue"]), I(u, { class: "input", placeholder: j(_).placeholder, modelValue: j(_).search, "onUpdate:modelValue": o[1] || (o[1] = m => j(_).search = m), search: "", onOnChange: r }, null, 8, ["placeholder", "modelValue"])]), (lt(!0), mt(te, null, ce(j(_).materialist, m => (lt(), mt("div", { key: m.value }, [I(l, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(m.label), 1)]), _: 2 }, 1024), (lt(!0), mt(te, null, ce(m.list, (y, w) => (lt(), Rt(d, { content: y.label, key: `${w}-bai1-button`, placement: "top" }, { default: G(() => [Ct(S("img", { class: "tmpl-img", alt: y.label, onClick: h, onDragend: c }, null, 40, Uv), [[g, y.src]])]), _: 2 }, 1032, ["content"]))), 128))]))), 128))]) } } })); const Nv = Yt(Vv, [["__scopeId", "data-v-95513dda"]]); const Wv = { setup() { Ke(); const { mixinState: e, canvasEditor: t } = zt(), a = [], p = dt("rgb(255, 255, 255)"); var v = dt(0), _ = dt(0), b = dt(0), f = dt(0); dt("#311B92"); const r = dt("white"), c = () => { const i = v.value / 100, s = _.value / 100, u = b.value / 100, l = f.value / 100, d = Math.round(255 * (1 - i) * (1 - l)), g = Math.round(255 * (1 - s) * (1 - l)), m = Math.round(255 * (1 - u) * (1 - l)); return p.value = `rgb(${d}, ${g}, ${m})`, `rgb(${d}, ${g}, ${m})` }; de([v, _, b, f], ([i, s, u, l]) => { const d = c(); h(d) }); const h = i => { t.canvas.getObjects().find(u => u.id === "workspace").set("fill", i), t.canvas.renderAll() }; return { mixinState: e, colorList: a, color: p, c: v, m: _, y: b, k: f, convertCMYKtoRGB: c, convertHEXtoRGB: i => { const s = i.replace("#", ""), u = parseInt(s, 16), l = u >> 16 & 255, d = u >> 8 & 255, g = u & 255, m = l / 255, y = d / 255, w = g / 255, C = Math.min(1 - m, 1 - y, 1 - w); v.value = Math.round((1 - m - C) / (1 - C) * 100), _.value = Math.round((1 - y - C) / (1 - C) * 100), b.value = Math.round((1 - w - C) / (1 - C) * 100), f.value = Math.round(C * 100) }, restCMYK: () => { v.value = 0, _.value = 0, b.value = 0, f.value = 0, console.log("test") }, boxColor: r, colors: ["#311B92", "#512DA8", "#673AB7", "#9575CD", "#D1C4E9"] } } }, $e = e => (me("data-v-1dbb48cc"), e = e(), ve(), e), Yv = { key: 0 }, Gv = { class: "cmyk-inputs" }, Xv = { class: "custom-slider" }, Kv = $e(() => S("div", { class: "slider-component" }, [S("label", { for: "cInput" }, [S("b", null, "C")])], -1)), qv = { class: "slider-component-cyan" }, Jv = { class: "slider-component" }, Zv = $e(() => S("span", null, [S("b", null, " %")], -1)), Qv = { class: "custom-slider" }, t1 = $e(() => S("div", { class: "slider-component" }, [S("label", { for: "mInput" }, [S("b", null, "M")])], -1)), e1 = { class: "slider-component-magenta" }, n1 = { class: "slider-component" }, i1 = $e(() => S("span", null, [S("b", null, " %")], -1)), r1 = { class: "custom-slider" }, s1 = $e(() => S("div", { class: "slider-component" }, [S("label", { for: "yInput" }, [S("b", null, "Y")])], -1)), o1 = { class: "slider-component-yellow" }, a1 = { class: "slider-component" }, l1 = $e(() => S("span", null, [S("b", null, " %")], -1)), c1 = { class: "custom-slider" }, u1 = $e(() => S("div", { class: "slider-component" }, [S("label", { for: "kInput" }, [S("b", null, "K")])], -1)), h1 = { class: "slider-component-key" }, f1 = { class: "slider-component" }, d1 = $e(() => S("span", null, [S("b", null, " %")], -1)), p1 = $e(() => S("p", null, "Remove", -1)), g1 = [p1]; function m1(e, t, a, p, v, _) { const b = ut("Divider"), f = ut("ColorPicker"); return p.mixinState.mSelectMode ? At("", !0) : (lt(), mt("div", Yv, [I(b, { orientation: "left", plain: "" }, { default: G(() => [xt(yt(e.$t("Color")), 1)]), _: 1 }), S("div", Gv, [I(f, { modelValue: p.color, "onUpdate:modelValue": t[0] || (t[0] = r => p.color = r), colors: p.colors, onOnChange: p.convertHEXtoRGB, basic: "" }, null, 8, ["modelValue", "colors", "onOnChange"]), S("div", Xv, [Kv, S("div", qv, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: t[1] || (t[1] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[2] || (t[2] = r => p.c = r), "show-input": "" }, null, 544), [[Mt, p.c, void 0, { number: !0 }]])]), S("div", Jv, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: t[3] || (t[3] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[4] || (t[4] = r => p.c = r), "show-input": "" }, null, 544), [[Mt, p.c, void 0, { number: !0 }]]), Zv])]), S("div", Qv, [t1, S("div", e1, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: t[5] || (t[5] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[6] || (t[6] = r => p.m = r), "show-input": "" }, null, 544), [[Mt, p.m, void 0, { number: !0 }]])]), S("div", n1, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: t[7] || (t[7] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[8] || (t[8] = r => p.m = r), "show-input": "" }, null, 544), [[Mt, p.m, void 0, { number: !0 }]]), i1])]), S("div", r1, [s1, S("div", o1, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: t[9] || (t[9] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[10] || (t[10] = r => p.y = r), "show-input": "" }, null, 544), [[Mt, p.y, void 0, { number: !0 }]])]), S("div", a1, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: t[11] || (t[11] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[12] || (t[12] = r => p.y = r), "show-input": "" }, null, 544), [[Mt, p.y, void 0, { number: !0 }]]), l1])]), S("div", c1, [u1, S("div", h1, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: t[13] || (t[13] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[14] || (t[14] = r => p.k = r), "show-input": "" }, null, 544), [[Mt, p.k, void 0, { number: !0 }]])]), S("div", f1, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: t[15] || (t[15] = (...r) => p.convertCMYKtoRGB && p.convertCMYKtoRGB(...r)), "onUpdate:modelValue": t[16] || (t[16] = r => p.k = r), "show-input": "" }, null, 544), [[Mt, p.k, void 0, { number: !0 }]]), d1])]), S("button", { class: "no-color-button", onClick: t[17] || (t[17] = (...r) => p.restCMYK && p.restCMYK(...r)) }, g1)])])) } const v1 = Yt(Wv, [["render", m1], ["__scopeId", "data-v-1dbb48cc"]]); const _1 = { key: 0 }, y1 = { key: 0 }, b1 = Dt({ name: "CanvasSize" }), w1 = Object.assign(b1, { setup(e) { const t = Or(), a = Wt(() => t.state.templateHeight), p = Wt(() => t.state.templateWidth), v = Wt(() => t.state.role); ue(() => ie(this, null, function* () { try { yield t.dispatch("fetchDataFromLaravel"), f.setSize(p.value * 96, a.value * 96), n.role = v.value, console.log("test role", v.value), console.log("test modal", n.role) } catch (m) { console.error("Error fetching data from Laravel:", m) } })); const { mixinState: b, canvasEditor: f } = zt(), { t: r } = Ke(), c = { width: p, height: a }, h = dt(!1), n = ee({ width: c.width, height: c.height, role: !1 }); let o = dt(c.width), i = dt(c.height), s = ee([{ label: r("red_book_vertical"), width: 900, height: 1200 }, { label: r("red_book_horizontal"), width: 1200, height: 900 }, { label: r("phone_wallpaper"), width: 1080, height: 1920 }, { label: "kindle", width: 1200, height: 860 }, { label: "kindle-resize", width: 860, height: 1200 }]); ue(() => { f.setSize(o.value * 96, i.value * 96), f.on("sizeChange", (m, y) => { m.value = m, y.value = y }) }); const u = (m, y) => { n.width = m, n.height = y }, l = () => { const m = o.value * 96, y = i.value * 96; f.setSize(m, y) }, d = () => { h.value = !1 }, g = () => { const m = n.width * 96, y = n.height * 96; o.value = n.width, i.value = n.height, f.setSize(m, y), d() }; return (m, y) => { const w = ut("Divider"), C = ut("InputNumber"), T = ut("FormItem"), A = ut("Form"), U = ut("Button"), R = ut("ButtonGroup"); return j(b).mSelectMode ? At("", !0) : (lt(), mt("div", _1, [j(n).role ? (lt(), mt("div", y1, [I(w, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(m.$t("size")) + " (Inch)", 1)]), _: 1 }), I(A, { "label-width": 40, class: "form-wrap" }, { default: G(() => [I(T, { label: m.$t("width"), prop: "name" }, { default: G(() => [I(C, { modelValue: j(o), "onUpdate:modelValue": y[0] || (y[0] = $ => Pt(o) ? o.value = $ : o = $), onOnChange: l }, null, 8, ["modelValue"])]), _: 1 }, 8, ["label"]), I(T, { label: m.$t("height"), prop: "name" }, { default: G(() => [I(C, { modelValue: j(i), "onUpdate:modelValue": y[1] || (y[1] = $ => Pt(i) ? i.value = $ : i = $), onOnChange: l }, null, 8, ["modelValue"])]), _: 1 }, 8, ["label"])]), _: 1 }), I(U, { type: "primary", onClick: y[2] || (y[2] = () => h.value = !0) }, { default: G(() => [xt("Resize")]), _: 1 })])) : At("", !0), I(j(qt.Modal), { modelValue: j(h), "onUpdate:modelValue": y[5] || (y[5] = $ => Pt(h) ? h.value = $ : null), title: m.$t("setSizeTip"), onOnOk: g, onOnCancel: d }, { default: G(() => [S("p", null, yt(m.$t("default_size")), 1), I(R, { vertical: "", style: { margin: "10px 0" } }, { default: G(() => [(lt(!0), mt(te, null, ce(j(s), ($, L) => (lt(), Rt(U, { key: `${L}presetSize`, size: "small", style: { "text-align": "left" }, onClick: B => u($.width, $.height) }, { default: G(() => [xt(yt($.label) + ":" + yt($.width) + "x" + yt($.height), 1)]), _: 2 }, 1032, ["onClick"]))), 128))]), _: 1 }), I(A, { "label-width": 40, class: "form-wrap", style: { "justify-content": "flex-start" } }, { default: G(() => [I(T, { label: m.$t("width"), prop: "name", style: { "margin-right": "10px" } }, { default: G(() => [I(C, { min: 1, max: 5e3, modelValue: j(n).width, "onUpdate:modelValue": y[3] || (y[3] = $ => j(n).width = $) }, null, 8, ["modelValue"])]), _: 1 }, 8, ["label"]), I(T, { label: m.$t("height"), prop: "name" }, { default: G(() => [I(C, { min: 1, modelValue: j(n).height, "onUpdate:modelValue": y[4] || (y[4] = $ => j(n).height = $) }, null, 8, ["modelValue"])]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["modelValue", "title"])])) } } }), C1 = Yt(w1, [["__scopeId", "data-v-c95043d8"]]), S1 = { key: 0, class: "box attr-item" }, x1 = Dt({ name: "ReplaceImg" }), T1 = Object.assign(x1, { setup(e) { const t = di(), a = Ue("event"), { mixinState: p, canvasEditor: v } = zt(), _ = dt(""), b = () => ie(this, null, function* () { const r = v.canvas.getActiveObjects()[0]; if (r && r.type === "image") { const [c] = yield kn({ accept: "image/*", multiple: !1 }), h = yield li(c), n = yield Kc(h), o = r.get("width"), i = r.get("height"), s = r.get("scaleX"), u = r.get("scaleY"); r.setSrc(n.src, () => { r.set("scaleX", o * s / n.width), r.set("scaleY", i * u / n.height), v.canvas.renderAll() }), n.remove() } }), f = () => { var c; const r = v.canvas.getActiveObjects()[0]; r && (_.value = r.type, (c = t == null ? void 0 : t.proxy) == null || c.$forceUpdate()) }; return ue(() => { a.on("selectOne", f) }), In(() => { a.off("selectOne", f) }), (r, c) => { const h = ut("Button"); return j(p).mSelectMode === "one" && j(_) === "image" ? (lt(), mt("div", S1, [I(h, { onClick: b, type: "text", long: "" }, { default: G(() => [xt(yt(r.$t("repleaceImg")), 1)]), _: 1 })])) : At("", !0) } } }), O1 = "/editor/assets/BlackWhite-f7b682f8.png", k1 = "/editor/assets/Brownie-e1fd7075.png", A1 = "/editor/assets/Invert-5af1c3a4.png", E1 = "/editor/assets/Kodachrome-2b49b22c.png", P1 = "/editor/assets/Polaroid-9023c2a3.png", M1 = "/editor/assets/Sepia-2ff95c35.png", j1 = "/editor/assets/Vintage-f02e23f3.png", D1 = "/editor/assets/technicolor-48049f1e.png", ne = { SELECT: "select", COLOR: "color", NUMBER: "number" }, Gs = [{ type: "Brightness", status: !1, params: [{ key: "brightness", value: 0, uiType: ne.NUMBER, min: -1, max: 1, step: .01 }] }, { type: "Contrast", status: !1, params: [{ key: "contrast", value: 0, uiType: ne.NUMBER, min: -1, max: 1, step: .01 }] }, { type: "Saturation", status: !1, params: [{ key: "saturation", value: 0, uiType: ne.NUMBER, min: -1, max: 1, step: .01 }] }, { type: "Vibrance", status: !1, params: [{ key: "vibrance", value: 0, uiType: ne.NUMBER, min: -1, max: 1, step: .01 }] }, { type: "HueRotation", status: !1, params: [{ key: "rotation", value: 0, uiType: ne.NUMBER, min: -1, max: 1, step: .01 }] }, { type: "Noise", status: !1, params: [{ key: "noise", value: 0, uiType: ne.NUMBER, min: -1, max: 1e3, step: .1 }] }, { type: "Pixelate", status: !1, params: [{ key: "blocksize", value: .01, uiType: ne.NUMBER, min: .01, max: 100, step: .01 }] }, { type: "Blur", status: !1, params: [{ key: "blur", value: 0, uiType: ne.NUMBER, min: 0, max: 1, step: .01 }] }, { type: "Grayscale", status: !1, params: [{ key: "mode", value: "average", uiType: ne.SELECT, list: ["average", "lightness", "luminosity"] }] }, { type: "RemoveColor", status: !1, params: [{ key: "color", value: "", uiType: ne.COLOR }, { key: "distance", value: 0, uiType: ne.NUMBER, min: 0, max: 1, step: .01 }] }], Xs = [{ type: "Gamma", status: !1, params: [{ key: "red", value: 0, uiType: ne.NUMBER, min: .01, max: 2.2, step: .01 }, { key: "green", value: 0, uiType: ne.NUMBER, min: .01, max: 2.2, step: .01 }, { key: "blue", value: 0, uiType: ne.NUMBER, min: .01, max: 2.2, step: .01 }], handler(e, t, a) { return { gamma: [e, t, a] } } }]; const L1 = { key: 0, class: "box" }, F1 = { class: "filter-box" }, $1 = ["src", "onClick"], I1 = { key: 0, class: "content" }, R1 = { key: 0 }, B1 = { key: 1 }, z1 = { key: 2 }, U1 = Dt({ name: "Filter" }), H1 = Object.assign(U1, { setup(e) { const { fabric: t, mixinState: a, canvasEditor: p } = zt(), v = Ue("event"), _ = di(), b = { BlackWhite: !1, Brownie: !1, Vintage: !1, Kodachrome: !1, technicolor: !1, Polaroid: !1, Invert: !1, Sepia: !1 }, f = ee({ uiType: ne, noParamsFilters: b, paramsFilters: [...Gs], combinationFilters: [...Xs], type: "" }), r = (g, m) => { const y = p.canvas.getActiveObjects()[0]; f.noParamsFilters[g] = m, m ? u(y, g) || s(y, g) : l(y, g) }, c = g => { const m = p.canvas.getActiveObjects()[0], w = [...f.paramsFilters, ...f.combinationFilters].find(C => C.type === g); w.status ? w.handler ? i(w) : w.params.forEach(C => { o(g, C.key, C.value) }) : l(m, g) }, h = () => { var m; const g = p.canvas.getActiveObjects()[0]; g && (f.type = g.type, f.type === "image" && (Object.keys(b).forEach(y => { var w; f.noParamsFilters[y] = !!u(g, y), (w = _ == null ? void 0 : _.proxy) == null || w.$forceUpdate() }), Gs.forEach(y => { const w = f.paramsFilters.find(T => T.type === y.type), C = u(g, y.type); w.status = !!C, w.params.forEach(T => { T.value = C ? C[T.key] : T.value }) }), Xs.forEach(y => { const w = f.combinationFilters.find(T => T.type === y.type), C = u(g, y.type); w.status = !!C })), (m = _ == null ? void 0 : _.proxy) == null || m.$forceUpdate()) }; ue(() => { v.on("selectOne", h) }), In(() => { v.off("selectOne", h) }); function n(g) { return new URL(Object.assign({ "../assets/filters/BlackWhite.png": O1, "../assets/filters/Brownie.png": k1, "../assets/filters/Invert.png": A1, "../assets/filters/Kodachrome.png": E1, "../assets/filters/Polaroid.png": P1, "../assets/filters/Sepia.png": M1, "../assets/filters/Vintage.png": j1, "../assets/filters/technicolor.png": D1 })[`../assets/filters/${g}.png`], self.location).href } function o(g, m, y) { const w = p.canvas.getActiveObjects()[0], C = u(w, g); if (C) C[m] = y; else { const T = s(w, g); T[m] = y } w.applyFilters(), p.canvas.renderAll() } function i(g) { const m = p.canvas.getActiveObjects()[0]; l(m, g.type); const y = g.params.map(w => w.value); s(m, g.type, g.handler(...y)) } function s(g, m, y = null) { let w; const C = d(m), T = t.Image.filters[C]; return T && (w = new T(y), w.options = y, g.filters.push(w)), g.applyFilters(), p.canvas.renderAll(), w } function u(g, m) { let y = null; if (g) { const w = d(m), { length: C } = g.filters; let T, A; for (A = 0; A < C; A += 1)if (T = g.filters[A], T.type === w) { y = T; break } } return y } function l(g, m) { const y = d(m); g.filters = g.filters.filter(w => w.type !== y), g.applyFilters(), p.canvas.renderAll() } function d(g) { return g.charAt(0).toUpperCase() + g.slice(1) } return (g, m) => { const y = ut("Checkbox"), w = ut("Panel"), C = ut("Radio"), T = ut("RadioGroup"), A = ut("Slider"), U = ut("ColorPicker"), R = ut("Collapse"); return j(a).mSelectMode === "one" && j(f).type === "image" ? (lt(), mt("div", L1, [I(R, null, { default: G(() => [I(w, { name: "1" }, { content: G(() => [S("div", F1, [(lt(!0), mt(te, null, ce(j(f).noParamsFilters, ($, L) => (lt(), mt("div", { class: "filter-item", key: L }, [S("img", { src: n(L), alt: "", onClick: B => r(L, !b[L]) }, null, 8, $1), I(y, { modelValue: j(f).noParamsFilters[L], "onUpdate:modelValue": B => j(f).noParamsFilters[L] = B, onOnChange: B => r(L, B) }, { default: G(() => [xt(yt(g.$t("filters." + L)), 1)]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue", "onOnChange"])]))), 128))])]), default: G(() => [xt(yt(g.$t("filters.simple")) + " ", 1)]), _: 1 }), I(w, { name: "2" }, { content: G(() => [S("div", null, [(lt(!0), mt(te, null, ce([...j(f).paramsFilters, ...j(f).combinationFilters], $ => (lt(), mt("div", { class: "filter-item has-params", key: $.type }, [I(y, { modelValue: $.status, "onUpdate:modelValue": L => $.status = L, onOnChange: L => c($.type) }, { default: G(() => [xt(yt(g.$t("filters." + $.type)), 1)]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue", "onOnChange"]), $.status ? (lt(), mt("div", I1, [(lt(!0), mt(te, null, ce($.params, L => (lt(), mt("div", { class: "content slider-box", key: L }, [L.uiType === j(ne).SELECT ? (lt(), mt("div", R1, [I(T, { modelValue: L.value, "onUpdate:modelValue": B => L.value = B, onOnChange: B => c($.type) }, { default: G(() => [(lt(!0), mt(te, null, ce(L.list, B => (lt(), Rt(C, { label: B, key: B }, { default: G(() => [xt(yt(g.$t("filters." + $.type + "List." + B)), 1)]), _: 2 }, 1032, ["label"]))), 128))]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue", "onOnChange"])])) : At("", !0), L.uiType === j(ne).NUMBER ? (lt(), mt("div", B1, [I(A, { modelValue: L.value, "onUpdate:modelValue": B => L.value = B, max: L.max, min: L.min, step: L.step, onOnInput: B => c($.type) }, null, 8, ["modelValue", "onUpdate:modelValue", "max", "min", "step", "onOnInput"])])) : At("", !0), L.uiType === j(ne).COLOR ? (lt(), mt("div", z1, [I(U, { modelValue: L.value, "onUpdate:modelValue": B => L.value = B, basic: "", size: "small", onOnChange: B => c($.type) }, null, 8, ["modelValue", "onUpdate:modelValue", "onOnChange"])])) : At("", !0)]))), 128))])) : At("", !0)]))), 128))])]), default: G(() => [xt(yt(g.$t("filters.complex")) + " ", 1)]), _: 1 })]), _: 1 })])) : At("", !0) } } }), V1 = Yt(H1, [["__scopeId", "data-v-fddaa573"]]), N1 = { style: { display: "inline-block" } }, W1 = { key: 0, class: "time" }, Y1 = { name: "ToolBar" }, G1 = Dt(Ut(Et({}, Y1), { setup(e) { const { canvasEditor: t } = zt(), { history: a, redoStack: p, undoStack: v } = ee(t.getHistory()), _ = () => { t.undo() }, b = () => { t.redo() }; return (f, r) => { const c = ut("Icon"), h = ut("Button"), n = ut("Tooltip"); return lt(), mt("div", N1, [I(n, { content: f.$t("history.revocation") + `(${j(v).length})` }, { default: G(() => [I(h, { onClick: _, type: "text", size: "small", disabled: j(v).length === 0 }, { default: G(() => [I(c, { type: "ios-undo", size: "20" })]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"]), I(n, { content: f.$t("history.redo") + `(${j(p).length})` }, { default: G(() => [I(h, { onClick: b, type: "text", size: "small", disabled: j(p).length === 0 }, { default: G(() => [I(c, { type: "ios-redo", size: "20" })]), _: 1 }, 8, ["disabled"])]), _: 1 }, 8, ["content"]), j(a).length ? (lt(), mt("span", W1, yt(j(Ec)(j(a)[0].timestamp, "HH:mm:ss").value), 1)) : At("", !0)]) } } })); const X1 = Yt(G1, [["__scopeId", "data-v-edf7b556"]]); const K1 = { class: "box" }, q1 = { class: "layer-box" }, J1 = ["onClick"], Z1 = { class: "ellipsis" }, Q1 = ["innerHTML"], t0 = { class: "btn-box" }, e0 = ["innerHTML"], n0 = ["innerHTML"], i0 = ["innerHTML"], r0 = ["innerHTML"], s0 = { key: 1, class: "empty-text" }, o0 = Dt({ name: "Layer" }), a0 = Object.assign(o0, { setup(e) { const { canvasEditor: t, fabric: a, mixinState: p } = zt(), v = dt([]), _ = u => u.id === p.mSelectId || p.mSelectIds.includes(u.id), b = u => { const l = { group: '<svg t="1650855307397" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2503" width="16" height="16"><path d="M839.036 130.458h-654.072c-30.102 0-54.506 24.404-54.506 54.506v654.072c0 30.102 24.404 54.506 54.506 54.506h654.072c30.102 0 54.506-24.404 54.506-54.506v-654.072c0-30.102-24.404-54.506-54.506-54.506zM839.036 811.786c0 15.050-12.196 27.249-27.249 27.249h-598.721c-15.050 0-27.249-12.196-27.249-27.249v-598.721c0-15.050 12.196-27.249 27.249-27.249h598.721c15.049 0 27.249 12.196 27.249 27.249v598.721zM730.028 421.639h-127.324v-126.817c0-30.091-24.402-54.499-54.501-54.499h-252.755c-30.098 0-54.501 24.401-54.501 54.499v253.89c0 30.091 24.402 54.499 54.501 54.499h127.324v126.817c0 30.091 24.402 54.499 54.501 54.499h252.755c30.098 0 54.501-24.401 54.501-54.499v-253.89c0-30.091-24.402-54.499-54.501-54.499zM323.36 548.137c-15.050 0-27.251-12.207-27.251-27.26v-197.694c0-15.055 12.201-27.26 27.251-27.26h196.928c15.051 0 27.251 12.207 27.251 27.26v98.458h-70.267c-30.098 0-54.501 24.401-54.501 54.499v71.998h-99.411zM547.539 477.24v43.638c0 15.055-12.202 27.26-27.251 27.26h-42.353v-43.638c0-15.055 12.202-27.26 27.251-27.26h42.353zM729.365 702.193c0 15.055-12.201 27.26-27.251 27.26h-196.928c-15.050 0-27.251-12.207-27.251-27.26v-98.981h70.267c30.098 0 54.501-24.401 54.501-54.499v-71.474h99.411c15.050 0 27.251 12.207 27.251 27.26v197.693z" p-id="2504"></path></svg>', textbox: '<svg t="1650854954008" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14038" width="16" height="16"><path d="M720.832 692.352h-12.64L530.208 260.448a19.968 19.968 0 0 0-36.416 0L316.608 692.352h-13.44c-7.904 0-15.04 3.968-17.408 11.072a19.872 19.872 0 0 0 18.208 27.68h56.96c9.504 0 18.208-6.336 19.776-15.808a18.752 18.752 0 0 0-15.808-21.344l36.384-87.808h159.776l34.816 87.808a18.88 18.88 0 0 0-15.808 21.344c1.568 9.504 10.272 15.808 19.776 15.808h121.024c7.904 0 15.04-3.968 17.408-11.072a19.2 19.2 0 0 0-17.408-27.68z m-306.112-125.76l64.864-158.208 64.864 158.208H414.72z m-246.816-80.704c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0-75.936c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0 151.872c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m11.872-216.736a12.16 12.16 0 0 0 11.872-11.872v-23.744c-0.8-6.336-5.536-11.072-11.872-11.072s-11.872 5.536-11.872 11.872v23.744c0 6.336 4.736 11.072 11.872 11.072z m-11.872 292.672c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0 75.936c0 7.104 4.736 11.872 11.872 11.872a12.16 12.16 0 0 0 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m665.248-227.808c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0-75.936c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0 151.872c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m11.072-216.736a12.16 12.16 0 0 0 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744c0.8 7.104 5.536 11.872 11.872 11.872z m-11.072 292.672c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m0 75.936c0 6.336 5.536 11.872 11.872 11.872s11.872-5.536 11.872-11.872v-23.744c0-6.336-5.536-11.872-11.872-11.872s-11.872 5.536-11.872 11.872v23.744z m-347.264 119.456h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872z m-75.936 0h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872z m151.872 0h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872z m-228.608 0h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-4.736-11.872-11.872-11.872z m-75.136-7.904H222.496v-11.072a12.48 12.48 0 0 0-12.672-12.64h-18.976v-37.984c0-7.104-5.536-12.64-11.872-12.64s-11.872 5.536-11.872 12.64v37.984h-10.272a12.512 12.512 0 0 0-12.672 12.64v52.992a12.48 12.48 0 0 0 12.672 12.64h52.992a12.512 12.512 0 0 0 12.672-12.64v-11.072h35.584c7.104-1.568 12.672-7.904 12.672-14.24 0-7.104-12.672-16.608-12.672-16.608z m379.68 7.904h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872z m75.936 0h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h23.744c6.336 0 11.872-5.536 11.872-11.872s-4.736-11.872-11.872-11.872z m-251.52-642.304h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872z m-75.936 0h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872z m151.872 0h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872z m-227.808 0h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872h-23.744c-7.104 0.8-11.872 5.536-11.872 12.672s4.736 11.072 11.872 11.072zM257.28 167.904H221.696v-11.072a12.512 12.512 0 0 0-12.672-12.672H156.832a12.512 12.512 0 0 0-12.672 12.672v52.992c0 7.104 5.536 12.672 12.672 12.672h11.072v35.584c1.568 7.104 7.904 12.672 14.24 12.672s16.608-12.672 16.608-12.672V222.496h11.072a12.512 12.512 0 0 0 12.672-12.672v-18.976h35.584a12.16 12.16 0 0 0 11.872-11.872 12.224 12.224 0 0 0-12.672-11.072z m356.768 22.944h23.744c6.336 0 11.872-5.536 11.872-11.872s-5.536-11.872-11.872-11.872h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872z m76.736 0h23.744c6.336 0 11.072-4.736 11.072-11.072s-5.536-11.872-11.872-11.872h-23.744c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.072 12.64 11.072z m176.384-46.656h-52.992a12.48 12.48 0 0 0-12.64 12.672v11.072h-35.584c-7.104 1.568-12.64 7.904-12.64 14.24s12.64 16.608 12.64 16.608h35.584v11.072c0 7.104 5.536 12.672 12.64 12.672h18.976v37.984c0 7.104 5.536 12.672 11.872 12.672s11.872-5.536 11.872-12.672V222.528h11.072a12.48 12.48 0 0 0 12.64-12.672V156.864a13.76 13.76 0 0 0-13.44-12.672z m0 657.312h-11.072v-35.584c-1.568-7.104-7.904-12.64-14.24-12.64-7.104 0-16.608 12.64-16.608 12.64v35.584h-11.072a12.48 12.48 0 0 0-12.64 12.64v18.976h-35.584c-6.336 0-11.872 5.536-11.872 11.872s5.536 11.872 11.872 11.872h35.584v11.072a12.48 12.48 0 0 0 12.64 12.64h52.992a12.48 12.48 0 0 0 12.64-12.64v-52.992c0-7.904-5.536-13.44-12.64-13.44z" p-id="14039"></path></svg>', "i-text": '<svg t="1650875455324" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5401" width="16" height="16"><path d="M213.333333 209.92v128h85.333334v-42.666667h170.666666v433.493334H384.853333v85.333333h256v-85.333333H554.666667V295.253333h170.666666v42.666667h85.333334v-128H213.333333z" p-id="5402"></path></svg>', image: '<svg t="1650855321307" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2701" width="16" height="16"><path d="M813.752 223.168H209.584a25.168 25.168 0 0 0-25.168 25.176v528.648a25.16 25.16 0 0 0 25.168 25.168h604.168a25.152 25.152 0 0 0 25.168-25.168V248.344a25.168 25.168 0 0 0-25.168-25.176z m-8.08 544.168H217.664V258h588.008v509.336z" p-id="2702"></path><path d="M406.752 454.168a44.24 44.24 0 1 0-0.008-88.48 44.24 44.24 0 0 0 0.008 88.48zM474.72 611.368l-67.968-94.376-110.584 158.336h442.328L605.8 426.52z" p-id="2703"></path></svg>', rect: '<svg t="1650855811131" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="18499" width="16" height="16"><path d="M864 896H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h704a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zM192 832h640V192H192v640z" p-id="18500"></path></svg>', circle: '<svg t="1650855860236" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19440" width="16" height="16"><path d="M512 928C282.624 928 96 741.376 96 512S282.624 96 512 96s416 186.624 416 416-186.624 416-416 416z m0-768C317.92 160 160 317.92 160 512s157.92 352 352 352 352-157.92 352-352S706.08 160 512 160z" p-id="19441"></path></svg>', triangle: '<svg t="1650874633978" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2032" width="16" height="16"><path d="M928.64 896a2.144 2.144 0 0 1-0.64 0H96a32.032 32.032 0 0 1-27.552-48.288l416-704c11.488-19.456 43.552-19.456 55.104 0l413.152 699.2A31.936 31.936 0 0 1 928.64 896zM152.064 832h719.84L512 222.912 152.064 832z" p-id="2033"></path></svg>', polygon: '<svg t="1650874633978" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2032" width="16" height="16"><path d="M161.152 398.016l134.016 412.416h433.664l134.016-412.416L512 143.104 161.152 398.08zM512 64l426.048 309.568-162.752 500.864H248.704L85.952 373.568 512 64z" p-id="2033"></path></svg>' }, d = '<svg t="1650855578257" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17630" width="16" height="16"><path d="M620.606061 0a62.060606 62.060606 0 0 1 62.060606 62.060606v188.943515C874.945939 273.997576 1024 437.651394 1024 636.121212c0 214.217697-173.661091 387.878788-387.878788 387.878788-198.469818 0-362.123636-149.054061-385.117091-341.333333H62.060606a62.060606 62.060606 0 0 1-62.060606-62.060606V62.060606a62.060606 62.060606 0 0 1 62.060606-62.060606h558.545455z m62.060606 297.937455V620.606061a62.060606 62.060606 0 0 1-62.060606 62.060606H297.937455C320.636121 849.159758 463.39103 977.454545 636.121212 977.454545c188.509091 0 341.333333-152.824242 341.333333-341.333333 0-172.730182-128.294788-315.485091-294.787878-338.183757zM620.606061 46.545455H62.060606a15.515152 15.515152 0 0 0-15.406545 13.699878L46.545455 62.060606v558.545455a15.515152 15.515152 0 0 0 13.699878 15.406545L62.060606 636.121212h186.181818c0-214.217697 173.661091-387.878788 387.878788-387.878788V62.060606a15.515152 15.515152 0 0 0-13.699879-15.406545L620.606061 46.545455z m15.515151 248.242424c-188.509091 0-341.333333 152.824242-341.333333 341.333333h325.818182a15.515152 15.515152 0 0 0 15.406545-13.699879L636.121212 620.606061V294.787879z" p-id="17631"></path></svg>'; return l[u] || d }, f = (u, l) => u.includes("text") ? l.name || l.text : { group: "Combination", image: "Image", rect: "Rectangle", circle: "Round", triangle: "Triangle", polygon: "Polygon", path: "Path" }[u] || "Element", r = u => { const l = t.canvas.getObjects().find(d => d.id === u); t.canvas.discardActiveObject(), t.canvas.setActiveObject(l), t.canvas.requestRenderAll() }, c = u => ({ up: '<svg t="1650442206559" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1799" width="12" height="12"><path d="M876.2 434.3L536.7 94.9c-6.6-6.6-15.5-10.3-24.7-10.3-9.3 0-18.2 3.7-24.7 10.3L147.8 434.3c-13.7 13.7-13.7 35.8 0 49.5 13.7 13.7 35.8 13.7 49.5 0L477 204.1v700.2c0 19.3 15.7 35 35 35s35-15.7 35-35V204.1l279.7 279.7c6.8 6.8 15.8 10.3 24.7 10.3s17.9-3.4 24.7-10.3c13.7-13.7 13.7-35.8 0.1-49.5z" p-id="1800"></path></svg>', down: '<svg t="1650442229022" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1997" width="12" height="12"><path d="M876.2 589.7L536.7 929.1c-6.6 6.6-15.5 10.3-24.7 10.3-9.3 0-18.2-3.7-24.7-10.3L147.8 589.7c-13.7-13.7-13.7-35.8 0-49.5 13.7-13.7 35.8-13.7 49.5 0L477 819.9V119.6c0-19.3 15.7-35 35-35s35 15.7 35 35v700.2l279.7-279.7c6.8-6.8 15.8-10.3 24.7-10.3s17.9 3.4 24.7 10.3c13.7 13.8 13.7 35.9 0.1 49.6z" p-id="1998" ></path></svg>', upTop: '<svg t="1650442106652" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1839" width="11" height="11"><path d="M548.352 219.648a58.88 58.88 0 0 0-16.896-10.752 51.2 51.2 0 0 0-38.912 0 58.88 58.88 0 0 0-16.896 10.752l-256 256a51.2 51.2 0 0 0 72.704 72.704L460.8 379.392V972.8a51.2 51.2 0 0 0 102.4 0V379.392l168.448 168.96a51.2 51.2 0 0 0 72.704-72.704zM972.8 0H51.2a51.2 51.2 0 0 0 0 102.4h921.6a51.2 51.2 0 0 0 0-102.4z" p-id="1840" ></path></svg>', downTop: '<svg t="1650442146918" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2045" width="11" height="11"><path d="M548.352 804.352a58.88 58.88 0 0 1-16.896 10.752 51.2 51.2 0 0 1-38.912 0 58.88 58.88 0 0 1-16.896-10.752l-256-256a51.2 51.2 0 0 1 72.704-72.704L460.8 644.608V51.2a51.2 51.2 0 0 1 102.4 0v593.408l168.448-168.96a51.2 51.2 0 0 1 72.704 72.704zM972.8 1024H51.2a51.2 51.2 0 0 1 0-102.4h921.6a51.2 51.2 0 0 1 0 102.4z" p-id="2046"></path></svg>' })[u], h = () => { t.up() }, n = () => { t.upTop() }, o = () => { t.down() }, i = () => { t.downTop() }, s = () => { v.value = [...t.canvas.getObjects().filter(u => !(u instanceof a.GuideLine || u.id === "workspace"))].reverse().map(u => { const { type: l, id: d, name: g, text: m } = u; return { type: l, id: d, name: g, text: m } }) }; return ue(() => { t.canvas.preserveObjectStacking = !0, t.canvas.on("after:render", s) }), (u, l) => { const d = ut("Divider"), g = ut("Tooltip"), m = ut("Button"), y = ut("ButtonGroup"); return lt(), mt("div", K1, [j(v).length ? (lt(), mt(te, { key: 0 }, [I(d, { plain: "", orientation: "left" }, { default: G(() => [xt(yt(u.$t("layers")), 1)]), _: 1 }), S("div", q1, [(lt(!0), mt(te, null, ce(j(v), w => (lt(), mt("div", { onClick: C => r(w.id), key: w.id, class: he(_(w) && "active") }, [I(g, { content: w.name || w.text || w.type, placement: "left" }, { default: G(() => [S("div", Z1, [S("span", { class: he(_(w) && "active"), innerHTML: b(w.type) }, null, 10, Q1), xt(" | " + yt(f(w.type, w)), 1)])]), _: 2 }, 1032, ["content"])], 10, J1))), 128))]), S("div", t0, [Ct(I(y, { size: "small" }, { default: G(() => [I(m, { onClick: h }, { default: G(() => [S("span", { innerHTML: c("up") }, null, 8, e0)]), _: 1 }), I(m, { onClick: o }, { default: G(() => [S("span", { innerHTML: c("down") }, null, 8, n0)]), _: 1 }), I(m, { onClick: n }, { default: G(() => [S("span", { innerHTML: c("upTop") }, null, 8, i0)]), _: 1 }), I(m, { onClick: i }, { default: G(() => [S("span", { innerHTML: c("downTop") }, null, 8, r0)]), _: 1 })]), _: 1 }, 512), [[pe, j(p).mSelectMode === "one"]])])], 64)) : (lt(), mt("p", s0, "No layers yet"))]) } } }), l0 = Yt(a0, [["__scopeId", "data-v-ad75088d"]]), c0 = [{ name: "汉体", fontFamily: "汉体" }, { name: "华康金刚黑", fontFamily: "华康金刚黑" }]; document.addEventListener("DOMContentLoaded", function () { const e = document.querySelector(".ivu-color-picker-input.ivu-input.ivu-input-default"); e && e.click() }); const u0 = [], h0 = [...c0, ...u0]; var f0 = Object.defineProperty, d0 = Object.defineProperties, p0 = Object.getOwnPropertyDescriptors, Ks = Object.getOwnPropertySymbols, g0 = Object.prototype.hasOwnProperty, m0 = Object.prototype.propertyIsEnumerable, qs = (e, t, a) => t in e ? f0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, v0 = (e, t) => { for (var a in t || (t = {})) g0.call(t, a) && qs(e, a, t[a]); if (Ks) for (var a of Ks(t)) m0.call(t, a) && qs(e, a, t[a]); return e }, _0 = (e, t) => d0(e, p0(t)), y0 = typeof global == "object" && global && global.Object === Object && global; const Ka = y0; var b0 = typeof self == "object" && self && self.Object === Object && self, w0 = Ka || b0 || Function("return this")(); const ye = w0; var C0 = ye.Symbol; const cn = C0; var qa = Object.prototype, S0 = qa.hasOwnProperty, x0 = qa.toString, Cn = cn ? cn.toStringTag : void 0; function T0(e) { var t = S0.call(e, Cn), a = e[Cn]; try { e[Cn] = void 0; var p = !0 } catch (_) { } var v = x0.call(e); return p && (t ? e[Cn] = a : delete e[Cn]), v } var O0 = Object.prototype, k0 = O0.toString; function A0(e) { return k0.call(e) } var E0 = "[object Null]", P0 = "[object Undefined]", Js = cn ? cn.toStringTag : void 0; function pn(e) { return e == null ? e === void 0 ? P0 : E0 : Js && Js in Object(e) ? T0(e) : A0(e) } function gn(e) { return e != null && typeof e == "object" } var M0 = "[object Symbol]"; function j0(e) { return typeof e == "symbol" || gn(e) && pn(e) == M0 } var D0 = Array.isArray; const Vr = D0; var L0 = /\s/; function F0(e) { for (var t = e.length; t-- && L0.test(e.charAt(t));); return t } var $0 = /^\s+/; function I0(e) { return e && e.slice(0, F0(e) + 1).replace($0, "") } function Le(e) { var t = typeof e; return e != null && (t == "object" || t == "function") } var Zs = 0 / 0, R0 = /^[-+]0x[0-9a-f]+$/i, B0 = /^0b[01]+$/i, z0 = /^0o[0-7]+$/i, U0 = parseInt; function Qs(e) { if (typeof e == "number") return e; if (j0(e)) return Zs; if (Le(e)) { var t = typeof e.valueOf == "function" ? e.valueOf() : e; e = Le(t) ? t + "" : t } if (typeof e != "string") return e === 0 ? e : +e; e = I0(e); var a = B0.test(e); return a || z0.test(e) ? U0(e.slice(2), a ? 2 : 8) : R0.test(e) ? Zs : +e } var H0 = "[object AsyncFunction]", V0 = "[object Function]", N0 = "[object GeneratorFunction]", W0 = "[object Proxy]"; function Ja(e) { if (!Le(e)) return !1; var t = pn(e); return t == V0 || t == N0 || t == H0 || t == W0 } var Y0 = ye["__core-js_shared__"]; const Bi = Y0; var to = function () { var e = /[^.]+$/.exec(Bi && Bi.keys && Bi.keys.IE_PROTO || ""); return e ? "Symbol(src)_1." + e : "" }(); function G0(e) { return !!to && to in e } var X0 = Function.prototype, K0 = X0.toString; function nn(e) { if (e != null) { try { return K0.call(e) } catch (t) { } try { return e + "" } catch (t) { } } return "" } var q0 = /[\\^$.*+?()[\]{}|]/g, J0 = /^\[object .+?Constructor\]$/, Z0 = Function.prototype, Q0 = Object.prototype, t3 = Z0.toString, e3 = Q0.hasOwnProperty, n3 = RegExp("^" + t3.call(e3).replace(q0, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function i3(e) { if (!Le(e) || G0(e)) return !1; var t = Ja(e) ? n3 : J0; return t.test(nn(e)) } function r3(e, t) { return e == null ? void 0 : e[t] } function rn(e, t) { var a = r3(e, t); return i3(a) ? a : void 0 } var s3 = rn(ye, "WeakMap"); const lr = s3; var eo = Object.create, o3 = function () { function e() { } return function (t) { if (!Le(t)) return {}; if (eo) return eo(t); e.prototype = t; var a = new e; return e.prototype = void 0, a } }(); const a3 = o3; function l3(e, t) { var a = -1, p = e.length; for (t || (t = Array(p)); ++a < p;)t[a] = e[a]; return t } var c3 = function () { try { var e = rn(Object, "defineProperty"); return e({}, "", {}), e } catch (t) { } }(); const no = c3; function u3(e, t) { for (var a = -1, p = e == null ? 0 : e.length; ++a < p && t(e[a], a, e) !== !1;); return e } var h3 = 9007199254740991, f3 = /^(?:0|[1-9]\d*)$/; function d3(e, t) { var a = typeof e; return t = t == null ? h3 : t, !!t && (a == "number" || a != "symbol" && f3.test(e)) && e > -1 && e % 1 == 0 && e < t } function Za(e, t, a) { t == "__proto__" && no ? no(e, t, { configurable: !0, enumerable: !0, value: a, writable: !0 }) : e[t] = a } function Qa(e, t) { return e === t || e !== e && t !== t } var p3 = Object.prototype, g3 = p3.hasOwnProperty; function tl(e, t, a) { var p = e[t]; (!(g3.call(e, t) && Qa(p, a)) || a === void 0 && !(t in e)) && Za(e, t, a) } function Si(e, t, a, p) { var v = !a; a || (a = {}); for (var _ = -1, b = t.length; ++_ < b;) { var f = t[_], r = p ? p(a[f], e[f], f, a, e) : void 0; r === void 0 && (r = e[f]), v ? Za(a, f, r) : tl(a, f, r) } return a } var m3 = 9007199254740991; function el(e) { return typeof e == "number" && e > -1 && e % 1 == 0 && e <= m3 } function nl(e) { return e != null && el(e.length) && !Ja(e) } var v3 = Object.prototype; function Nr(e) { var t = e && e.constructor, a = typeof t == "function" && t.prototype || v3; return e === a } function _3(e, t) { for (var a = -1, p = Array(e); ++a < e;)p[a] = t(a); return p } var y3 = "[object Arguments]"; function io(e) { return gn(e) && pn(e) == y3 } var il = Object.prototype, b3 = il.hasOwnProperty, w3 = il.propertyIsEnumerable, C3 = io(function () { return arguments }()) ? io : function (e) { return gn(e) && b3.call(e, "callee") && !w3.call(e, "callee") }; const S3 = C3; function x3() { return !1 } var rl = typeof exports == "object" && exports && !exports.nodeType && exports, ro = rl && typeof module == "object" && module && !module.nodeType && module, T3 = ro && ro.exports === rl, so = T3 ? ye.Buffer : void 0, O3 = so ? so.isBuffer : void 0, k3 = O3 || x3; const sl = k3; var A3 = "[object Arguments]", E3 = "[object Array]", P3 = "[object Boolean]", M3 = "[object Date]", j3 = "[object Error]", D3 = "[object Function]", L3 = "[object Map]", F3 = "[object Number]", $3 = "[object Object]", I3 = "[object RegExp]", R3 = "[object Set]", B3 = "[object String]", z3 = "[object WeakMap]", U3 = "[object ArrayBuffer]", H3 = "[object DataView]", V3 = "[object Float32Array]", N3 = "[object Float64Array]", W3 = "[object Int8Array]", Y3 = "[object Int16Array]", G3 = "[object Int32Array]", X3 = "[object Uint8Array]", K3 = "[object Uint8ClampedArray]", q3 = "[object Uint16Array]", J3 = "[object Uint32Array]", Kt = {}; Kt[V3] = Kt[N3] = Kt[W3] = Kt[Y3] = Kt[G3] = Kt[X3] = Kt[K3] = Kt[q3] = Kt[J3] = !0; Kt[A3] = Kt[E3] = Kt[U3] = Kt[P3] = Kt[H3] = Kt[M3] = Kt[j3] = Kt[D3] = Kt[L3] = Kt[F3] = Kt[$3] = Kt[I3] = Kt[R3] = Kt[B3] = Kt[z3] = !1; function Z3(e) { return gn(e) && el(e.length) && !!Kt[pn(e)] } function Wr(e) { return function (t) { return e(t) } } var ol = typeof exports == "object" && exports && !exports.nodeType && exports, On = ol && typeof module == "object" && module && !module.nodeType && module, Q3 = On && On.exports === ol, zi = Q3 && Ka.process, t_ = function () { try { var e = On && On.require && On.require("util").types; return e || zi && zi.binding && zi.binding("util") } catch (t) { } }(); const un = t_; var oo = un && un.isTypedArray, e_ = oo ? Wr(oo) : Z3; const n_ = e_; var i_ = Object.prototype, r_ = i_.hasOwnProperty; function al(e, t) { var a = Vr(e), p = !a && S3(e), v = !a && !p && sl(e), _ = !a && !p && !v && n_(e), b = a || p || v || _, f = b ? _3(e.length, String) : [], r = f.length; for (var c in e) (t || r_.call(e, c)) && !(b && (c == "length" || v && (c == "offset" || c == "parent") || _ && (c == "buffer" || c == "byteLength" || c == "byteOffset") || d3(c, r))) && f.push(c); return f } function ll(e, t) { return function (a) { return e(t(a)) } } var s_ = ll(Object.keys, Object); const o_ = s_; var a_ = Object.prototype, l_ = a_.hasOwnProperty; function c_(e) { if (!Nr(e)) return o_(e); var t = []; for (var a in Object(e)) l_.call(e, a) && a != "constructor" && t.push(a); return t } function Yr(e) { return nl(e) ? al(e) : c_(e) } function u_(e) { var t = []; if (e != null) for (var a in Object(e)) t.push(a); return t } var h_ = Object.prototype, f_ = h_.hasOwnProperty; function d_(e) { if (!Le(e)) return u_(e); var t = Nr(e), a = []; for (var p in e) p == "constructor" && (t || !f_.call(e, p)) || a.push(p); return a } function Gr(e) { return nl(e) ? al(e, !0) : d_(e) } var p_ = rn(Object, "create"); const Mn = p_; function g_() { this.__data__ = Mn ? Mn(null) : {}, this.size = 0 } function m_(e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } var v_ = "__lodash_hash_undefined__", __ = Object.prototype, y_ = __.hasOwnProperty; function b_(e) { var t = this.__data__; if (Mn) { var a = t[e]; return a === v_ ? void 0 : a } return y_.call(t, e) ? t[e] : void 0 } var w_ = Object.prototype, C_ = w_.hasOwnProperty; function S_(e) { var t = this.__data__; return Mn ? t[e] !== void 0 : C_.call(t, e) } var x_ = "__lodash_hash_undefined__"; function T_(e, t) { var a = this.__data__; return this.size += this.has(e) ? 0 : 1, a[e] = Mn && t === void 0 ? x_ : t, this } function Xe(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } Xe.prototype.clear = g_; Xe.prototype.delete = m_; Xe.prototype.get = b_; Xe.prototype.has = S_; Xe.prototype.set = T_; function O_() { this.__data__ = [], this.size = 0 } function xi(e, t) { for (var a = e.length; a--;)if (Qa(e[a][0], t)) return a; return -1 } var k_ = Array.prototype, A_ = k_.splice; function E_(e) { var t = this.__data__, a = xi(t, e); if (a < 0) return !1; var p = t.length - 1; return a == p ? t.pop() : A_.call(t, a, 1), --this.size, !0 } function P_(e) { var t = this.__data__, a = xi(t, e); return a < 0 ? void 0 : t[a][1] } function M_(e) { return xi(this.__data__, e) > -1 } function j_(e, t) { var a = this.__data__, p = xi(a, e); return p < 0 ? (++this.size, a.push([e, t])) : a[p][1] = t, this } function Ie(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } Ie.prototype.clear = O_; Ie.prototype.delete = E_; Ie.prototype.get = P_; Ie.prototype.has = M_; Ie.prototype.set = j_; var D_ = rn(ye, "Map"); const jn = D_; function L_() { this.size = 0, this.__data__ = { hash: new Xe, map: new (jn || Ie), string: new Xe } } function F_(e) { var t = typeof e; return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null } function Ti(e, t) { var a = e.__data__; return F_(t) ? a[typeof t == "string" ? "string" : "hash"] : a.map } function $_(e) { var t = Ti(this, e).delete(e); return this.size -= t ? 1 : 0, t } function I_(e) { return Ti(this, e).get(e) } function R_(e) { return Ti(this, e).has(e) } function B_(e, t) { var a = Ti(this, e), p = a.size; return a.set(e, t), this.size += a.size == p ? 0 : 1, this } function mn(e) { var t = -1, a = e == null ? 0 : e.length; for (this.clear(); ++t < a;) { var p = e[t]; this.set(p[0], p[1]) } } mn.prototype.clear = L_; mn.prototype.delete = $_; mn.prototype.get = I_; mn.prototype.has = R_; mn.prototype.set = B_; function cl(e, t) { for (var a = -1, p = t.length, v = e.length; ++a < p;)e[v + a] = t[a]; return e } var z_ = ll(Object.getPrototypeOf, Object); const ul = z_; function U_() { this.__data__ = new Ie, this.size = 0 } function H_(e) { var t = this.__data__, a = t.delete(e); return this.size = t.size, a } function V_(e) { return this.__data__.get(e) } function N_(e) { return this.__data__.has(e) } var W_ = 200; function Y_(e, t) { var a = this.__data__; if (a instanceof Ie) { var p = a.__data__; if (!jn || p.length < W_ - 1) return p.push([e, t]), this.size = ++a.size, this; a = this.__data__ = new mn(p) } return a.set(e, t), this.size = a.size, this } function vn(e) { var t = this.__data__ = new Ie(e); this.size = t.size } vn.prototype.clear = U_; vn.prototype.delete = H_; vn.prototype.get = V_; vn.prototype.has = N_; vn.prototype.set = Y_; function G_(e, t) { return e && Si(t, Yr(t), e) } function X_(e, t) { return e && Si(t, Gr(t), e) } var hl = typeof exports == "object" && exports && !exports.nodeType && exports, ao = hl && typeof module == "object" && module && !module.nodeType && module, K_ = ao && ao.exports === hl, lo = K_ ? ye.Buffer : void 0, co = lo ? lo.allocUnsafe : void 0; function q_(e, t) { if (t) return e.slice(); var a = e.length, p = co ? co(a) : new e.constructor(a); return e.copy(p), p } function J_(e, t) { for (var a = -1, p = e == null ? 0 : e.length, v = 0, _ = []; ++a < p;) { var b = e[a]; t(b, a, e) && (_[v++] = b) } return _ } function fl() { return [] } var Z_ = Object.prototype, Q_ = Z_.propertyIsEnumerable, uo = Object.getOwnPropertySymbols, ty = uo ? function (e) { return e == null ? [] : (e = Object(e), J_(uo(e), function (t) { return Q_.call(e, t) })) } : fl; const Xr = ty; function ey(e, t) { return Si(e, Xr(e), t) } var ny = Object.getOwnPropertySymbols, iy = ny ? function (e) { for (var t = []; e;)cl(t, Xr(e)), e = ul(e); return t } : fl; const dl = iy; function ry(e, t) { return Si(e, dl(e), t) } function pl(e, t, a) { var p = t(e); return Vr(e) ? p : cl(p, a(e)) } function sy(e) { return pl(e, Yr, Xr) } function oy(e) { return pl(e, Gr, dl) } var ay = rn(ye, "DataView"); const cr = ay; var ly = rn(ye, "Promise"); const ur = ly; var cy = rn(ye, "Set"); const hr = cy; var ho = "[object Map]", uy = "[object Object]", fo = "[object Promise]", po = "[object Set]", go = "[object WeakMap]", mo = "[object DataView]", hy = nn(cr), fy = nn(jn), dy = nn(ur), py = nn(hr), gy = nn(lr), We = pn; (cr && We(new cr(new ArrayBuffer(1))) != mo || jn && We(new jn) != ho || ur && We(ur.resolve()) != fo || hr && We(new hr) != po || lr && We(new lr) != go) && (We = function (e) { var t = pn(e), a = t == uy ? e.constructor : void 0, p = a ? nn(a) : ""; if (p) switch (p) { case hy: return mo; case fy: return ho; case dy: return fo; case py: return po; case gy: return go }return t }); const Kr = We; var my = Object.prototype, vy = my.hasOwnProperty; function _y(e) { var t = e.length, a = new e.constructor(t); return t && typeof e[0] == "string" && vy.call(e, "index") && (a.index = e.index, a.input = e.input), a } var yy = ye.Uint8Array; const vo = yy; function qr(e) { var t = new e.constructor(e.byteLength); return new vo(t).set(new vo(e)), t } function by(e, t) { var a = t ? qr(e.buffer) : e.buffer; return new e.constructor(a, e.byteOffset, e.byteLength) } var wy = /\w*$/; function Cy(e) { var t = new e.constructor(e.source, wy.exec(e)); return t.lastIndex = e.lastIndex, t } var _o = cn ? cn.prototype : void 0, yo = _o ? _o.valueOf : void 0; function Sy(e) { return yo ? Object(yo.call(e)) : {} } function xy(e, t) { var a = t ? qr(e.buffer) : e.buffer; return new e.constructor(a, e.byteOffset, e.length) } var Ty = "[object Boolean]", Oy = "[object Date]", ky = "[object Map]", Ay = "[object Number]", Ey = "[object RegExp]", Py = "[object Set]", My = "[object String]", jy = "[object Symbol]", Dy = "[object ArrayBuffer]", Ly = "[object DataView]", Fy = "[object Float32Array]", $y = "[object Float64Array]", Iy = "[object Int8Array]", Ry = "[object Int16Array]", By = "[object Int32Array]", zy = "[object Uint8Array]", Uy = "[object Uint8ClampedArray]", Hy = "[object Uint16Array]", Vy = "[object Uint32Array]"; function Ny(e, t, a) { var p = e.constructor; switch (t) { case Dy: return qr(e); case Ty: case Oy: return new p(+e); case Ly: return by(e, a); case Fy: case $y: case Iy: case Ry: case By: case zy: case Uy: case Hy: case Vy: return xy(e, a); case ky: return new p; case Ay: case My: return new p(e); case Ey: return Cy(e); case Py: return new p; case jy: return Sy(e) } } function Wy(e) { return typeof e.constructor == "function" && !Nr(e) ? a3(ul(e)) : {} } var Yy = "[object Map]"; function Gy(e) { return gn(e) && Kr(e) == Yy } var bo = un && un.isMap, Xy = bo ? Wr(bo) : Gy; const Ky = Xy; var qy = "[object Set]"; function Jy(e) { return gn(e) && Kr(e) == qy } var wo = un && un.isSet, Zy = wo ? Wr(wo) : Jy; const Qy = Zy; var t2 = 1, e2 = 2, n2 = 4, gl = "[object Arguments]", i2 = "[object Array]", r2 = "[object Boolean]", s2 = "[object Date]", o2 = "[object Error]", ml = "[object Function]", a2 = "[object GeneratorFunction]", l2 = "[object Map]", c2 = "[object Number]", vl = "[object Object]", u2 = "[object RegExp]", h2 = "[object Set]", f2 = "[object String]", d2 = "[object Symbol]", p2 = "[object WeakMap]", g2 = "[object ArrayBuffer]", m2 = "[object DataView]", v2 = "[object Float32Array]", _2 = "[object Float64Array]", y2 = "[object Int8Array]", b2 = "[object Int16Array]", w2 = "[object Int32Array]", C2 = "[object Uint8Array]", S2 = "[object Uint8ClampedArray]", x2 = "[object Uint16Array]", T2 = "[object Uint32Array]", Vt = {}; Vt[gl] = Vt[i2] = Vt[g2] = Vt[m2] = Vt[r2] = Vt[s2] = Vt[v2] = Vt[_2] = Vt[y2] = Vt[b2] = Vt[w2] = Vt[l2] = Vt[c2] = Vt[vl] = Vt[u2] = Vt[h2] = Vt[f2] = Vt[d2] = Vt[C2] = Vt[S2] = Vt[x2] = Vt[T2] = !0; Vt[o2] = Vt[ml] = Vt[p2] = !1; function ei(e, t, a, p, v, _) { var b, f = t & t2, r = t & e2, c = t & n2; if (a && (b = v ? a(e, p, v, _) : a(e)), b !== void 0) return b; if (!Le(e)) return e; var h = Vr(e); if (h) { if (b = _y(e), !f) return l3(e, b) } else { var n = Kr(e), o = n == ml || n == a2; if (sl(e)) return q_(e, f); if (n == vl || n == gl || o && !v) { if (b = r || o ? {} : Wy(e), !f) return r ? ry(e, X_(b, e)) : ey(e, G_(b, e)) } else { if (!Vt[n]) return v ? e : {}; b = Ny(e, n, f) } } _ || (_ = new vn); var i = _.get(e); if (i) return i; _.set(e, b), Qy(e) ? e.forEach(function (l) { b.add(ei(l, t, a, l, e, _)) }) : Ky(e) && e.forEach(function (l, d) { b.set(d, ei(l, t, a, d, e, _)) }); var s = c ? r ? oy : sy : r ? Gr : Yr, u = h ? void 0 : s(e); return u3(u || e, function (l, d) { u && (d = l, l = e[d]), tl(b, d, ei(l, t, a, d, e, _)) }), b } var O2 = 1, k2 = 4; function A2(e) { return ei(e, O2 | k2) } var E2 = function () { return ye.Date.now() }; const Ui = E2; var P2 = "Expected a function", M2 = Math.max, j2 = Math.min; function D2(e, t, a) { var p, v, _, b, f, r, c = 0, h = !1, n = !1, o = !0; if (typeof e != "function") throw new TypeError(P2); t = Qs(t) || 0, Le(a) && (h = !!a.leading, n = "maxWait" in a, _ = n ? M2(Qs(a.maxWait) || 0, t) : _, o = "trailing" in a ? !!a.trailing : o); function i(C) { var T = p, A = v; return p = v = void 0, c = C, b = e.apply(A, T), b } function s(C) { return c = C, f = setTimeout(d, t), h ? i(C) : b } function u(C) { var T = C - r, A = C - c, U = t - T; return n ? j2(U, _ - A) : U } function l(C) { var T = C - r, A = C - c; return r === void 0 || T >= t || T < 0 || n && A >= _ } function d() { var C = Ui(); if (l(C)) return g(C); f = setTimeout(d, u(C)) } function g(C) { return f = void 0, o && p ? i(C) : (p = v = void 0, b) } function m() { f !== void 0 && clearTimeout(f), c = 0, p = r = v = f = void 0 } function y() { return f === void 0 ? b : g(Ui()) } function w() { var C = Ui(), T = l(C); if (p = arguments, v = this, r = C, T) { if (f === void 0) return s(r); if (n) return clearTimeout(f), f = setTimeout(d, t), i(r) } return f === void 0 && (f = setTimeout(d, t)), b } return w.cancel = m, w.flush = y, w } var L2 = "Expected a function"; function F2(e, t, a) { var p = !0, v = !0; if (typeof e != "function") throw new TypeError(L2); return Le(a) && (p = "leading" in a ? !!a.leading : p, v = "trailing" in a ? !!a.trailing : v), D2(e, t, { leading: p, maxWait: t, trailing: v }) } function YS(e, t, a) { let p = e.toString(16), v = t.toString(16), _ = a.toString(16); return e < 16 && (p = `0${p}`), t < 16 && (v = `0${v}`), a < 16 && (_ = `0${_}`), p + v + _ } function $2(e, t, a, p) { return `rgba(${e}, ${t}, ${a}, ${p})` } function I2(e, t, a) { let p = ""; const v = e.slice(); return v.sort((_, b) => _.left - b.left), t === "linear" ? p = `linear-gradient(${a}deg,` : p = "radial-gradient(", v.forEach((_, b) => { p += `rgba(${_.red}, ${_.green}, ${_.blue}, ${_.alpha}) ${_.left}%`, b !== v.length - 1 && (p += ",") }), p += ")", p } let Yn; const R2 = new Uint8Array(16); function B2() { if (!Yn && (Yn = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Yn)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return Yn(R2) } const se = []; for (let e = 0; e < 256; ++e)se.push((e + 256).toString(16).slice(1)); function z2(e, t = 0) { return se[e[t + 0]] + se[e[t + 1]] + se[e[t + 2]] + se[e[t + 3]] + "-" + se[e[t + 4]] + se[e[t + 5]] + "-" + se[e[t + 6]] + se[e[t + 7]] + "-" + se[e[t + 8]] + se[e[t + 9]] + "-" + se[e[t + 10]] + se[e[t + 11]] + se[e[t + 12]] + se[e[t + 13]] + se[e[t + 14]] + se[e[t + 15]] } const U2 = typeof crypto != "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Co = { randomUUID: U2 }; function So(e, t, a) { if (Co.randomUUID && !t && !e) return Co.randomUUID(); e = e || {}; const p = e.random || (e.rng || B2)(); if (p[6] = p[6] & 15 | 64, p[8] = p[8] & 63 | 128, t) { a = a || 0; for (let v = 0; v < 16; ++v)t[a + v] = p[v]; return t } return z2(p) } const H2 = { class: "picker-color-ui border-box m-8px bg-[#fff] flex flex-col slelect-none" }, V2 = S("p", null, "Loading...", -1), N2 = { key: 0, class: "btns flex justify-end items-center select-none" }, W2 = Dt({ name: "ColorPicker" }), Y2 = Dt(_0(v0({}, W2), { props: { isGradient: { type: Boolean, default: !1 }, showBtn: { type: Boolean, default: !1 }, showCancel: { type: Boolean, default: !1 }, color: { type: Object, default: e => e.isGradient ? { type: "linear", degree: 0, points: [{ id: So(), left: 0, red: 0, green: 0, blue: 0, alpha: 1 }, { id: So(), left: 100, red: 255, green: 0, blue: 0, alpha: 1 }] } : { red: 255, green: 0, blue: 0, alpha: 1 } }, cancelText: { type: String, default: "Cancel" }, cancelColor: { type: String, default: "#333" }, cancelBg: { type: String, default: "#fff" }, confirmText: { type: String, default: "Confirm" }, confirmColor: { type: String, defualt: "#333" }, confirmBg: { type: String, defualt: "#fff" } }, emits: ["change"], setup(e, { expose: t, emit: a }) { var p, v; const _ = e, b = as(() => ls(() => import("./index-3f84cf4d.4097b618.js"), ["js/index-3f84cf4d.4097b618.js", "js/index.vue_vue_type_script_name_Preview_setup_true_lang-22e0d43b.0a3d97a4.js", "js/index.414766e6.js", "assets/index-1b8c8e19.css"])), f = as(() => ls(() => import("./index-b1398dc9.8da4235f.js"), ["js/index-b1398dc9.8da4235f.js", "js/index.vue_vue_type_script_name_Preview_setup_true_lang-22e0d43b.0a3d97a4.js", "js/index.414766e6.js", "assets/index-1b8c8e19.css"])), r = _.isGradient && ((v = (p = _.color) == null ? void 0 : p.points) == null ? void 0 : v.length) || 0, c = r ? r - 1 : 0; console.log(c), console.log(_.color.points); const h = ee({ isGradient: _.isGradient, red: _.isGradient ? _.color.points[c].red : _.color.red, green: _.isGradient ? _.color.points[c].green : _.color.green, blue: _.isGradient ? _.color.points[c].blue : _.color.blue, alpha: _.isGradient ? _.color.points[c].alpha : _.color.alpha, hue: 0, saturation: 100, value: 100, style: "", type: _.isGradient ? _.color.type : "linear", degree: _.isGradient ? _.color.degree : 0, activePointIndex: c, points: _.isGradient ? A2(_.color.points) : [] }), n = F2(function ({ red: l, green: d, blue: g, alpha: m, hue: y, saturation: w, value: C, points: T, type: A, degree: U }, R) { const $ = { red: l, green: d, blue: g, alpha: m, hue: y, saturation: w, value: C, points: T, type: A, degree: U }; _.isGradient ? o($, R) : i($, R) }, _.showBtn ? 100 : 150); function o(l, d) { const { red: g = 0, green: m = 0, blue: y = 0, alpha: w = 0, hue: C, saturation: T, value: A, points: U, type: R, degree: $ } = l, L = h.points[h.activePointIndex]; d ? d === "points" || d === "type" || d === "degree" ? h[d] = l[d] : L[d] = l[d] : (L.red = g, L.green = m, L.blue = y, h.alpha = w, U && (h.points = U), R && (h.type = R), $ && (h.degree = $), T && (h.saturation = T), A && (h.value = A), C && (h.hue = C)); const B = I2(h.points, h.type, h.degree); h.style = B, !_.showBtn && a("change", { style: h.style, gradient: { type: h.type, degree: h.degree, points: h.points } }) } function i(l, d) { const { red: g = 0, green: m = 0, blue: y = 0, alpha: w, hue: C, saturation: T, value: A } = l; d ? h[d] = l[d] : (h.red = g, h.green = m, h.blue = y, w && (h.alpha = w), T && (h.saturation = T), A && (h.value = A), C && (h.hue = C)); const U = $2(h.red, h.green, h.blue, h.alpha); h.style = U, !_.showBtn && a("change", { style: U, color: { red: h.red, green: h.green, blue: h.blue, hue: h.hue, alpha: h.alpha } }) } const s = l => { l && typeof l == "function" && l() }, u = l => { const { isGradient: d, style: g, type: m, degree: y, points: w, red: C, green: T, blue: A, alpha: U, hue: R } = h; d ? a("change", { style: g, gradient: { type: m, degree: y, points: w } }) : a("change", { style: g, color: { red: C, green: T, blue: A, hue: R, alpha: U } }), l && typeof l == "function" && l() }; return Sn("colorPickerState", h), Sn("updateColor", n), t({ onClose: s, onConfirm: u }), (l, d) => (lt(), mt("div", H2, [(lt(), Rt(uc, null, { default: G(() => [_.isGradient ? (lt(), Rt(j(b), { key: 0 })) : (lt(), Rt(j(f), { key: 1 }))]), fallback: G(() => [V2]), _: 1 })), e.showBtn ? (lt(), mt("div", N2, [e.showCancel ? (lt(), mt("div", { key: 0, class: "btn", style: ai({ color: _.cancelColor, backgroundColor: _.cancelBg }), onClick: s }, yt(_.cancelText), 5)) : At("", !0), S("div", { class: "btn", style: ai({ color: _.confirmColor, backgroundColor: _.confirmBg }), onClick: u }, yt(_.confirmText), 5)])) : At("", !0)])) } })); const be = e => (me("data-v-3219f44f"), e = e(), ve(), e), G2 = { class: "box" }, X2 = be(() => S("span", { id: "gradient-button" }, "Gradient", -1)), K2 = be(() => S("span", null, "Solid Color", -1)), q2 = { key: 0 }, J2 = { class: "content" }, Z2 = { class: "cmyk-inputs" }, Q2 = { class: "custom-slider" }, tb = be(() => S("div", { class: "slider-component" }, [S("label", { for: "cInput" }, [S("b", null, "C")])], -1)), eb = { class: "slider-component-cyan" }, nb = { class: "slider-component" }, ib = be(() => S("span", null, [S("b", null, " %")], -1)), rb = { class: "custom-slider" }, sb = be(() => S("div", { class: "slider-component" }, [S("label", { for: "mInput" }, [S("b", null, "M")])], -1)), ob = { class: "slider-component-magenta" }, ab = { class: "slider-component" }, lb = be(() => S("span", null, [S("b", null, " %")], -1)), cb = { class: "custom-slider" }, ub = be(() => S("div", { class: "slider-component" }, [S("label", { for: "yInput" }, [S("b", null, "Y")])], -1)), hb = { class: "slider-component-yellow" }, fb = { class: "slider-component" }, db = be(() => S("span", null, [S("b", null, " %")], -1)), pb = { class: "custom-slider" }, gb = be(() => S("div", { class: "slider-component" }, [S("label", { for: "kInput" }, [S("b", null, "K")])], -1)), mb = { class: "slider-component-key" }, vb = { class: "slider-component" }, _b = be(() => S("span", null, [S("b", null, " %")], -1)), yb = be(() => S("p", null, "Remove", -1)), bb = [yb], wb = Dt({ name: "ColorSelector" }), Cb = Object.assign(wb, { props: { angleKey: { type: String, default: "gradientAngle" }, color: { type: [Object, String], default: "" } }, emits: ["change"], setup(e, { emit: t }) { var a = dt(0), p = dt(0), v = dt(0), _ = dt(0); const b = () => { const R = a.value / 100, $ = p.value / 100, L = v.value / 100, B = _.value / 100, N = Math.round(255 * (1 - R) * (1 - B)), K = Math.round(255 * (1 - $) * (1 - B)), st = Math.round(255 * (1 - L) * (1 - B)), ft = c(N, K, st); l = ft, s("change", ft) }, f = R => { const $ = h(R), L = $.r, B = $.g, N = $.b, K = typeof L == "number" && L >= 0 ? L / 255 : 0, st = typeof B == "number" && B >= 0 ? B / 255 : 0, ft = typeof N == "number" && N >= 0 ? N / 255 : 0, ht = Math.min(1 - K, 1 - st, 1 - ft); a.value = Math.round((1 - K - ht) / (1 - ht) * 100), p.value = Math.round((1 - st - ht) / (1 - ht) * 100), v.value = Math.round((1 - ft - ht) / (1 - ht) * 100), _.value = Math.round(ht * 100) }, r = () => { a.value = 0, p.value = 0, v.value = 0, _.value = 0, l = "#ffffff", s("change", "#ffffff") }, c = (R, $, L) => { const B = N => { const K = N.toString(16); return K.length === 1 ? "0" + K : K }; return R = Math.max(0, Math.min(255, R)), $ = Math.max(0, Math.min(255, $)), L = Math.max(0, Math.min(255, L)), "#" + B(R) + B($) + B(L) }; function h(R) { R = R.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (L, B, N, K) => B + B + N + N + K + K); const $ = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(R); return $ ? { r: parseInt($[1], 16), g: parseInt($[2], 16), b: parseInt($[3], 16) } : null } const { canvasEditor: n } = zt(), o = (R, $, L, B, N) => { const K = M => { const E = -parseInt(M, 10) * (Math.PI / 180); return { x1: Math.round(50 + Math.sin(E) * 50) / 100, y1: Math.round(50 + Math.cos(E) * 50) / 100, x2: Math.round(50 + Math.sin(E + Math.PI) * 50) / 100, y2: Math.round(50 + Math.cos(E + Math.PI) * 50) / 100 } }, st = M => { const E = K(N); return new Q.fabric.Gradient({ type: "linear", coords: { x1: E.x1 * $, y1: E.y1 * L, x2: E.x2 * $, y2: E.y2 * L }, colorStops: M }) }, ft = M => new Q.fabric.Gradient({ type: "radial", coords: { x1: $ / 2, y1: L / 2, r1: 0, x2: $ / 2, y2: L / 2, r2: $ / 2 }, colorStops: M }); let ht = {}; const k = [...R]; return B === "linear" ? ht = st(k) : B === "radial" && (ht = ft(k)), ht }, i = e, s = t, u = dt(!1); let l = dt(""); const d = dt("background: linear-gradient(124deg, rgb(28, 27, 27) 0%, rgb(255, 0, 0) 100%);"), g = ee({ type: "linear", degree: 0, points: [{ left: 0, red: 0, green: 0, blue: 0, alpha: 1 }, { left: 100, red: 255, green: 0, blue: 0, alpha: 1 }] }), m = R => { if (typeof R == "string") u.value = !1, l.value = R; else { u.value = !0; const $ = n.canvas.getActiveObjects()[0]; $ && (T(R, $), C(R)) } }, y = tn(function (R) { const $ = n.canvas.getActiveObjects()[0], { gradient: L } = R; if ($) { const B = A(L, $); s("change", B), $.set(i.angleKey, L.degree), w(R) } }, 500), w = R => { R.gradient.type === "linear" ? d.value = `background: ${R.style};` : d.value = `background: ${R.style.replace("radial", "linear")};` }, C = R => { R.colorStops.sort((L, B) => L.offset - B.offset); const $ = R.colorStops.map(L => `${L.color} ${L.offset * 100}%`); d.value = `background: linear-gradient(124deg, ${$});` }, T = (R, $) => { g.type = R.type, g.degree = $.get(i.angleKey, R.degree), g.points = R.colorStops.map(L => { const [B, N, K, st] = L.color.replace(/^rgba?\(|\s+|\)$/g, "").split(","); return { left: L.offset * 100, red: Number(B), green: Number(N), blue: Number(K), alpha: Number(st) } }) }, A = (R, $) => { const L = R.points.map(B => ({ offset: B.left / 100, color: `rgba(${B.red}, ${B.green}, ${B.blue}, ${B.alpha})` })); return o(L, $.width, $.height, R.type, R.degree) }, U = R => { f(R), s("change", R) }; return ue(() => { m(i.color) }), (R, $) => { const L = ut("iSwitch"), B = ut("ColorPicker"); return lt(), mt("div", G2, [I(L, { modelValue: j(u), "onUpdate:modelValue": $[0] || ($[0] = N => Pt(u) ? u.value = N : null), size: "large", class: "switch" }, { open: G(() => [X2]), close: G(() => [K2]), _: 1 }, 8, ["modelValue"]), j(u) ? (lt(), mt("div", q2, [S("div", { class: "gradient-bar", style: ai(j(d)) }, null, 4), I(j(Y2), { "is-gradient": !0, gradient: j(g), onChange: j(y), "cancel-text": R.$t("cancel"), "confirm-text": R.$t("ok") }, null, 8, ["gradient", "onChange", "cancel-text", "confirm-text"])])) : At("", !0), Ct(S("div", null, [S("div", J2, [S("div", Z2, [I(B, { modelValue: j(l), "onUpdate:modelValue": $[1] || ($[1] = N => Pt(l) ? l.value = N : l = N), onOnChange: U, basic: "" }, null, 8, ["modelValue"])]), S("div", Q2, [tb, S("div", eb, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[2] || ($[2] = N => Pt(a) ? a.value = N : a = N), "show-input": "" }, null, 544), [[Mt, j(a), void 0, { number: !0 }]])]), S("div", nb, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[3] || ($[3] = N => Pt(a) ? a.value = N : a = N), "show-input": "" }, null, 544), [[Mt, j(a), void 0, { number: !0 }]]), ib])]), S("div", rb, [sb, S("div", ob, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[4] || ($[4] = N => Pt(p) ? p.value = N : p = N), "show-input": "" }, null, 544), [[Mt, j(p), void 0, { number: !0 }]])]), S("div", ab, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[5] || ($[5] = N => Pt(p) ? p.value = N : p = N), "show-input": "" }, null, 544), [[Mt, j(p), void 0, { number: !0 }]]), lb])]), S("div", cb, [ub, S("div", hb, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[6] || ($[6] = N => Pt(v) ? v.value = N : v = N), "show-input": "" }, null, 544), [[Mt, j(v), void 0, { number: !0 }]])]), S("div", fb, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[7] || ($[7] = N => Pt(v) ? v.value = N : v = N), "show-input": "" }, null, 544), [[Mt, j(v), void 0, { number: !0 }]]), db])]), S("div", pb, [gb, S("div", mb, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[8] || ($[8] = N => Pt(_) ? _.value = N : _ = N), "show-input": "" }, null, 544), [[Mt, j(_), void 0, { number: !0 }]])]), S("div", vb, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: b, "onUpdate:modelValue": $[9] || ($[9] = N => Pt(_) ? _.value = N : _ = N), "show-input": "" }, null, 544), [[Mt, j(_), void 0, { number: !0 }]]), _b])]), S("div", null, [S("button", { class: "no-color-button", onClick: r }, bb)])])], 512), [[pe, !j(u)]])]) } } }), Sb = Yt(Cb, [["__scopeId", "data-v-3219f44f"]]); function Jr(e, t) { return t === void 0 && (t = 15), +parseFloat(Number(e).toPrecision(t)) } function Oe(e) { var t = e.toString().split(/[eE]/), a = (t[0].split(".")[1] || "").length - +(t[1] || 0); return a > 0 ? a : 0 } function Dn(e) { if (e.toString().indexOf("e") === -1) return Number(e.toString().replace(".", "")); var t = Oe(e); return t > 0 ? Jr(Number(e) * Math.pow(10, t)) : Number(e) } function fr(e) { yl && (e > Number.MAX_SAFE_INTEGER || e < Number.MIN_SAFE_INTEGER) && console.warn(e + " is beyond boundary when transfer to integer, the results may not be accurate") } function Oi(e) { return function () { for (var t = [], a = 0; a < arguments.length; a++)t[a] = arguments[a]; var p = t[0], v = t.slice(1); return v.reduce(function (_, b) { return e(_, b) }, p) } } var He = Oi(function (e, t) { var a = Dn(e), p = Dn(t), v = Oe(e) + Oe(t), _ = a * p; return fr(_), _ / Math.pow(10, v) }), xb = Oi(function (e, t) { var a = Math.pow(10, Math.max(Oe(e), Oe(t))); return (He(e, a) + He(t, a)) / a }), Tb = Oi(function (e, t) { var a = Math.pow(10, Math.max(Oe(e), Oe(t))); return (He(e, a) - He(t, a)) / a }), _l = Oi(function (e, t) { var a = Dn(e), p = Dn(t); return fr(a), fr(p), He(a / p, Jr(Math.pow(10, Oe(t) - Oe(e)))) }); function Ob(e, t) { var a = Math.pow(10, t), p = _l(Math.round(Math.abs(He(e, a))), a); return e < 0 && p !== 0 && (p = He(p, -1)), p } var yl = !0; function kb(e) { e === void 0 && (e = !0), yl = e } var Gn = { strip: Jr, plus: xb, minus: Tb, times: He, divide: _l, round: Ob, digitLength: Oe, float2Fixed: Dn, enableBoundaryChecking: kb }; const bl = e => (me("data-v-4c516747"), e = e(), ve(), e), Ab = bl(() => S("i", { class: "ivu-icon ivu-icon-ios-remove" }, null, -1)), Eb = [Ab], Pb = bl(() => S("i", { class: "ivu-icon ivu-icon-ios-add" }, null, -1)), Mb = [Pb], jb = ["aria-valuemax", "aria-valuemin", "aria-valuenow", "value", "disabled", "autofocus", "readonly", "placeholder"], le = "ivu-input-number", Xn = "ivu-icon", Db = 150, Lb = Dt({ __name: "inputNumber", props: { autofocus: { type: Boolean }, parser: {}, formatter: {}, min: { default: -1 / 0 }, max: { default: 1 / 0 }, precision: { default: 2 }, step: { default: 1 }, modelValue: {}, defaultValue: {}, modelEvent: { default: "change" }, controlsOutside: { type: Boolean }, hideButton: { type: Boolean }, downDisabled: { type: Boolean }, upDisabled: { type: Boolean }, size: { default: "default" }, disabled: { type: Boolean }, readonly: { type: Boolean }, placeholder: {}, append: {}, prepend: {} }, emits: ["update:modelValue", "on-change", "on-focus", "on-blur", "on-input"], setup(e, { expose: t, emit: a }) { var W; Gn.enableBoundaryChecking(!1); const p = e, v = a, _ = dt(`${le}-input-wrap`), b = dt(`${le}-input`), f = dt(`${le}-handler-wrap`), r = dt(`${le}-handler-up-inner ${Xn} ${Xn}-ios-arrow-up`), c = dt(`${le}-handler-down-inner ${Xn} ${Xn}-ios-arrow-down`), h = dt([`${le}-handler`, `${le}-handler-up`, { [`${le}-handler-up-disabled`]: p.upDisabled }]), n = dt([`${le}-handler`, `${le}-handler-down`, { [`${le}-handler-down-disabled`]: p.downDisabled }]), o = dt(!1), i = Wt(() => [`${le}`, { [`${le}-${p.size}`]: !!p.size, [`${le}-disabled`]: p.disabled, [`${le}-focused`]: o.value, [`${le}-controls-outside`]: p.controlsOutside }]), s = dt(), u = Wt(() => { if (ae(p.precision)) { const O = `${p.step}`.split(".")[1], x = O && O.length || 0; return Math.max(x, p.precision) } }), l = O => { var F, z; if (!ae(O)) return ""; const x = u.value ? O.toFixed(u.value).replace(/\.?0+$/, "") : String(O); return (z = (F = p.formatter) == null ? void 0 : F.call(p, x)) != null ? z : x }, d = dt(l((W = p.modelValue) != null ? W : p.defaultValue)), g = O => { o.value = !0, v("on-focus", O) }, m = O => { o.value = !1, v("on-blur", O) }, y = O => { $(O, "minus", !0) }, w = O => { $(O, "plus", !0) }, C = O => { O.key === "ArrowUp" ? (O.preventDefault(), !p.readonly && T("plus", O)) : O.key === "ArrowDown" && (O.preventDefault(), !p.readonly && T("minus", O)) }, T = (O, x) => { if (O === "plus" && (N.value || p.upDisabled) || O === "minus" && (B.value || p.downDisabled)) return; let F; ae(L.value) ? F = ft(Gn[O](L.value, p.step)) : F = p.min === -1 / 0 ? 0 : p.min, d.value = l(F), K(F), v("update:modelValue", F), v("on-change", F, x) }; let A = 0; const U = () => { A && (window.clearTimeout(A), A = 0) }, R = { onMouseup: U, onMouseleave: U }, $ = (O, x, F = !1) => { var z; O.preventDefault(), (z = s.value) == null || z.focus(), T(x, O), F && (A = window.setTimeout(() => O.target.dispatchEvent(O), Db)) }, L = Wt(() => { var x, F; if (!d.value) return; const O = Number((F = (x = p.parser) == null ? void 0 : x.call(p, d.value)) != null ? F : d.value); return Number.isNaN(O) ? void 0 : O }), B = dt(ae(L.value) && L.value <= p.min), N = dt(ae(L.value) && L.value >= p.max), K = O => { let x = !1, F = !1; ae(O) && (O <= p.min && (x = !0), O >= p.max && (F = !0)), N.value !== F && (N.value = F), B.value !== x && (B.value = x) }, st = O => { var F, z, q, X; let { value: x } = O.target; x = x.trim().replace(/。/g, "."), x = (z = (F = p.parser) == null ? void 0 : F.call(p, x)) != null ? z : x, (ae(Number(x)) || /^(\.|-)$/.test(x)) && (d.value = (X = (q = p.formatter) == null ? void 0 : q.call(p, x)) != null ? X : x, K(L.value), p.modelEvent === "input" && v("update:modelValue", L.value), v("on-input", L.value, d.value, O)) }, ft = O => { if (!xm(O)) return ae(p.min) && O < p.min && (O = p.min), ae(p.max) && O > p.max && (O = p.max), ae(u.value) ? Gn.round(O, u.value) : O }, ht = O => { const x = ft(L.value), F = l(x); (x !== L.value || d.value !== F) && (d.value = F, K(x)), No(() => { ae(p.modelValue) && p.modelValue !== x && (d.value = l(p.modelValue), K(p.modelValue)) }), v("update:modelValue", x), v("on-change", x, O) }, k = () => { const O = ft(L.value), x = l(O); (O !== L.value || d.value !== x) && (d.value = x), v("update:modelValue", O) }, M = dt(), E = dt(), P = O => { const x = dt(), { posStart: F, posEnd: z } = Gc(O, { threshold: 0, onSwipeStart: () => { x.value = L.value }, onSwipe: q => { if (!ae(x.value)) return; const X = x.value + Gn.round(z.x - F.x, 0) * p.step; d.value = l(X), p.modelEvent === "input" ? st(q) : ht(q) } }) }; return ue(() => { M.value && P(M), E.value && P(E) }), de(() => p.modelValue, O => { O !== L.value && (d.value = l(O), K(O)) }), de(() => p.min, O => { const x = ae(L.value) && L.value <= O; B.value !== x && (B.value = x), ae(L.value) && L.value < O && k() }), de(() => p.max, O => { const x = ae(L.value) && L.value >= O; N.value !== x && (N.value = x), ae(L.value) && L.value > O && k() }), t({ minus: y, plus: w, input: s.value, focus: () => { var O; (O = s.value) == null || O.focus() }, blur: () => { var O; (O = s.value) == null || O.blur() } }), (O, x) => (lt(), mt("div", { class: he(j(i)) }, [O.controlsOutside ? (lt(), mt(te, { key: 0 }, [S("div", Nn({ class: ["ivu-input-number-controls-outside-btn ivu-input-number-controls-outside-down", { "ivu-input-number-controls-outside-btn-disabled": O.downDisabled }], onMousedown: y }, R), Eb, 16), S("div", Nn({ class: ["ivu-input-number-controls-outside-btn ivu-input-number-controls-outside-up", { "ivu-input-number-controls-outside-btn-disabled": O.upDisabled }], onMousedown: w }, R), Mb, 16)], 64)) : O.hideButton ? At("", !0) : (lt(), mt("div", { key: 1, class: he(j(f)) }, [S("a", Nn({ class: j(h), onMousedown: w }, R), [S("span", { class: he(j(r)) }, null, 2)], 16), S("a", Nn({ class: j(n), onMousedown: y }, R), [S("span", { class: he(j(c)) }, null, 2)], 16)], 2)), S("div", { class: he(j(_)) }, [O.$slots.prefix ? cs(O.$slots, "prefix", { key: 0 }, void 0, !0) : O.append ? (lt(), mt("label", { key: 1, ref_key: "appendLabelRef", ref: M, class: he(`${j(_)}__label`) }, yt(O.append), 3)) : At("", !0), S("input", { ref_key: "inputRef", ref: s, type: "text", autocomplete: "off", spellcheck: "false", role: "spinbutton", "aria-valuemax": O.max, "aria-valuemin": O.min, "aria-valuenow": j(d), value: j(d), class: he(j(b)), disabled: O.disabled, autofocus: O.autofocus, readonly: O.readonly, placeholder: O.placeholder, onFocus: g, onBlur: m, onInput: st, onChange: ht, onKeydown: C }, null, 42, jb), O.$slots.suffix ? cs(O.$slots, "suffix", { key: 2 }, void 0, !0) : O.prepend ? (lt(), mt("label", { key: 3, ref_key: "prependLabelRef", ref: E, class: he(`${j(_)}__label`) }, yt(O.prepend), 3)) : At("", !0)], 2)], 2)) } }); const Ce = Yt(Lb, [["__scopeId", "data-v-4c516747"]]); const Ft = e => (me("data-v-53cda12e"), e = e(), ve(), e), Fb = { key: 0, class: "box" }, $b = Ft(() => S("span", null, "+", -1)), Ib = { key: 0, class: "font" }, Rb = { class: "flex-view" }, Bb = { class: "flex-item" }, zb = { class: "left font-selector" }, Ub = { key: 0, class: "font-item" }, Hb = { style: { display: "none" } }, Vb = { class: "right" }, Nb = { class: "flex-view" }, Wb = { class: "flex-item" }, Yb = ["innerHTML"], Gb = { class: "flex-view" }, Xb = { class: "flex-item" }, Kb = { viewBox: "0 0 1024 1024", width: "14", height: "14" }, qb = ["fill"], Jb = { viewBox: "0 0 1024 1024", width: "14", height: "14" }, Zb = ["fill"], Qb = { viewBox: "0 0 1024 1024", width: "14", height: "14" }, tw = ["fill"], ew = { viewBox: "0 0 1024 1024", width: "14", height: "14" }, nw = ["fill"], iw = Ft(() => S("span", null, "+", -1)), rw = { key: 1, class: "font-background-color" }, sw = { class: "cmyk-inputs" }, ow = { class: "custom-slider" }, aw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "cInput" }, [S("b", null, "C")])], -1)), lw = { class: "slider-component-cyan" }, cw = { class: "slider-component" }, uw = Ft(() => S("span", null, [S("b", null, " %")], -1)), hw = { class: "custom-slider" }, fw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "mInput" }, [S("b", null, "M")])], -1)), dw = { class: "slider-component-magenta" }, pw = { class: "slider-component" }, gw = Ft(() => S("span", null, [S("b", null, " %")], -1)), mw = { class: "custom-slider" }, vw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "yInput" }, [S("b", null, "Y")])], -1)), _w = { class: "slider-component-yellow" }, yw = { class: "slider-component" }, bw = Ft(() => S("span", null, [S("b", null, " %")], -1)), ww = { class: "custom-slider" }, Cw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "kInput" }, [S("b", null, "K")])], -1)), Sw = { class: "slider-component-key" }, xw = { class: "slider-component" }, Tw = Ft(() => S("span", null, [S("b", null, " %")], -1)), Ow = Ft(() => S("p", null, "Remove", -1)), kw = [Ow], Aw = Ft(() => S("span", null, "+", -1)), Ew = { key: 0 }, Pw = { class: "flex-view" }, Mw = { class: "flex-item", id: "angel" }, jw = { class: "label" }, Dw = { class: "content slider-box" }, Lw = { class: "flex-view" }, Fw = { class: "flex-item", id: "angel" }, $w = { class: "label" }, Iw = { class: "content slider-box" }, Rw = Ft(() => S("span", null, "+", -1)), Bw = { key: 1, class: "stroke" }, zw = { class: "ivu-col__box" }, Uw = { class: "content" }, Hw = { class: "cmyk-inputs" }, Vw = { class: "custom-slider" }, Nw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "cInput" }, [S("b", null, "C")])], -1)), Ww = { class: "slider-component-cyan" }, Yw = { class: "slider-component" }, Gw = Ft(() => S("span", null, [S("b", null, " %")], -1)), Xw = { class: "custom-slider" }, Kw = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "mInput" }, [S("b", null, "M")])], -1)), qw = { class: "slider-component-magenta" }, Jw = { class: "slider-component" }, Zw = Ft(() => S("span", null, [S("b", null, " %")], -1)), Qw = { class: "custom-slider" }, tC = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "yInput" }, [S("b", null, "Y")])], -1)), eC = { class: "slider-component-yellow" }, nC = { class: "slider-component" }, iC = Ft(() => S("span", null, [S("b", null, " %")], -1)), rC = { class: "custom-slider" }, sC = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "kInput" }, [S("b", null, "K")])], -1)), oC = { class: "slider-component-key" }, aC = { class: "slider-component" }, lC = Ft(() => S("span", null, [S("b", null, " %")], -1)), cC = Ft(() => S("p", null, "Remove", -1)), uC = [cC], hC = { class: "ivu-col__box" }, fC = { class: "ivu-col__box" }, dC = { class: "label" }, pC = { class: "content" }, gC = Ft(() => S("span", null, "+", -1)), mC = { key: 2 }, vC = { class: "ivu-col__box" }, _C = { class: "content" }, yC = { class: "cmyk-inputs" }, bC = { class: "custom-slider" }, wC = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "cInput" }, [S("b", null, "C")])], -1)), CC = { class: "slider-component-cyan" }, SC = { class: "slider-component" }, xC = Ft(() => S("span", null, [S("b", null, " %")], -1)), TC = { class: "custom-slider" }, OC = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "mInput" }, [S("b", null, "M")])], -1)), kC = { class: "slider-component-magenta" }, AC = { class: "slider-component" }, EC = Ft(() => S("span", null, [S("b", null, " %")], -1)), PC = { class: "custom-slider" }, MC = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "yInput" }, [S("b", null, "Y")])], -1)), jC = { class: "slider-component-yellow" }, DC = { class: "slider-component" }, LC = Ft(() => S("span", null, [S("b", null, " %")], -1)), FC = { class: "custom-slider" }, $C = Ft(() => S("div", { class: "slider-component" }, [S("label", { for: "kInput" }, [S("b", null, "K")])], -1)), IC = { class: "slider-component-key" }, RC = { class: "slider-component" }, BC = Ft(() => S("span", null, [S("b", null, " %")], -1)), zC = Ft(() => S("p", null, "Remove", -1)), UC = [zC], HC = Dt({ name: "AttrBute" }), VC = Object.assign(HC, { setup(e) { const t = Ue("event"), a = di(), p = "https://nihaojob.github.io/vue-fabric-editor-static/", { fabric: v, mixinState: _, canvasEditor: b } = zt(), f = dt(!1), r = dt(!1), c = dt(!1), h = dt(!1), n = dt(!1), o = () => { n.value = !n.value }, i = () => { h.value = !h.value }, s = () => { r.value = !r.value }, u = () => { f.value = !f.value }, l = () => { c.value = !c.value }, d = ["i-text", "textbox", "text"], g = ee({ id: "", opacity: 0, angle: 0, fill: "#fff", left: 0, top: 0, strokeWidth: 0, strokeDashArray: [], stroke: "#fff", shadow: { color: "#fff", blur: 0, offsetX: 0, offsetY: 0 }, points: {} }), m = ee({ fontSize: 0, fontFamily: "", lineHeight: 0, charSpacing: 0, fontWeight: "", textBackgroundColor: "#fff", textAlign: "", fontStyle: "", underline: !1, linethrough: !1, overline: !1 }), y = dt([...h0]), w = [{ value: { strokeUniform: !0, strokeDashArray: [], strokeLineCap: "butt" }, label: "Stroke" }, { value: { strokeUniform: !0, strokeDashArray: [1, 10], strokeLineCap: "butt" }, label: "Dash-1" }, { value: { strokeUniform: !0, strokeDashArray: [1, 10], strokeLineCap: "round" }, label: "Dash-2" }, { value: { strokeUniform: !0, strokeDashArray: [15, 15], strokeLineCap: "square" }, label: "Dash-3" }, { value: { strokeUniform: !0, strokeDashArray: [15, 15], strokeLineCap: "round" }, label: "Dash-4" }, { value: { strokeUniform: !0, strokeDashArray: [25, 25], strokeLineCap: "square" }, label: "Dash-5" }, { value: { strokeUniform: !0, strokeDashArray: [25, 25], strokeLineCap: "round" }, label: "Dash-6" }, { value: { strokeUniform: !0, strokeDashArray: [1, 8, 16, 8, 1, 20], strokeLineCap: "square" }, label: "Dash-7" }, { value: { strokeUniform: !0, strokeDashArray: [1, 8, 16, 8, 1, 20], strokeLineCap: "round" }, label: "Dash-8" }], C = ["left", "center", "right"], T = ['<svg t="1650441458823" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3554" width="18" height="18"><path d="M198.4 198.4h341.333333c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533334 19.2v57.6c0 8.533333-2.133333 14.933333-8.533334 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-341.333333c-8.533333 0-14.933333-2.133333-19.2-8.533334-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533333z m0 170.666667h569.6c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333h-569.6c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533333z m0 170.666666h454.4c8.533333 0 14.933333 2.133333 19.2 8.533334 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333h-454.4c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533334z m0 170.666667h625.066667c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-625.066667c-8.533333 0-14.933333-2.133333-19.2-8.533334-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533333z" p-id="3555"></path></svg>', '<svg t="1650441512015" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3704" width="18" height="18"><path d="M313.6 198.4h398.933333c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533334 19.2v57.6c0 8.533333-2.133333 14.933333-8.533334 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-398.933333c-8.533333 0-14.933333-2.133333-19.2-8.533334-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 10.666667-8.533333 19.2-8.533333z m-115.2 170.666667h625.066667c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333h-625.066667c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533333z m115.2 170.666666h398.933333c8.533333 0 14.933333 2.133333 19.2 8.533334 6.4 6.4 8.533333 12.8 8.533334 19.2v57.6c0 8.533333-2.133333 14.933333-8.533334 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333h-398.933333c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 10.666667-8.533333 19.2-8.533334z m-115.2 170.666667h625.066667c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-625.066667c-8.533333 0-14.933333-2.133333-19.2-8.533334-6.4-6.4-8.533333-12.8-8.533333-19.2v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 4.266667-4.266667 12.8-8.533333 19.2-8.533333z" p-id="3705"></path></svg>', '<svg t="1650441519862" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="18" height="18"><path d="M454.4 283.733333v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 6.4-6.4 12.8-8.533333 19.2-8.533333h341.333334c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-341.333334c-8.533333 0-14.933333-2.133333-19.2-8.533334-4.266667-4.266667-8.533333-10.666667-8.533333-19.2z m-226.133333 170.666667v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 6.4-6.4 12.8-8.533333 19.2-8.533333h569.6c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333H256c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-4.266667-8.533333-10.666667-8.533333-19.2z m113.066666 170.666667v-57.6c0-8.533333 2.133333-14.933333 8.533334-19.2 6.4-6.4 12.8-8.533333 19.2-8.533334h454.4c8.533333 0 14.933333 2.133333 19.2 8.533334 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533333h-454.4c-8.533333 0-14.933333-2.133333-19.2-8.533333-6.4-4.266667-8.533333-10.666667-8.533334-19.2z m-170.666666 170.666666v-57.6c0-8.533333 2.133333-14.933333 8.533333-19.2 6.4-6.4 12.8-8.533333 19.2-8.533333h625.066667c8.533333 0 14.933333 2.133333 19.2 8.533333 6.4 6.4 8.533333 12.8 8.533333 19.2v57.6c0 8.533333-2.133333 14.933333-8.533333 19.2-6.4 6.4-12.8 8.533333-19.2 8.533334h-625.066667c-8.533333 0-14.933333-2.133333-19.2-8.533334-6.4-4.266667-8.533333-10.666667-8.533333-19.2z" p-id="3855"></path></svg>'], A = () => { Te.get(`${p}/font/free-font.json`).then(et => { y.value = [...y.value, ...Object.entries(et.data).map(([, D]) => D)] }) }, U = et => { const D = b.canvas.getActiveObject(); et && et.target && et.target !== D || D && (g.id = D.get("id"), g.opacity = D.get("opacity") * 100, g.fill = D.get("fill"), g.left = D.get("left"), g.top = D.get("top"), g.stroke = D.get("stroke"), g.strokeWidth = D.get("strokeWidth"), g.shadow = D.get("shadow") || {}, g.angle = D.get("angle") || 0, g.points = D.get("points") || {}, ["i-text", "text", "textbox"].includes(D.type) && (m.fontSize = D.get("fontSize"), m.fontFamily = D.get("fontFamily"), m.lineHeight = D.get("lineHeight"), m.textAlign = D.get("textAlign"), m.underline = D.get("underline"), m.linethrough = D.get("linethrough"), m.charSpacing = D.get("charSpacing"), m.overline = D.get("overline"), m.fontStyle = D.get("fontStyle"), m.textBackgroundColor = D.get("textBackgroundColor"), m.fontWeight = D.get("fontWeight"))) }, R = () => { var et; g.fill = "", (et = a == null ? void 0 : a.proxy) == null || et.$forceUpdate() }, $ = () => { A(), t.on("selectCancel", R), t.on("selectOne", U), b.canvas.on("object:modified", U) }; var L = dt(0), B = dt(0), N = dt(0), K = dt(0), st = dt(0), ft = dt(0), ht = dt(0), k = dt(0), M = dt(0), E = dt(0), P = dt(0), W = dt(0), O = 0; const x = () => { const et = L.value / 100, D = B.value / 100, vt = N.value / 100, _t = K.value / 100, Tt = Math.round(255 * (1 - et) * (1 - _t)), $t = Math.round(255 * (1 - D) * (1 - _t)), Gt = Math.round(255 * (1 - vt) * (1 - _t)), It = J(Tt, $t, Gt); O = 1, Y("textBackgroundColor", It), m.textBackgroundColor = It }, F = et => { const D = H(et), vt = D.r, _t = D.g, Tt = D.b, $t = typeof vt == "number" && vt >= 0 ? vt / 255 : 0, Gt = typeof _t == "number" && _t >= 0 ? _t / 255 : 0, It = typeof Tt == "number" && Tt >= 0 ? Tt / 255 : 0, jt = Math.min(1 - $t, 1 - Gt, 1 - It); L.value = Math.round((1 - $t - jt) / (1 - jt) * 100), B.value = Math.round((1 - Gt - jt) / (1 - jt) * 100), N.value = Math.round((1 - It - jt) / (1 - jt) * 100), K.value = Math.round(jt * 100) }, z = () => { L.value = 0, B.value = 0, N.value = 0, K.value = 0; const et = "#ffffff"; O = 1, Y("textBackgroundColor", et), m.textBackgroundColor = et }, q = () => { const et = M.value / 100, D = E.value / 100, vt = P.value / 100, _t = W.value / 100, Tt = Math.round(255 * (1 - et) * (1 - _t)), $t = Math.round(255 * (1 - D) * (1 - _t)), Gt = Math.round(255 * (1 - vt) * (1 - _t)), It = J(Tt, $t, Gt); O = 1, g.shadow.color = It, Y("color", It) }, X = et => { const D = H(et), vt = D.r, _t = D.g, Tt = D.b, $t = typeof vt == "number" && vt >= 0 ? vt / 255 : 0, Gt = typeof _t == "number" && _t >= 0 ? _t / 255 : 0, It = typeof Tt == "number" && Tt >= 0 ? Tt / 255 : 0, jt = Math.min(1 - $t, 1 - Gt, 1 - It); M.value = Math.round((1 - $t - jt) / (1 - jt) * 100), E.value = Math.round((1 - Gt - jt) / (1 - jt) * 100), P.value = Math.round((1 - It - jt) / (1 - jt) * 100), W.value = Math.round(jt * 100) }, ot = () => { M.value = 0, E.value = 0, P.value = 0, W.value = 0; const et = "#ffffff"; O = 1, Y("shadow", et), m.textBackgroundColor = et }, ct = () => { const et = st.value / 100, D = ft.value / 100, vt = ht.value / 100, _t = k.value / 100, Tt = Math.round(255 * (1 - et) * (1 - _t)), $t = Math.round(255 * (1 - D) * (1 - _t)), Gt = Math.round(255 * (1 - vt) * (1 - _t)), It = J(Tt, $t, Gt); O = 1, Y("stroke", It), g.stroke = It }, gt = et => { const D = H(et), vt = D.r, _t = D.g, Tt = D.b, $t = typeof vt == "number" && vt >= 0 ? vt / 255 : 0, Gt = typeof _t == "number" && _t >= 0 ? _t / 255 : 0, It = typeof Tt == "number" && Tt >= 0 ? Tt / 255 : 0, jt = Math.min(1 - $t, 1 - Gt, 1 - It); st.value = Math.round((1 - $t - jt) / (1 - jt) * 100), ft.value = Math.round((1 - Gt - jt) / (1 - jt) * 100), ht.value = Math.round((1 - It - jt) / (1 - jt) * 100), k.value = Math.round(jt * 100) }, J = (et, D, vt) => { const _t = Tt => { const $t = Tt.toString(16); return $t.length === 1 ? "0" + $t : $t }; return et = Math.max(0, Math.min(255, et)), D = Math.max(0, Math.min(255, D)), vt = Math.max(0, Math.min(255, vt)), "#" + _t(et) + _t(D) + _t(vt) }; function H(et) { et = et.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (vt, _t, Tt, $t) => _t + _t + Tt + Tt + $t + $t); const D = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(et); return D ? { r: parseInt(D[1], 16), g: parseInt(D[2], 16), b: parseInt(D[3], 16) } : null } const nt = () => { st.value = 0, ft.value = 0, ht.value = 0, k.value = 0; const et = "#ffff"; Y("stroke", et), m.textBackgroundColor = et }, it = et => { if (!et) return; if (["arial", "Microsoft YaHei"].includes(et)) { const _t = b.canvas.getActiveObjects()[0]; _t && _t.set("fontFamily", et), b.canvas.renderAll(); return } qt.Spin.show(), new Yo(et).load(null, 15e4).then(() => { const _t = b.canvas.getActiveObjects()[0]; _t && _t.set("fontFamily", et), b.canvas.renderAll(), qt.Spin.hide() }).catch(() => { qt.Spin.hide() }) }, Y = (et, D) => { const vt = b.canvas.getActiveObjects()[0]; if (et === "opacity") { vt && vt.set(et, D / 100), b.canvas.renderAll(); return } if (et === "angle") { vt.rotate(D), b.canvas.renderAll(); return } vt && vt.set(et, D), b.canvas.renderAll(), U(), O === 0 && et === "textBackgroundColor" && F(D), O === 0 && et === "textBackgroundColor" && F(D), O === 0 && et === "color" && X(D), O === 0 && et === "stroke" && gt(D), O = 0 }, at = et => { const D = b.canvas.getActiveObjects()[0]; if (D) { const vt = w.find(_t => _t.label === et); D.set(vt.value), b.canvas.renderAll() } }, pt = () => { const et = b.canvas.getActiveObjects()[0]; et && et.set("shadow", new v.Shadow(g.shadow)), b.canvas.renderAll() }, St = (et, D) => { const vt = D === "normal" ? "bold" : "normal"; m.fontWeight = vt; const _t = b.canvas.getActiveObjects()[0]; _t && _t.set(et, vt), b.canvas.renderAll() }, bt = (et, D) => { const vt = D === "normal" ? "italic" : "normal"; m.fontStyle = vt; const _t = b.canvas.getActiveObjects()[0]; _t && _t.set(et, vt), b.canvas.renderAll() }, tt = (et, D) => { const vt = D === !1; m.linethrough = vt; const _t = b.canvas.getActiveObjects()[0]; _t && _t.set(et, vt), b.canvas.renderAll() }, wt = (et, D) => { const vt = D === !1; m.underline = vt; const _t = b.canvas.getActiveObjects()[0]; _t && _t.set(et, vt), b.canvas.renderAll() }, kt = et => { const D = b.canvas.getActiveObjects(); !D || !D.length || (D[0].set("points", Xa(et, Math.min(D[0].width, D[0].height) / 2)), b.canvas.requestRenderAll()) }; return ue($), In(() => { t.off("selectCancel", R), t.off("selectOne", U), b.canvas.off("object:modified", U) }), (et, D) => { const vt = ut("Option"), _t = ut("Select"), Tt = ut("Radio"), $t = ut("RadioGroup"), Gt = ut("Button"), It = ut("ButtonGroup"), jt = ut("Col"), we = ut("Row"), _n = ut("ColorPicker"), Hn = ut("Slider"); return j(_).mSelectMode === "one" ? (lt(), mt("div", Fb, [Ct(S("div", null, [S("div", { class: "dropdown cstmStyle", plain: "", orientation: "left", onClick: s }, [S("span", null, yt(et.$t("attributes.font")), 1), $b]), r.value ? (lt(), mt("div", Ib, [S("div", Rb, [S("div", Bb, [S("div", zb, [I(_t, { modelValue: j(m).fontFamily, "onUpdate:modelValue": D[0] || (D[0] = V => j(m).fontFamily = V), onOnChange: it }, { default: G(() => [(lt(!0), mt(te, null, ce(y.value, V => (lt(), Rt(vt, { value: V.name, key: `font-${V.name}` }, { default: G(() => [V.preview ? (lt(), mt("div", { key: 1, class: "font-item", style: ai(`background-image:url('${V.preview}');`) }, [xt(yt(V.preview ? "" : V) + " ", 1), S("span", Hb, yt(V.name), 1)], 4)) : (lt(), mt("div", Ub, yt(V.name), 1))]), _: 2 }, 1032, ["value"]))), 128))]), _: 1 }, 8, ["modelValue"])]), S("div", Vb, [I(j(Ce), { modelValue: j(m).fontSize, "onUpdate:modelValue": D[1] || (D[1] = V => j(m).fontSize = V), onOnChange: D[2] || (D[2] = V => Y("fontSize", V)), append: "Font size", min: 1 }, null, 8, ["modelValue"])])])]), S("div", Nb, [S("div", Wb, [I($t, { class: "button-group", modelValue: j(m).textAlign, "onUpdate:modelValue": D[3] || (D[3] = V => j(m).textAlign = V), onOnChange: D[4] || (D[4] = V => Y("textAlign", V)), type: "button" }, { default: G(() => [(lt(), mt(te, null, ce(C, (V, Ql) => I(Tt, { label: V, key: V }, { default: G(() => [S("span", { innerHTML: T[Ql] }, null, 8, Yb)]), _: 2 }, 1032, ["label"])), 64))]), _: 1 }, 8, ["modelValue"])])]), S("div", Gb, [S("div", Xb, [I(It, { class: "button-group" }, { default: G(() => [I(Gt, { onClick: D[5] || (D[5] = V => St("fontWeight", j(m).fontWeight)) }, { default: G(() => [(lt(), mt("svg", Kb, [S("path", { d: "M793.99865 476a244 244 0 0 0 54-130.42C862.75865 192.98 743.01865 64 593.85865 64H195.01865a32 32 0 0 0-32 32v96a32 32 0 0 0 32 32h63.74v576H195.01865a32 32 0 0 0-32 32v96a32 32 0 0 0 32 32h418.64c141.6 0 268.28-103.5 282-244.8 9.48-96.9-32.78-184.12-101.66-239.2zM418.33865 224h175.52a96 96 0 0 1 0 192h-175.52z m175.52 576h-175.52V576h175.52a112 112 0 0 1 0 224z", fill: j(m).fontWeight === "bold" ? "#305ef4" : "#666" }, null, 8, qb)]))]), _: 1 }), I(Gt, { onClick: D[6] || (D[6] = V => bt("fontStyle", j(m).fontStyle)) }, { default: G(() => [(lt(), mt("svg", Jb, [S("path", { d: "M832 96v64a32 32 0 0 1-32 32h-125.52l-160 640H608a32 32 0 0 1 32 32v64a32 32 0 0 1-32 32H224a32 32 0 0 1-32-32v-64a32 32 0 0 1 32-32h125.52l160-640H416a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h384a32 32 0 0 1 32 32z", fill: j(m).fontStyle === "italic" ? "#305ef4" : "#666" }, null, 8, Zb)]))]), _: 1 }), I(Gt, { onClick: D[7] || (D[7] = V => tt("linethrough", j(m).linethrough)) }, { default: G(() => [(lt(), mt("svg", Qb, [S("path", { d: "M893.088 501.792H125.344a32 32 0 0 0 0 64h767.744a32 32 0 0 0 0-64zM448 448h112V208h288V96H160v112h288zM448 640h112v288H448z", fill: j(m).linethrough ? "#305ef4" : "#666" }, null, 8, tw)]))]), _: 1 }), I(Gt, { onClick: D[8] || (D[8] = V => wt("underline", j(m).underline)) }, { default: G(() => [(lt(), mt("svg", ew, [S("path", { d: "M703.232 67.008h127.488v413.248c0 158.016-142.656 286.016-318.72 286.016-176 0-318.72-128-318.72-286.016V67.008h127.488v413.248c0 39.872 18.176 78.144 51.136 107.776 36.8 32.96 86.528 51.072 140.096 51.072s103.36-18.112 140.032-51.136c33.024-29.632 51.2-67.968 51.2-107.776V67.008zM193.28 871.616h637.44v85.376H193.28v-85.376z", fill: j(m).underline ? "#305ef4" : "#666" }, null, 8, nw)]))]), _: 1 })]), _: 1 })])]), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(m).lineHeight, "onUpdate:modelValue": D[9] || (D[9] = V => j(m).lineHeight = V), onOnChange: D[10] || (D[10] = V => Y("lineHeight", V)), step: .1, append: et.$t("attributes.line_height") }, null, 8, ["modelValue", "append"])]), _: 1 }), I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(m).charSpacing, "onUpdate:modelValue": D[11] || (D[11] = V => j(m).charSpacing = V), onOnChange: D[12] || (D[12] = V => Y("charSpacing", V)), append: et.$t("attributes.char_spacing") }, null, 8, ["modelValue", "append"])]), _: 1 })]), _: 1 })])) : At("", !0), S("div", { class: "dropdown cstmStyle", plain: "", orientation: "left", onClick: u }, [S("span", null, yt(et.$t("background")), 1), iw]), f.value ? (lt(), mt("div", rw, [S("div", sw, [I(_n, { modelValue: j(m).textBackgroundColor, "onUpdate:modelValue": D[13] || (D[13] = V => j(m).textBackgroundColor = V), onOnChange: D[14] || (D[14] = V => Y("textBackgroundColor", V)), basic: "" }, null, 8, ["modelValue"])]), S("div", ow, [aw, S("div", lw, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[15] || (D[15] = V => Pt(L) ? L.value = V : L = V), "show-input": "" }, null, 544), [[Mt, j(L), void 0, { number: !0 }]])]), S("div", cw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: D[16] || (D[16] = V => x()), "onUpdate:modelValue": D[17] || (D[17] = V => Pt(L) ? L.value = V : L = V), "show-input": "" }, null, 544), [[Mt, j(L), void 0, { number: !0 }]]), uw])]), S("div", hw, [fw, S("div", dw, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[18] || (D[18] = V => Pt(B) ? B.value = V : B = V), "show-input": "" }, null, 544), [[Mt, j(B), void 0, { number: !0 }]])]), S("div", pw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[19] || (D[19] = V => Pt(B) ? B.value = V : B = V), "show-input": "" }, null, 544), [[Mt, j(B), void 0, { number: !0 }]]), gw])]), S("div", mw, [vw, S("div", _w, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[20] || (D[20] = V => Pt(N) ? N.value = V : N = V), "show-input": "" }, null, 544), [[Mt, j(N), void 0, { number: !0 }]])]), S("div", yw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[21] || (D[21] = V => Pt(N) ? N.value = V : N = V), "show-input": "" }, null, 544), [[Mt, j(N), void 0, { number: !0 }]]), bw])]), S("div", ww, [Cw, S("div", Sw, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[22] || (D[22] = V => Pt(K) ? K.value = V : K = V), "show-input": "" }, null, 544), [[Mt, j(K), void 0, { number: !0 }]])]), S("div", xw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: x, "onUpdate:modelValue": D[23] || (D[23] = V => Pt(K) ? K.value = V : K = V), "show-input": "" }, null, 544), [[Mt, j(K), void 0, { number: !0 }]]), Tw])]), S("div", { class: "button-div" }, [S("button", { class: "no-color-button", onClick: z }, kw)])])) : At("", !0)], 512), [[pe, d.includes(j(_).mSelectOneType)]]), S("div", null, [S("div", { class: "dropdown cstmStyle", plain: "", orientation: "left", onClick: o }, [S("span", null, yt(et.$t("attributes.exterior")), 1), Aw]), n.value ? (lt(), mt("div", Ew, [j(_).mSelectOneType === "polygon" ? (lt(), Rt(we, { key: 0, gutter: 12 }, { default: G(() => [I(jt, { flex: "0.5" }, { default: G(() => [I(j(Ce), { modelValue: j(g).points.length, "onUpdate:modelValue": D[24] || (D[24] = V => j(g).points.length = V), min: 3, max: 30, onOnChange: kt, append: "Number of sides" }, null, 8, ["modelValue"])]), _: 1 })]), _: 1 })) : At("", !0), I(Sb, { color: j(g).fill, onChange: D[25] || (D[25] = V => Y("fill", V)) }, null, 8, ["color"]), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(g).left, "onUpdate:modelValue": D[26] || (D[26] = V => j(g).left = V), onOnChange: D[27] || (D[27] = V => Y("left", V)), append: et.$t("attributes.left") }, null, 8, ["modelValue", "append"])]), _: 1 }), I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(g).top, "onUpdate:modelValue": D[28] || (D[28] = V => j(g).top = V), onOnChange: D[29] || (D[29] = V => Y("top", V)), append: et.$t("attributes.top") }, null, 8, ["modelValue", "append"])]), _: 1 })]), _: 1 }), S("div", Pw, [S("div", Mw, [S("span", jw, yt(et.$t("attributes.angle")), 1), S("div", Dw, [I(Hn, { modelValue: j(g).angle, "onUpdate:modelValue": D[30] || (D[30] = V => j(g).angle = V), max: 360, onOnInput: D[31] || (D[31] = V => Y("angle", V)) }, null, 8, ["modelValue"])])])]), S("div", Lw, [S("div", Fw, [S("span", $w, yt(et.$t("attributes.opacity")), 1), S("div", Iw, [I(Hn, { modelValue: j(g).opacity, "onUpdate:modelValue": D[32] || (D[32] = V => j(g).opacity = V), onOnInput: D[33] || (D[33] = V => Y("opacity", V)) }, null, 8, ["modelValue"])])])])])) : At("", !0), S("div", { class: "dropdown cstmStyle", plain: "", orientation: "left", onClick: l }, [S("span", null, yt(et.$t("attributes.stroke")), 1), Rw]), c.value ? (lt(), mt("div", Bw, [S("div", zw, [S("div", Uw, [S("div", Hw, [I(_n, { modelValue: j(g).stroke, "onUpdate:modelValue": D[34] || (D[34] = V => j(g).stroke = V), onOnChange: D[35] || (D[35] = V => Y("stroke", V)), basic: "" }, null, 8, ["modelValue"])]), S("div", Vw, [Nw, S("div", Ww, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[36] || (D[36] = V => Pt(st) ? st.value = V : st = V), "show-input": "" }, null, 544), [[Mt, j(st), void 0, { number: !0 }]])]), S("div", Yw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[37] || (D[37] = V => Pt(st) ? st.value = V : st = V), "show-input": "" }, null, 544), [[Mt, j(st), void 0, { number: !0 }]]), Gw])]), S("div", Xw, [Kw, S("div", qw, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[38] || (D[38] = V => Pt(ft) ? ft.value = V : ft = V), "show-input": "" }, null, 544), [[Mt, j(ft), void 0, { number: !0 }]])]), S("div", Jw, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[39] || (D[39] = V => Pt(ft) ? ft.value = V : ft = V), "show-input": "" }, null, 544), [[Mt, j(ft), void 0, { number: !0 }]]), Zw])]), S("div", Qw, [tC, S("div", eC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[40] || (D[40] = V => Pt(ht) ? ht.value = V : ht = V), "show-input": "" }, null, 544), [[Mt, j(ht), void 0, { number: !0 }]])]), S("div", nC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[41] || (D[41] = V => Pt(ht) ? ht.value = V : ht = V), "show-input": "" }, null, 544), [[Mt, j(ht), void 0, { number: !0 }]]), iC])]), S("div", rC, [sC, S("div", oC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[42] || (D[42] = V => Pt(k) ? k.value = V : k = V), "show-input": "" }, null, 544), [[Mt, j(k), void 0, { number: !0 }]])]), S("div", aC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: ct, "onUpdate:modelValue": D[43] || (D[43] = V => Pt(k) ? k.value = V : k = V), "show-input": "" }, null, 544), [[Mt, j(k), void 0, { number: !0 }]]), lC])]), S("div", null, [S("button", { class: "no-color-button", onClick: nt }, uC)])])]), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [S("div", hC, [I(j(Ce), { modelValue: j(g).strokeWidth, "onUpdate:modelValue": D[44] || (D[44] = V => j(g).strokeWidth = V), onOnChange: D[45] || (D[45] = V => Y("strokeWidth", V)), append: et.$t("width"), min: 0 }, null, 8, ["modelValue", "append"])])]), _: 1 })]), _: 1 }), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [S("div", fC, [S("span", dC, yt(et.$t("attributes.stroke")), 1), S("div", pC, [I(_t, { modelValue: j(g).strokeDashArray, "onUpdate:modelValue": D[46] || (D[46] = V => j(g).strokeDashArray = V), onOnChange: at }, { default: G(() => [(lt(), mt(te, null, ce(w, V => I(vt, { value: V.label, key: `stroke-${V.label}` }, { default: G(() => [xt(yt(V.label), 1)]), _: 2 }, 1032, ["value"])), 64))]), _: 1 }, 8, ["modelValue"])])])]), _: 1 })]), _: 1 })])) : At("", !0), S("div", { class: "dropdown cstmStyle", plain: "", orientation: "left", onClick: i }, [S("span", null, yt(et.$t("attributes.shadow")), 1), gC]), h.value ? (lt(), mt("div", mC, [S("div", vC, [S("div", _C, [S("div", yC, [I(_n, { modelValue: j(g).shadow.color, "onUpdate:modelValue": D[47] || (D[47] = V => j(g).shadow.color = V), onOnChange: D[48] || (D[48] = V => Y("color", V)), basic: "" }, null, 8, ["modelValue"])]), S("div", bC, [wC, S("div", CC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[49] || (D[49] = V => Pt(M) ? M.value = V : M = V), "show-input": "" }, null, 544), [[Mt, j(M), void 0, { number: !0 }]])]), S("div", SC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[50] || (D[50] = V => Pt(M) ? M.value = V : M = V), "show-input": "" }, null, 544), [[Mt, j(M), void 0, { number: !0 }]]), xC])]), S("div", TC, [OC, S("div", kC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[51] || (D[51] = V => Pt(E) ? E.value = V : E = V), "show-input": "" }, null, 544), [[Mt, j(E), void 0, { number: !0 }]])]), S("div", AC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[52] || (D[52] = V => Pt(E) ? E.value = V : E = V), "show-input": "" }, null, 544), [[Mt, j(E), void 0, { number: !0 }]]), EC])]), S("div", PC, [MC, S("div", jC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[53] || (D[53] = V => Pt(P) ? P.value = V : P = V), "show-input": "" }, null, 544), [[Mt, j(P), void 0, { number: !0 }]])]), S("div", DC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[54] || (D[54] = V => Pt(P) ? P.value = V : P = V), "show-input": "" }, null, 544), [[Mt, j(P), void 0, { number: !0 }]]), LC])]), S("div", FC, [$C, S("div", IC, [Ct(S("input", { class: "slider", type: "range", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[55] || (D[55] = V => Pt(W) ? W.value = V : W = V), "show-input": "" }, null, 544), [[Mt, j(W), void 0, { number: !0 }]])]), S("div", RC, [Ct(S("input", { class: "slider-input", type: "number", min: "0", max: "100", onChange: q, "onUpdate:modelValue": D[56] || (D[56] = V => Pt(W) ? W.value = V : W = V), "show-input": "" }, null, 544), [[Mt, j(W), void 0, { number: !0 }]]), BC])]), S("button", { class: "no-color-button", onClick: ot }, UC)])]), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(g).shadow.blur, "onUpdate:modelValue": D[57] || (D[57] = V => j(g).shadow.blur = V), defaultValue: 0, onOnChange: D[58] || (D[58] = V => pt("blur", V)), append: et.$t("attributes.blur"), min: 0 }, null, 8, ["modelValue", "append"])]), _: 1 })]), _: 1 }), I(we, { gutter: 12 }, { default: G(() => [I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(g).shadow.offsetX, "onUpdate:modelValue": D[59] || (D[59] = V => j(g).shadow.offsetX = V), defaultValue: 0, onOnChange: D[60] || (D[60] = V => pt("offsetX", V)), append: et.$t("attributes.offset_x") }, null, 8, ["modelValue", "append"])]), _: 1 }), I(jt, { flex: "1" }, { default: G(() => [I(j(Ce), { modelValue: j(g).shadow.offsetY, "onUpdate:modelValue": D[61] || (D[61] = V => j(g).shadow.offsetY = V), defaultValue: 0, onOnChange: D[62] || (D[62] = V => pt("offsetY", V)), append: et.$t("attributes.offset_y") }, null, 8, ["modelValue", "append"])]), _: 1 })]), _: 1 })])) : At("", !0)])])) : At("", !0) } } }), NC = Yt(VC, [["__scopeId", "data-v-53cda12e"]]), hi = { reloadImportTmpl: dt(0), reloadUserUpoload: dt(0), ReloadTemplate(e) { e === "userTemp" && this.reloadImportTmpl.value++, e === "userUploads" && this.reloadUserUpoload.value++ } }; var Zr = { exports: {} }, sn = typeof Reflect == "object" ? Reflect : null, xo = sn && typeof sn.apply == "function" ? sn.apply : function (t, a, p) { return Function.prototype.apply.call(t, a, p) }, ni; sn && typeof sn.ownKeys == "function" ? ni = sn.ownKeys : Object.getOwnPropertySymbols ? ni = function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : ni = function (t) { return Object.getOwnPropertyNames(t) }; function WC(e) { console && console.warn && console.warn(e) } var wl = Number.isNaN || function (t) { return t !== t }; function Bt() { Bt.init.call(this) } Zr.exports = Bt; Zr.exports.once = KC; Bt.EventEmitter = Bt; Bt.prototype._events = void 0; Bt.prototype._eventsCount = 0; Bt.prototype._maxListeners = void 0; var To = 10; function ki(e) { if (typeof e != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e) } Object.defineProperty(Bt, "defaultMaxListeners", { enumerable: !0, get: function () { return To }, set: function (e) { if (typeof e != "number" || e < 0 || wl(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + "."); To = e } }); Bt.init = function () { (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }; Bt.prototype.setMaxListeners = function (t) { if (typeof t != "number" || t < 0 || wl(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }; function Cl(e) { return e._maxListeners === void 0 ? Bt.defaultMaxListeners : e._maxListeners } Bt.prototype.getMaxListeners = function () { return Cl(this) }; Bt.prototype.emit = function (t) { for (var a = [], p = 1; p < arguments.length; p++)a.push(arguments[p]); var v = t === "error", _ = this._events; if (_ !== void 0) v = v && _.error === void 0; else if (!v) return !1; if (v) { var b; if (a.length > 0 && (b = a[0]), b instanceof Error) throw b; var f = new Error("Unhandled error." + (b ? " (" + b.message + ")" : "")); throw f.context = b, f } var r = _[t]; if (r === void 0) return !1; if (typeof r == "function") xo(r, this, a); else for (var c = r.length, h = kl(r, c), p = 0; p < c; ++p)xo(h[p], this, a); return !0 }; function Sl(e, t, a, p) { var v, _, b; if (ki(a), _ = e._events, _ === void 0 ? (_ = e._events = Object.create(null), e._eventsCount = 0) : (_.newListener !== void 0 && (e.emit("newListener", t, a.listener ? a.listener : a), _ = e._events), b = _[t]), b === void 0) b = _[t] = a, ++e._eventsCount; else if (typeof b == "function" ? b = _[t] = p ? [a, b] : [b, a] : p ? b.unshift(a) : b.push(a), v = Cl(e), v > 0 && b.length > v && !b.warned) { b.warned = !0; var f = new Error("Possible EventEmitter memory leak detected. " + b.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit"); f.name = "MaxListenersExceededWarning", f.emitter = e, f.type = t, f.count = b.length, WC(f) } return e } Bt.prototype.addListener = function (t, a) { return Sl(this, t, a, !1) }; Bt.prototype.on = Bt.prototype.addListener; Bt.prototype.prependListener = function (t, a) { return Sl(this, t, a, !0) }; function YC() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function xl(e, t, a) { var p = { fired: !1, wrapFn: void 0, target: e, type: t, listener: a }, v = YC.bind(p); return v.listener = a, p.wrapFn = v, v } Bt.prototype.once = function (t, a) { return ki(a), this.on(t, xl(this, t, a)), this }; Bt.prototype.prependOnceListener = function (t, a) { return ki(a), this.prependListener(t, xl(this, t, a)), this }; Bt.prototype.removeListener = function (t, a) { var p, v, _, b, f; if (ki(a), v = this._events, v === void 0) return this; if (p = v[t], p === void 0) return this; if (p === a || p.listener === a) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete v[t], v.removeListener && this.emit("removeListener", t, p.listener || a)); else if (typeof p != "function") { for (_ = -1, b = p.length - 1; b >= 0; b--)if (p[b] === a || p[b].listener === a) { f = p[b].listener, _ = b; break } if (_ < 0) return this; _ === 0 ? p.shift() : GC(p, _), p.length === 1 && (v[t] = p[0]), v.removeListener !== void 0 && this.emit("removeListener", t, f || a) } return this }; Bt.prototype.off = Bt.prototype.removeListener; Bt.prototype.removeAllListeners = function (t) { var a, p, v; if (p = this._events, p === void 0) return this; if (p.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : p[t] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete p[t]), this; if (arguments.length === 0) { var _ = Object.keys(p), b; for (v = 0; v < _.length; ++v)b = _[v], b !== "removeListener" && this.removeAllListeners(b); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if (a = p[t], typeof a == "function") this.removeListener(t, a); else if (a !== void 0) for (v = a.length - 1; v >= 0; v--)this.removeListener(t, a[v]); return this }; function Tl(e, t, a) { var p = e._events; if (p === void 0) return []; var v = p[t]; return v === void 0 ? [] : typeof v == "function" ? a ? [v.listener || v] : [v] : a ? XC(v) : kl(v, v.length) } Bt.prototype.listeners = function (t) { return Tl(this, t, !0) }; Bt.prototype.rawListeners = function (t) { return Tl(this, t, !1) }; Bt.listenerCount = function (e, t) { return typeof e.listenerCount == "function" ? e.listenerCount(t) : Ol.call(e, t) }; Bt.prototype.listenerCount = Ol; function Ol(e) { var t = this._events; if (t !== void 0) { var a = t[e]; if (typeof a == "function") return 1; if (a !== void 0) return a.length } return 0 } Bt.prototype.eventNames = function () { return this._eventsCount > 0 ? ni(this._events) : [] }; function kl(e, t) { for (var a = new Array(t), p = 0; p < t; ++p)a[p] = e[p]; return a } function GC(e, t) { for (; t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop() } function XC(e) { for (var t = new Array(e.length), a = 0; a < t.length; ++a)t[a] = e[a].listener || e[a]; return t } function KC(e, t) { return new Promise(function (a, p) { function v(b) { e.removeListener(t, _), p(b) } function _() { typeof e.removeListener == "function" && e.removeListener("error", v), a([].slice.call(arguments)) } Al(e, t, _, { once: !0 }), t !== "error" && qC(e, v, { once: !0 }) }) } function qC(e, t, a) { typeof e.on == "function" && Al(e, "error", t, a) } function Al(e, t, a, p) { if (typeof e.on == "function") p.once ? e.once(t, a) : e.on(t, a); else if (typeof e.addEventListener == "function") e.addEventListener(t, function v(_) { p.once && e.removeEventListener(t, v), a(_) }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e) } var JC = Zr.exports; const El = Vo(JC); class Pl extends El { constructor() { super(...arguments); Z(this, "handler"); Z(this, "mSelectMode", "") } init(a) { this.handler = a, this.handler && (this.handler.on("selection:created", () => this.selected()), this.handler.on("selection:updated", () => this.selected()), this.handler.on("selection:cleared", () => this.selected())) } selected() { if (!this.handler) throw TypeError("Canvas handler not initialized"); const a = this.handler.getActiveObjects().filter(p => !(p instanceof Q.fabric.GuideLine)); a && a.length === 1 ? this.emit(fe.ONE, a) : a && a.length > 1 ? (this.mSelectMode = "multiple", this.emit(fe.MULTI, a)) : this.emit(fe.CANCEL) } } const Hi = new Pl; var Vi = typeof navigator != "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1; function Ni(e, t, a, p) { e.addEventListener ? e.addEventListener(t, a, p) : e.attachEvent && e.attachEvent("on".concat(t), function () { a(window.event) }) } function Ml(e, t) { for (var a = t.slice(0, t.length - 1), p = 0; p < a.length; p++)a[p] = e[a[p].toLowerCase()]; return a } function jl(e) { typeof e != "string" && (e = ""), e = e.replace(/\s/g, ""); for (var t = e.split(","), a = t.lastIndexOf(""); a >= 0;)t[a - 1] += ",", t.splice(a, 1), a = t.lastIndexOf(""); return t } function ZC(e, t) { for (var a = e.length >= t.length ? e : t, p = e.length >= t.length ? t : e, v = !0, _ = 0; _ < a.length; _++)p.indexOf(a[_]) === -1 && (v = !1); return v } var Ln = { backspace: 8, "⌫": 8, tab: 9, clear: 12, enter: 13, "↩": 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, "⇪": 20, ",": 188, ".": 190, "/": 191, "`": 192, "-": Vi ? 173 : 189, "=": Vi ? 61 : 187, ";": Vi ? 59 : 186, "'": 222, "[": 219, "]": 221, "\\": 220 }, ke = { "⇧": 16, shift: 16, "⌥": 18, alt: 18, option: 18, "⌃": 17, ctrl: 17, control: 17, "⌘": 91, cmd: 91, command: 91 }, dr = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, oe = { 16: !1, 18: !1, 17: !1, 91: !1 }, Zt = {}; for (var Kn = 1; Kn < 20; Kn++)Ln["f".concat(Kn)] = 111 + Kn; var Nt = [], Oo = !1, Dl = "all", Ll = [], Un = function (t) { return Ln[t.toLowerCase()] || ke[t.toLowerCase()] || t.toUpperCase().charCodeAt(0) }, QC = function (t) { return Object.keys(Ln).find(function (a) { return Ln[a] === t }) }, t6 = function (t) { return Object.keys(ke).find(function (a) { return ke[a] === t }) }; function Fl(e) { Dl = e || "all" } function Fn() { return Dl || "all" } function e6() { return Nt.slice(0) } function n6() { return Nt.map(function (e) { return QC(e) || t6(e) || String.fromCharCode(e) }) } function i6() { var e = []; return Object.keys(Zt).forEach(function (t) { Zt[t].forEach(function (a) { var p = a.key, v = a.scope, _ = a.mods, b = a.shortcut; e.push({ scope: v, shortcut: b, mods: _, keys: p.split("+").map(function (f) { return Un(f) }) }) }) }), e } function r6(e) { var t = e.target || e.srcElement, a = t.tagName, p = !0; return (t.isContentEditable || (a === "INPUT" || a === "TEXTAREA" || a === "SELECT") && !t.readOnly) && (p = !1), p } function s6(e) { return typeof e == "string" && (e = Un(e)), Nt.indexOf(e) !== -1 } function o6(e, t) { var a, p; e || (e = Fn()); for (var v in Zt) if (Object.prototype.hasOwnProperty.call(Zt, v)) for (a = Zt[v], p = 0; p < a.length;)a[p].scope === e ? a.splice(p, 1) : p++; Fn() === e && Fl(t || "all") } function a6(e) { var t = e.keyCode || e.which || e.charCode, a = Nt.indexOf(t); if (a >= 0 && Nt.splice(a, 1), e.key && e.key.toLowerCase() === "meta" && Nt.splice(0, Nt.length), (t === 93 || t === 224) && (t = 91), t in oe) { oe[t] = !1; for (var p in ke) ke[p] === t && (Me[p] = !1) } } function l6(e) { if (typeof e == "undefined") Object.keys(Zt).forEach(function (b) { return delete Zt[b] }); else if (Array.isArray(e)) e.forEach(function (b) { b.key && Wi(b) }); else if (typeof e == "object") e.key && Wi(e); else if (typeof e == "string") { for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), p = 1; p < t; p++)a[p - 1] = arguments[p]; var v = a[0], _ = a[1]; typeof v == "function" && (_ = v, v = ""), Wi({ key: e, scope: v, method: _, splitKey: "+" }) } } var Wi = function (t) { var a = t.key, p = t.scope, v = t.method, _ = t.splitKey, b = _ === void 0 ? "+" : _, f = jl(a); f.forEach(function (r) { var c = r.split(b), h = c.length, n = c[h - 1], o = n === "*" ? "*" : Un(n); if (Zt[o]) { p || (p = Fn()); var i = h > 1 ? Ml(ke, c) : []; Zt[o] = Zt[o].filter(function (s) { var u = v ? s.method === v : !0; return !(u && s.scope === p && ZC(s.mods, i)) }) } }) }; function ko(e, t, a, p) { if (t.element === p) { var v; if (t.scope === a || t.scope === "all") { v = t.mods.length > 0; for (var _ in oe) Object.prototype.hasOwnProperty.call(oe, _) && (!oe[_] && t.mods.indexOf(+_) > -1 || oe[_] && t.mods.indexOf(+_) === -1) && (v = !1); (t.mods.length === 0 && !oe[16] && !oe[18] && !oe[17] && !oe[91] || v || t.shortcut === "*") && (t.keys = [], t.keys = t.keys.concat(Nt), t.method(e, t) === !1 && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0))) } } } function Ao(e, t) { var a = Zt["*"], p = e.keyCode || e.which || e.charCode; if (Me.filter.call(this, e)) { if ((p === 93 || p === 224) && (p = 91), Nt.indexOf(p) === -1 && p !== 229 && Nt.push(p), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function (s) { var u = dr[s]; e[s] && Nt.indexOf(u) === -1 ? Nt.push(u) : !e[s] && Nt.indexOf(u) > -1 ? Nt.splice(Nt.indexOf(u), 1) : s === "metaKey" && e[s] && Nt.length === 3 && (e.ctrlKey || e.shiftKey || e.altKey || (Nt = Nt.slice(Nt.indexOf(u)))) }), p in oe) { oe[p] = !0; for (var v in ke) ke[v] === p && (Me[v] = !0); if (!a) return } for (var _ in oe) Object.prototype.hasOwnProperty.call(oe, _) && (oe[_] = e[dr[_]]); e.getModifierState && !(e.altKey && !e.ctrlKey) && e.getModifierState("AltGraph") && (Nt.indexOf(17) === -1 && Nt.push(17), Nt.indexOf(18) === -1 && Nt.push(18), oe[17] = !0, oe[18] = !0); var b = Fn(); if (a) for (var f = 0; f < a.length; f++)a[f].scope === b && (e.type === "keydown" && a[f].keydown || e.type === "keyup" && a[f].keyup) && ko(e, a[f], b, t); if (p in Zt) { for (var r = 0; r < Zt[p].length; r++)if ((e.type === "keydown" && Zt[p][r].keydown || e.type === "keyup" && Zt[p][r].keyup) && Zt[p][r].key) { for (var c = Zt[p][r], h = c.splitKey, n = c.key.split(h), o = [], i = 0; i < n.length; i++)o.push(Un(n[i])); o.sort().join("") === Nt.sort().join("") && ko(e, c, b, t) } } } } function c6(e) { return Ll.indexOf(e) > -1 } function Me(e, t, a) { Nt = []; var p = jl(e), v = [], _ = "all", b = document, f = 0, r = !1, c = !0, h = "+", n = !1; for (a === void 0 && typeof t == "function" && (a = t), Object.prototype.toString.call(t) === "[object Object]" && (t.scope && (_ = t.scope), t.element && (b = t.element), t.keyup && (r = t.keyup), t.keydown !== void 0 && (c = t.keydown), t.capture !== void 0 && (n = t.capture), typeof t.splitKey == "string" && (h = t.splitKey)), typeof t == "string" && (_ = t); f < p.length; f++)e = p[f].split(h), v = [], e.length > 1 && (v = Ml(ke, e)), e = e[e.length - 1], e = e === "*" ? "*" : Un(e), e in Zt || (Zt[e] = []), Zt[e].push({ keyup: r, keydown: c, scope: _, mods: v, shortcut: p[f], method: a, key: p[f], splitKey: h, element: b }); typeof b != "undefined" && !c6(b) && window && (Ll.push(b), Ni(b, "keydown", function (o) { Ao(o, b) }, n), Oo || (Oo = !0, Ni(window, "focus", function () { Nt = [] }, n)), Ni(b, "keyup", function (o) { Ao(o, b), a6(o) }, n)) } function u6(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all"; Object.keys(Zt).forEach(function (a) { var p = Zt[a].filter(function (v) { return v.scope === t && v.shortcut === e }); p.forEach(function (v) { v && v.method && v.method() }) }) } var Yi = { getPressedKeyString: n6, setScope: Fl, getScope: Fn, deleteScope: o6, getPressedKeyCodes: e6, getAllKeyCodes: i6, isPressed: s6, filter: r6, trigger: u6, unbind: l6, keyMap: Ln, modifier: ke, modifierMap: dr }; for (var Gi in Yi) Object.prototype.hasOwnProperty.call(Yi, Gi) && (Me[Gi] = Yi[Gi]); if (typeof window != "undefined") { var h6 = window.hotkeys; Me.noConflict = function (e) { return e && window.hotkeys === Me && (window.hotkeys = h6), Me }, window.hotkeys = Me } class fi { constructor(t, a) { this.container = t, this.dom = null, this.shown = !1, this.root = !0, this.parent = null, this.submenus = [], this.items = a, this._onclick = p => { this.dom && p.target != this.dom && p.target.parentElement != this.dom && !p.target.classList.contains("item") && !p.target.parentElement.classList.contains("item") && this.hideAll() }, this._oncontextmenu = p => { p.preventDefault(), p.target != this.dom && p.target.parentElement != this.dom && !p.target.classList.contains("item") && !p.target.parentElement.classList.contains("item") && (this.hideAll(), this.show(p.clientX, p.clientY)) }, this._oncontextmenu_keydown = p => { p.keyCode == 93 && (p.preventDefault(), this.hideAll(), this.show(p.clientX, p.clientY)) }, this._onblur = () => { this.hideAll() } } getMenuDom() { const t = document.createElement("div"); t.classList.add("context"); for (const a of this.items) t.appendChild(this.itemToDomEl(a)); return t } itemToDomEl(t) { const a = document.createElement("div"); if (t === null) return a.classList = "separator", a; t.hasOwnProperty("color") && /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t.color.toString()) && (a.style.cssText = `color: ${t.color}`), a.classList.add("item"); const p = document.createElement("span"); p.classList = "label", p.innerText = t.hasOwnProperty("text") ? t.text.toString() : "", a.appendChild(p), t.hasOwnProperty("disabled") && t.disabled ? a.classList.add("disabled") : a.classList.add("enabled"); const v = document.createElement("span"); if (v.classList = "hotkey", v.innerText = t.hasOwnProperty("hotkey") ? t.hotkey.toString() : "", a.appendChild(v), t.hasOwnProperty("subitems") && Array.isArray(t.subitems) && t.subitems.length > 0) { const _ = new fi(this.container, t.subitems); _.root = !1, _.parent = this; const b = () => { if (t.hasOwnProperty("disabled") && t.disabled == !0) return; this.hideSubMenus(); const f = this.dom.offsetLeft + this.dom.clientWidth + a.offsetLeft, r = this.dom.offsetTop + a.offsetTop; _.shown ? _.hide() : _.show(f, r) }; this.submenus.push(_), a.classList.add("has-subitems"), a.addEventListener("click", b), a.addEventListener("mousemove", b) } else if (t.hasOwnProperty("submenu") && t.submenu instanceof fi) { const _ = t.submenu; _.root = !1, _.parent = this; const b = () => { if (t.hasOwnProperty("disabled") && t.disabled == !0) return; this.hideSubMenus(); const f = this.dom.offsetLeft + this.dom.clientWidth + a.offsetLeft, r = this.dom.offsetTop + a.offsetTop; _.shown ? _.hide() : _.show(f, r) }; this.submenus.push(_), a.classList.add("has-subitems"), a.addEventListener("click", b), a.addEventListener("mousemove", b) } else a.addEventListener("click", () => { if (this.hideSubMenus(), !a.classList.contains("disabled")) if (t.hasOwnProperty("onclick") && typeof t.onclick == "function") { const _ = { handled: !1, item: a, label: p, hotkey: v, items: this.items, data: t }; t.onclick(_), _.handled || this.hide() } else this.hide() }), a.addEventListener("mousemove", () => { this.hideSubMenus() }); return a } hideAll() { if (this.root && !this.parent) { this.shown && (this.hideSubMenus(), this.shown = !1, this.container.removeChild(this.dom), this.parent && this.parent.shown && this.parent.hide()); return } this.parent.hide() } hide() { this.dom && this.shown && (this.shown = !1, this.hideSubMenus(), this.container.removeChild(this.dom), this.parent && this.parent.shown && this.parent.hide()) } hideSubMenus() { for (const t of this.submenus) t.shown && (t.shown = !1, t.container.removeChild(t.dom)), t.hideSubMenus() } show(t, a) { this.dom = this.getMenuDom(), this.dom.style.left = `${t}px`, this.dom.style.top = `${a}px`, this.shown = !0, this.container.appendChild(this.dom) } install() { this.container.addEventListener("contextmenu", this._oncontextmenu), this.container.addEventListener("keydown", this._oncontextmenu_keydown), this.container.addEventListener("click", this._onclick), window.addEventListener("blur", this._onblur) } setData(t) { this.items = t } uninstall() { this.dom = null, this.container.removeEventListener("keydown", this._oncontextmenu_keydown), this.container.removeEventListener("click", this._onclick), window.removeEventListener("blur", this._onblur) } } function Xi(e, t) { const a = document.createElement("a"); a.href = e, a.download = `${Jt()}.${t}`, document.body.appendChild(a), a.click(), a.remove() } function $l(e) { e && e.forEach(t => { t.objects ? $l(t.objects) : t.type === "text" && (t.type = "textbox") }) } class pr { constructor(t, a, p) { Z(this, "canvas"); Z(this, "editor"); Z(this, "frontTempJson"); Z(this, "backTempJson"); Z(this, "frontSaveOptions", ""); Z(this, "backSaveOptions", ""); Z(this, "backTemplateExsist", !1); Z(this, "currentTemp", "front"); Z(this, "sharedState"); Z(this, "hiddenButtonRef", dt(null)); this.canvas = t, this.editor = a, this.initHiddenButtonRef(), this.sharedState = p, this.currentTemp = "front", this.waitForSharedState() } waitForSharedState() { const t = setInterval(() => { Ot.front !== "" && Ot.back !== "" && (this.frontTempJson = Ot.front, this.backTempJson = Ot.back, this.currentTemp = Ot.position, this.backTemplateExsist = Ot.backTemplateExsist, clearInterval(t)) }, 500) } initHiddenButtonRef() { this.hiddenButtonRef = dt(document.querySelector("#hiddenButton")) } insert() { kn({ accept: ".json" }).then(t => { const [a] = t, p = new FileReader; p.readAsText(a, "UTF-8"), p.onload = () => { this.insertSvgFile(p.result) } }) } insertSvgFile(t) { console.log("insert svg file", t), this.editor.hooksEntity.hookImportBefore.callAsync(t, () => { this.canvas.loadFromJSON(t, () => { this.canvas.renderAll(), this.editor.hooksEntity.hookImportAfter.callAsync(t, () => { this.canvas.renderAll() }) }) }) } insertSvgString(t) { Q.fabric.loadSVGFromString(t, (a, p) => { const v = Q.fabric.util.groupSVGElements(a, Ut(Et({}, p), { name: "SVG  ", id: Jt() })); this.canvas.add(v), this.canvas.renderAll() }) } saveSvg() { this.editor.hooksEntity.hookSaveBefore.callAsync("", () => { const t = this._getSaveSvgOption(), a = this.canvas.toSVG(t), p = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(a)}`; this.editor.hooksEntity.hookSaveAfter.callAsync(p, () => { Xi(p, "svg") }) }) } getJson() { return this.canvas.toJSON(["id", "gradientAngle", "selectable", "hasControls"]) } dragAddItem(t, a) { const { left: p, top: v } = this.canvas.getSelectionElement().getBoundingClientRect(); if (t.x < p || t.y < v || a.width === void 0) return; const _ = { x: t.x - p, y: t.y - v }, b = this.canvas.restorePointerVpt(_); a.left = b.x - a.width / 2, a.top = b.y, this.canvas.add(a), this.canvas.requestRenderAll() } clipboard() { const t = this.getJson(); qc(JSON.stringify(t, null, "	")) } saveJson() { return ie(this, null, function* () { const t = this.getJson(); yield $l(t.objects); const a = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(t, null, "	"))}`; Xi(a, "json") }) } toggleTemplate(t) { t !== this.currentTemp && (t === "front" && (this.editor.hooksEntity.hookSaveBefore.callAsync("", () => { const a = this._getSaveSvgOption(); this.backSaveOptions = this.canvas.toSVG(a) }), this.insertSvgString(this.frontSaveOptions), this.currentTemp = "front"), t === "back" && (this.editor.hooksEntity.hookSaveBefore.callAsync("", () => { const a = this._getSaveSvgOption(); this.frontSaveOptions = this.canvas.toSVG(a) }), this.insertSvgString(this.backSaveOptions), this.currentTemp = "back")) } saveTemplate() { return ie(this, null, function* () { const t = new FormData, a = this._getSaveSvgOption(), p = this.canvas.toSVG(a); t.append("frontImage", p), t.append("userId", Ot.userId), t.append("templateWidth", Ot.templateWidth), t.append("templateHeight", Ot.templateHeight), t.append("productId", Ot.productId), t.append("role", Ot.role), Ot.back && t.append("backImage", this.backSaveOptions), this.hiddenButtonRef.value && this.hiddenButtonRef.value.click(); try { (yield Te.post("https://vista.simboz.website/api/template/storeTemp", t, { headers: { "Content-Type": "application/json" } })).status === 200 && (Ot.role || (window.location.href = "/cart")), hi.ReloadTemplate("userTemp") } catch (v) { } }) } saveImg() { this.editor.hooksEntity.hookSaveBefore.callAsync("", () => { const t = this._getSaveOption(); this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); const a = this.canvas.toDataURL(t); this.editor.hooksEntity.hookSaveAfter.callAsync(a, () => { Xi(a, "jpg") }) }) } preview() { return new Promise((t, a) => { this.editor.hooksEntity.hookSaveBefore.callAsync("", () => { const p = this._getSaveOption(); this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]), this.canvas.renderAll(); const v = this.canvas.toDataURL(p); this.editor.hooksEntity.hookSaveAfter.callAsync(v, () => { t(v) }) }) }) } getUserUploads(t) { return ie(this, null, function* () { try { const a = yield Te.get(` https://vista.simboz.website/api/template/loadUserImages/${t}`); if (a.status === 200) { const p = a.data.data; return qt.Spin.hide(), p } else return [] } catch (a) { return [] } }) } uploadImage(t, a) { return ie(this, null, function* () { const p = new FormData; p.append("image", t), p.append("user_id", "12"); try { const v = yield Te.post("https://vista.simboz.website/api/template/uploadImage", p, { headers: { "Content-Type": "multipart/form-data", Authorization: `Bearer ${this.apiToken.value}` } }); hi.ReloadTemplate("userUploads") } catch (v) { } }) } _getSaveSvgOption() { const t = this.canvas.getObjects().find(b => b.id === "workspace"), { left: a, top: p, width: v, height: _ } = t; return { width: v, height: _, viewBox: { x: a, y: p, width: v, height: _ } } } _getSaveOption() { const t = this.canvas.getObjects().find(f => f.id === "workspace"), { left: a, top: p, width: v, height: _ } = t; return { name: "New Image", format: "svg", quality: 1, left: a, top: p } } clear() { this.canvas.getObjects().forEach(t => { t.id !== "workspace" && this.canvas.remove(t) }), this.canvas.discardActiveObject(), this.canvas.renderAll() } destroy() { } } Z(pr, "pluginName", "ServersPlugin"), Z(pr, "apis", ["insert", "insertSvgFile", "getJson", "dragAddItem", "clipboard", "saveJson", "saveTemplate", "saveSvg", "saveImg", "clear", "preview", "toggleTemplate", "waitForSharedState", "getUserUploads", "uploadImage", "insertSvgString"]); var Qr = {}; Qr.deprecate = (e, t) => { let a = !0; return function () { return a && (console.warn("DeprecationWarning: " + t), a = !1), e.apply(this, arguments) } }; const f6 = Qr, d6 = f6.deprecate(() => { }, "Hook.context is deprecated and will be removed"), Eo = function (...e) { return this.call = this._createCall("sync"), this.call(...e) }, Po = function (...e) { return this.callAsync = this._createCall("async"), this.callAsync(...e) }, Mo = function (...e) { return this.promise = this._createCall("promise"), this.promise(...e) }; let Il = class { constructor(t = [], a = void 0) { this._args = t, this.name = a, this.taps = [], this.interceptors = [], this._call = Eo, this.call = Eo, this._callAsync = Po, this.callAsync = Po, this._promise = Mo, this.promise = Mo, this._x = void 0, this.compile = this.compile, this.tap = this.tap, this.tapAsync = this.tapAsync, this.tapPromise = this.tapPromise } compile(t) { throw new Error("Abstract: should be overridden") } _createCall(t) { return this.compile({ taps: this.taps, interceptors: this.interceptors, args: this._args, type: t }) } _tap(t, a, p) { if (typeof a == "string") a = { name: a.trim() }; else if (typeof a != "object" || a === null) throw new Error("Invalid tap options"); if (typeof a.name != "string" || a.name === "") throw new Error("Missing name for tap"); typeof a.context != "undefined" && d6(), a = Object.assign({ type: t, fn: p }, a), a = this._runRegisterInterceptors(a), this._insert(a) } tap(t, a) { this._tap("sync", t, a) } tapAsync(t, a) { this._tap("async", t, a) } tapPromise(t, a) { this._tap("promise", t, a) } _runRegisterInterceptors(t) { for (const a of this.interceptors) if (a.register) { const p = a.register(t); p !== void 0 && (t = p) } return t } withOptions(t) { const a = p => Object.assign({}, t, typeof p == "string" ? { name: p } : p); return { name: this.name, tap: (p, v) => this.tap(a(p), v), tapAsync: (p, v) => this.tapAsync(a(p), v), tapPromise: (p, v) => this.tapPromise(a(p), v), intercept: p => this.intercept(p), isUsed: () => this.isUsed(), withOptions: p => this.withOptions(a(p)) } } isUsed() { return this.taps.length > 0 || this.interceptors.length > 0 } intercept(t) { if (this._resetCompilation(), this.interceptors.push(Object.assign({}, t)), t.register) for (let a = 0; a < this.taps.length; a++)this.taps[a] = t.register(this.taps[a]) } _resetCompilation() { this.call = this._call, this.callAsync = this._callAsync, this.promise = this._promise } _insert(t) { this._resetCompilation(); let a; typeof t.before == "string" ? a = new Set([t.before]) : Array.isArray(t.before) && (a = new Set(t.before)); let p = 0; typeof t.stage == "number" && (p = t.stage); let v = this.taps.length; for (; v > 0;) { v--; const _ = this.taps[v]; this.taps[v + 1] = _; const b = _.stage || 0; if (a) { if (a.has(_.name)) { a.delete(_.name); continue } if (a.size > 0) continue } if (!(b > p)) { v++; break } } this.taps[v] = t } }; Object.setPrototypeOf(Il.prototype, null); var Ee = Il; let p6 = class {
	constructor(t) { this.config = t, this.options = void 0, this._args = void 0 } create(t) {
		this.init(t); let a; switch (this.options.type) {
			case "sync": a = new Function(this.args(), `"use strict";
`+ this.header() + this.contentWithInterceptors({
				onError: b => `throw ${b};
`, onResult: b => `return ${b};
`, resultReturns: !0, onDone: () => "", rethrowIfPossible: !0
			})); break; case "async": a = new Function(this.args({ after: "_callback" }), `"use strict";
`+ this.header() + this.contentWithInterceptors({
				onError: b => `_callback(${b});
`, onResult: b => `_callback(null, ${b});
`, onDone: () => `_callback();
`})); break; case "promise": let p = !1; const v = this.contentWithInterceptors({
					onError: b => (p = !0, `_error(${b});
`), onResult: b => `_resolve(${b});
`, onDone: () => `_resolve();
`}); let _ = ""; _ += `"use strict";
`, _ += this.header(), _ += `return new Promise((function(_resolve, _reject) {
`, p && (_ += `var _sync = true;
`, _ += `function _error(_err) {
`, _ += `if(_sync)
`, _ += `_resolve(Promise.resolve().then((function() { throw _err; })));
`, _ += `else
`, _ += `_reject(_err);
`, _ += `};
`), _ += v, p && (_ += `_sync = false;
`), _ += `}));
`, a = new Function(this.args(), _); break
		}return this.deinit(), a
	} setup(t, a) { t._x = a.taps.map(p => p.fn) } init(t) { this.options = t, this._args = t.args.slice() } deinit() { this.options = void 0, this._args = void 0 } contentWithInterceptors(t) {
		if (this.options.interceptors.length > 0) {
			const a = t.onError, p = t.onResult, v = t.onDone; let _ = ""; for (let b = 0; b < this.options.interceptors.length; b++) {
				const f = this.options.interceptors[b]; f.call && (_ += `${this.getInterceptor(b)}.call(${this.args({ before: f.context ? "_context" : void 0 })});
`)
			} return _ += this.content(Object.assign(t, {
				onError: a && (b => {
					let f = ""; for (let r = 0; r < this.options.interceptors.length; r++)this.options.interceptors[r].error && (f += `${this.getInterceptor(r)}.error(${b});
`); return f += a(b), f
				}), onResult: p && (b => {
					let f = ""; for (let r = 0; r < this.options.interceptors.length; r++)this.options.interceptors[r].result && (f += `${this.getInterceptor(r)}.result(${b});
`); return f += p(b), f
				}), onDone: v && (() => {
					let b = ""; for (let f = 0; f < this.options.interceptors.length; f++)this.options.interceptors[f].done && (b += `${this.getInterceptor(f)}.done();
`); return b += v(), b
				})
			})), _
		} else return this.content(t)
	} header() {
		let t = ""; return this.needContext() ? t += `var _context = {};
`: t += `var _context;
`, t += `var _x = this._x;
`, this.options.interceptors.length > 0 && (t += `var _taps = this.taps;
`, t += `var _interceptors = this.interceptors;
`), t
	} needContext() { for (const t of this.options.taps) if (t.context) return !0; return !1 } callTap(t, { onError: a, onResult: p, onDone: v, rethrowIfPossible: _ }) {
		let b = "", f = !1; for (let c = 0; c < this.options.interceptors.length; c++) {
			const h = this.options.interceptors[c]; h.tap && (f || (b += `var _tap${t} = ${this.getTap(t)};
`, f = !0), b += `${this.getInterceptor(c)}.tap(${h.context ? "_context, " : ""}_tap${t});
`)
		} b += `var _fn${t} = ${this.getTapFn(t)};
`; const r = this.options.taps[t]; switch (r.type) {
			case "sync": _ || (b += `var _hasError${t} = false;
`, b += `try {
`), p ? b += `var _result${t} = _fn${t}(${this.args({ before: r.context ? "_context" : void 0 })});
`: b += `_fn${t}(${this.args({ before: r.context ? "_context" : void 0 })});
`, _ || (b += `} catch(_err) {
`, b += `_hasError${t} = true;
`, b += a("_err"), b += `}
`, b += `if(!_hasError${t}) {
`), p && (b += p(`_result${t}`)), v && (b += v()), _ || (b += `}
`); break; case "async": let c = ""; p ? c += `(function(_err${t}, _result${t}) {
`: c += `(function(_err${t}) {
`, c += `if(_err${t}) {
`, c += a(`_err${t}`), c += `} else {
`, p && (c += p(`_result${t}`)), v && (c += v()), c += `}
`, c += "})", b += `_fn${t}(${this.args({ before: r.context ? "_context" : void 0, after: c })});
`; break; case "promise": b += `var _hasResult${t} = false;
`, b += `var _promise${t} = _fn${t}(${this.args({ before: r.context ? "_context" : void 0 })});
`, b += `if (!_promise${t} || !_promise${t}.then)
`, b += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${t} + ')');
`, b += `_promise${t}.then((function(_result${t}) {
`, b += `_hasResult${t} = true;
`, p && (b += p(`_result${t}`)), v && (b += v()), b += `}), function(_err${t}) {
`, b += `if(_hasResult${t}) throw _err${t};
`, b += a(`_err${t}`), b += `});
`; break
		}return b
	} callTapsSeries({ onError: t, onResult: a, resultReturns: p, onDone: v, doneReturns: _, rethrowIfPossible: b }) {
		if (this.options.taps.length === 0) return v(); const f = this.options.taps.findIndex(o => o.type !== "sync"), r = p || _; let c = "", h = v, n = 0; for (let o = this.options.taps.length - 1; o >= 0; o--) {
			const i = o; h !== v && (this.options.taps[i].type !== "sync" || n++ > 20) && (n = 0, c += `function _next${i}() {
`, c += h(), c += `}
`, h = () => `${r ? "return " : ""}_next${i}();
`); const u = h, l = g => g ? "" : v(), d = this.callTap(i, { onError: g => t(i, g, u, l), onResult: a && (g => a(i, g, u, l)), onDone: !a && u, rethrowIfPossible: b && (f < 0 || i < f) }); h = () => d
		} return c += h(), c
	} callTapsLooping({ onError: t, onDone: a, rethrowIfPossible: p }) {
		if (this.options.taps.length === 0) return a(); const v = this.options.taps.every(b => b.type === "sync"); let _ = ""; v || (_ += `var _looper = (function() {
`, _ += `var _loopAsync = false;
`), _ += `var _loop;
`, _ += `do {
`, _ += `_loop = false;
`; for (let b = 0; b < this.options.interceptors.length; b++) {
			const f = this.options.interceptors[b]; f.loop && (_ += `${this.getInterceptor(b)}.loop(${this.args({ before: f.context ? "_context" : void 0 })});
`)
		} return _ += this.callTapsSeries({
			onError: t, onResult: (b, f, r, c) => {
				let h = ""; return h += `if(${f} !== undefined) {
`, h += `_loop = true;
`, v || (h += `if(_loopAsync) _looper();
`), h += c(!0), h += `} else {
`, h += r(), h += `}
`, h
			}, onDone: a && (() => {
				let b = ""; return b += `if(!_loop) {
`, b += a(), b += `}
`, b
			}), rethrowIfPossible: p && v
		}), _ += `} while(_loop);
`, v || (_ += `_loopAsync = true;
`, _ += `});
`, _ += `_looper();
`), _
	} callTapsParallel({ onError: t, onResult: a, onDone: p, rethrowIfPossible: v, onTap: _ = (b, f) => f() }) {
		if (this.options.taps.length <= 1) return this.callTapsSeries({ onError: t, onResult: a, onDone: p, rethrowIfPossible: v }); let b = ""; b += `do {
`, b += `var _counter = ${this.options.taps.length};
`, p && (b += `var _done = (function() {
`, b += p(), b += `});
`); for (let f = 0; f < this.options.taps.length; f++) {
			const r = () => p ? `if(--_counter === 0) _done();
`: "--_counter;", c = h => h || !p ? `_counter = 0;
`: `_counter = 0;
_done();
`; b += `if(_counter <= 0) break;
`, b += _(f, () => this.callTap(f, {
				onError: h => {
					let n = ""; return n += `if(_counter > 0) {
`, n += t(f, h, r, c), n += `}
`, n
				}, onResult: a && (h => {
					let n = ""; return n += `if(_counter > 0) {
`, n += a(f, h, r, c), n += `}
`, n
				}), onDone: !a && (() => r()), rethrowIfPossible: v
			}), r, c)
		} return b += `} while(false);
`, b
	} args({ before: t, after: a } = {}) { let p = this._args; return t && (p = [t].concat(p)), a && (p = p.concat(a)), p.length === 0 ? "" : p.join(", ") } getTapFn(t) { return `_x[${t}]` } getTap(t) { return `_taps[${t}]` } getInterceptor(t) { return `_interceptors[${t}]` }
}; var Pe = p6; const g6 = Ee, m6 = Pe; class v6 extends m6 { content({ onError: t, onDone: a, rethrowIfPossible: p }) { return this.callTapsSeries({ onError: (v, _) => t(_), onDone: a, rethrowIfPossible: p }) } } const jo = new v6, _6 = () => { throw new Error("tapAsync is not supported on a SyncHook") }, y6 = () => { throw new Error("tapPromise is not supported on a SyncHook") }, b6 = function (e) { return jo.setup(this, e), jo.create(e) }; function Rl(e = [], t = void 0) { const a = new g6(e, t); return a.constructor = Rl, a.tapAsync = _6, a.tapPromise = y6, a.compile = b6, a } Rl.prototype = null; const w6 = Ee, C6 = Pe; class S6 extends C6 {
	content({ onError: t, onResult: a, resultReturns: p, onDone: v, rethrowIfPossible: _ }) {
		return this.callTapsSeries({
			onError: (b, f) => t(f), onResult: (b, f, r) => `if(${f} !== undefined) {
${a(f)};
} else {
${r()}}
`, resultReturns: p, onDone: v, rethrowIfPossible: _
		})
	}
} const Do = new S6, x6 = () => { throw new Error("tapAsync is not supported on a SyncBailHook") }, T6 = () => { throw new Error("tapPromise is not supported on a SyncBailHook") }, O6 = function (e) { return Do.setup(this, e), Do.create(e) }; function Bl(e = [], t = void 0) { const a = new w6(e, t); return a.constructor = Bl, a.tapAsync = x6, a.tapPromise = T6, a.compile = O6, a } Bl.prototype = null; const k6 = Ee, A6 = Pe; class E6 extends A6 {
	content({ onError: t, onResult: a, resultReturns: p, rethrowIfPossible: v }) {
		return this.callTapsSeries({
			onError: (_, b) => t(b), onResult: (_, b, f) => {
				let r = ""; return r += `if(${b} !== undefined) {
`, r += `${this._args[0]} = ${b};
`, r += `}
`, r += f(), r
			}, onDone: () => a(this._args[0]), doneReturns: p, rethrowIfPossible: v
		})
	}
} const Lo = new E6, P6 = () => { throw new Error("tapAsync is not supported on a SyncWaterfallHook") }, M6 = () => { throw new Error("tapPromise is not supported on a SyncWaterfallHook") }, j6 = function (e) { return Lo.setup(this, e), Lo.create(e) }; function zl(e = [], t = void 0) { if (e.length < 1) throw new Error("Waterfall hooks must have at least one argument"); const a = new k6(e, t); return a.constructor = zl, a.tapAsync = P6, a.tapPromise = M6, a.compile = j6, a } zl.prototype = null; const D6 = Ee, L6 = Pe; class F6 extends L6 { content({ onError: t, onDone: a, rethrowIfPossible: p }) { return this.callTapsLooping({ onError: (v, _) => t(_), onDone: a, rethrowIfPossible: p }) } } const Fo = new F6, $6 = () => { throw new Error("tapAsync is not supported on a SyncLoopHook") }, I6 = () => { throw new Error("tapPromise is not supported on a SyncLoopHook") }, R6 = function (e) { return Fo.setup(this, e), Fo.create(e) }; function Ul(e = [], t = void 0) { const a = new D6(e, t); return a.constructor = Ul, a.tapAsync = $6, a.tapPromise = I6, a.compile = R6, a } Ul.prototype = null; const B6 = Ee, z6 = Pe; class U6 extends z6 { content({ onError: t, onDone: a }) { return this.callTapsParallel({ onError: (p, v, _, b) => t(v) + b(!0), onDone: a }) } } const $o = new U6, H6 = function (e) { return $o.setup(this, e), $o.create(e) }; function Hl(e = [], t = void 0) { const a = new B6(e, t); return a.constructor = Hl, a.compile = H6, a._call = void 0, a.call = void 0, a } Hl.prototype = null; const V6 = Ee, N6 = Pe; class W6 extends N6 {
	content({ onError: t, onResult: a, onDone: p }) {
		let v = ""; return v += `var _results = new Array(${this.options.taps.length});
`, v += `var _checkDone = function() {
`, v += `for(var i = 0; i < _results.length; i++) {
`, v += `var item = _results[i];
`, v += `if(item === undefined) return false;
`, v += `if(item.result !== undefined) {
`, v += a("item.result"), v += `return true;
`, v += `}
`, v += `if(item.error) {
`, v += t("item.error"), v += `return true;
`, v += `}
`, v += `}
`, v += `return false;
`, v += `}
`, v += this.callTapsParallel({
			onError: (_, b, f, r) => {
				let c = ""; return c += `if(${_} < _results.length && ((_results.length = ${_ + 1}), (_results[${_}] = { error: ${b} }), _checkDone())) {
`, c += r(!0), c += `} else {
`, c += f(), c += `}
`, c
			}, onResult: (_, b, f, r) => {
				let c = ""; return c += `if(${_} < _results.length && (${b} !== undefined && (_results.length = ${_ + 1}), (_results[${_}] = { result: ${b} }), _checkDone())) {
`, c += r(!0), c += `} else {
`, c += f(), c += `}
`, c
			}, onTap: (_, b, f, r) => {
				let c = ""; return _ > 0 && (c += `if(${_} >= _results.length) {
`, c += f(), c += `} else {
`), c += b(), _ > 0 && (c += `}
`), c
			}, onDone: p
		}), v
	}
} const Io = new W6, Y6 = function (e) { return Io.setup(this, e), Io.create(e) }; function Vl(e = [], t = void 0) { const a = new V6(e, t); return a.constructor = Vl, a.compile = Y6, a._call = void 0, a.call = void 0, a } Vl.prototype = null; const G6 = Ee, X6 = Pe; class K6 extends X6 { content({ onError: t, onDone: a }) { return this.callTapsSeries({ onError: (p, v, _, b) => t(v) + b(!0), onDone: a }) } } const Ro = new K6, q6 = function (e) { return Ro.setup(this, e), Ro.create(e) }; function ts(e = [], t = void 0) { const a = new G6(e, t); return a.constructor = ts, a.compile = q6, a._call = void 0, a.call = void 0, a } ts.prototype = null; var J6 = ts; const Z6 = Ee, Q6 = Pe; class tS extends Q6 {
	content({ onError: t, onResult: a, resultReturns: p, onDone: v }) {
		return this.callTapsSeries({
			onError: (_, b, f, r) => t(b) + r(!0), onResult: (_, b, f) => `if(${b} !== undefined) {
${a(b)}
} else {
${f()}}
`, resultReturns: p, onDone: v
		})
	}
} const Bo = new tS, eS = function (e) { return Bo.setup(this, e), Bo.create(e) }; function Nl(e = [], t = void 0) { const a = new Z6(e, t); return a.constructor = Nl, a.compile = eS, a._call = void 0, a.call = void 0, a } Nl.prototype = null; const nS = Ee, iS = Pe; class rS extends iS { content({ onError: t, onDone: a }) { return this.callTapsLooping({ onError: (p, v, _, b) => t(v) + b(!0), onDone: a }) } } const zo = new rS, sS = function (e) { return zo.setup(this, e), zo.create(e) }; function Wl(e = [], t = void 0) { const a = new nS(e, t); return a.constructor = Wl, a.compile = sS, a._call = void 0, a.call = void 0, a } Wl.prototype = null; const oS = Ee, aS = Pe; class lS extends aS {
	content({ onError: t, onResult: a, onDone: p }) {
		return this.callTapsSeries({
			onError: (v, _, b, f) => t(_) + f(!0), onResult: (v, _, b) => {
				let f = ""; return f += `if(${_} !== undefined) {
`, f += `${this._args[0]} = ${_};
`, f += `}
`, f += b(), f
			}, onDone: () => a(this._args[0])
		})
	}
} const Uo = new lS, cS = function (e) { return Uo.setup(this, e), Uo.create(e) }; function Yl(e = [], t = void 0) { if (e.length < 1) throw new Error("Waterfall hooks must have at least one argument"); const a = new oS(e, t); return a.constructor = Yl, a.compile = cS, a._call = void 0, a.call = void 0, a } Yl.prototype = null; const es = Qr, uS = (e, t) => t; class ns { constructor(t, a = void 0) { this._map = new Map, this.name = a, this._factory = t, this._interceptors = [] } get(t) { return this._map.get(t) } for(t) { const a = this.get(t); if (a !== void 0) return a; let p = this._factory(t); const v = this._interceptors; for (let _ = 0; _ < v.length; _++)p = v[_].factory(t, p); return this._map.set(t, p), p } intercept(t) { this._interceptors.push(Object.assign({ factory: uS }, t)) } } ns.prototype.tap = es.deprecate(function (e, t, a) { return this.for(e).tap(t, a) }, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead."); ns.prototype.tapAsync = es.deprecate(function (e, t, a) { return this.for(e).tapAsync(t, a) }, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead."); ns.prototype.tapPromise = es.deprecate(function (e, t, a) { return this.for(e).tapPromise(t, a) }, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead."); var hS = J6; class fS extends El { constructor() { super(...arguments); Z(this, "canvas"); Z(this, "contextMenu"); Z(this, "pluginMap", {}); Z(this, "customEvents", []); Z(this, "customApis", []); Z(this, "hooks", ["hookImportBefore", "hookImportAfter", "hookSaveBefore", "hookSaveAfter"]); Z(this, "hooksEntity", {}) } init(a) { this.canvas = a, this._initContextMenu(), this._bindContextMenu(), this._initActionHooks(), this._initServersPlugin() } use(a, p) { if (this._checkPlugin(a)) { this._saveCustomAttr(a); const v = new a(this.canvas, this, p); this.pluginMap[a.pluginName] = v, this._bindingHooks(v), this._bindingHotkeys(v), this._bindingApis(v) } } getPlugin(a) { if (this.pluginMap[a]) return this.pluginMap[a] } _checkPlugin(a) { const { pluginName: p, events: v = [], apis: _ = [] } = a; if (this.pluginMap[p]) throw new Error(p + "Plug-in repeated initialization"); return v.forEach(b => { if (this.customEvents.find(f => f === b)) throw new Error(p + "in plug-in" + b + "重复") }), _.forEach(b => { if (this.customApis.find(f => f === b)) throw new Error(p + "in plug-in" + b + "重复") }), !0 } _bindingHooks(a) { this.hooks.forEach(p => { const v = a[p]; v && this.hooksEntity[p].tapPromise(a.pluginName + p, function () { return v.apply(a, [...arguments]) }) }) } _bindingHotkeys(a) { var p; (p = a == null ? void 0 : a.hotkeys) == null || p.forEach(v => { Me(v, { keyup: !0 }, _ => a.hotkeyEvent(v, _)) }) } _saveCustomAttr(a) { const { events: p = [], apis: v = [] } = a; this.customApis = this.customApis.concat(v), this.customEvents = this.customEvents.concat(p) } _bindingApis(a) { const { apis: p = [] } = a.constructor; p.forEach(v => { this[v] = function () { return a[v].apply(a, [...arguments]) } }) } _bindContextMenu() { this.canvas.on("mouse:down", a => { if (a.button === 3) { let p = []; Object.keys(this.pluginMap).forEach(v => { const _ = this.pluginMap[v], b = _.contextMenu && _.contextMenu(); b && (p = p.concat(b)) }), this._renderMenu(a, p) } }) } _renderMenu(a, p) { p.length !== 0 && (this.contextMenu.hideAll(), this.contextMenu.setData(p), this.contextMenu.show(a.e.clientX, a.e.clientY)) } _initActionHooks() { this.hooks.forEach(a => { this.hooksEntity[a] = new hS(["data"]) }) } _initContextMenu() { this.contextMenu = new fi(this.canvas.wrapperEl, []), this.contextMenu.install() } _initServersPlugin() { this.use(pr, {}) } } class ii { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "defautOption", {}); Z(this, "hotkeys", ["space"]); Z(this, "dragMode", !1); this.canvas = t, this.editor = a, this.dragMode = !1, this.init() } init() { this._initDring() } startDring() { this.dragMode = !0, this.canvas.defaultCursor = "grab", this.editor.emit("startDring"), this.canvas.renderAll() } endDring() { this.dragMode = !1, this.canvas.defaultCursor = "default", this.canvas.isDragging = !1, this.editor.emit("endDring"), this.canvas.renderAll() } _initDring() { const t = this; this.canvas.on("mouse:down", function (a) { const p = a.e; (p.altKey || t.dragMode) && (t.canvas.defaultCursor = "grabbing", t.canvas.discardActiveObject(), t._setDring(), this.selection = !1, this.isDragging = !0, this.lastPosX = p.clientX, this.lastPosY = p.clientY, this.requestRenderAll()) }), this.canvas.on("mouse:move", function (a) { if (this.isDragging) { t.canvas.discardActiveObject(), t.canvas.defaultCursor = "grabbing"; const { e: p } = a; if (!this.viewportTransform) return; const v = this.viewportTransform; v[4] += p.clientX - this.lastPosX, v[5] += p.clientY - this.lastPosY, this.lastPosX = p.clientX, this.lastPosY = p.clientY, this.requestRenderAll() } }), this.canvas.on("mouse:up", function () { this.viewportTransform && (this.setViewportTransform(this.viewportTransform), this.isDragging = !1, this.selection = !0, this.getObjects().forEach(a => { a.id !== "workspace" && a.hasControls && (a.selectable = !0) }), t.canvas.defaultCursor = "default", this.requestRenderAll()) }) } _setDring() { this.canvas.selection = !1, this.canvas.defaultCursor = "grab", this.canvas.getObjects().forEach(t => { t.selectable = !1 }), this.canvas.requestRenderAll() } destroy() { console.log("pluginDestroy") } hotkeyEvent(t, a) { a.code === "Space" && a.type === "keydown" && (this.dragMode || this.startDring()), a.code === "Space" && a.type === "keyup" && this.endDring() } } Z(ii, "pluginName", "DringPlugin"), Z(ii, "events", ["startDring", "endDring"]), Z(ii, "apis", ["startDring", "endDring"]); class ri { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "defautOption", { color: "rgba(255,95,95,1)", width: 1 }); Z(this, "hotkeys", [""]); Z(this, "dragMode", !1); this.canvas = t, this.editor = a, this.dragMode = !1, this.init() } init() { const { canvas: t } = this, a = t.getSelectionContext(), p = 5, v = 4, _ = this; let b, f = 1; function r(s) { h(s.x + .5, s.y1 > s.y2 ? s.y2 : s.y1, s.x + .5, s.y2 > s.y1 ? s.y2 : s.y1) } function c(s) { h(s.x1 > s.x2 ? s.x2 : s.x1, s.y + .5, s.x2 > s.x1 ? s.x2 : s.x1, s.y + .5) } function h(s, u, l, d) { b != null && (a.save(), a.lineWidth = _.defautOption.width, a.strokeStyle = _.defautOption.color, a.beginPath(), a.moveTo(s * f + b[4], u * f + b[5]), a.lineTo(l * f + b[4], d * f + b[5]), a.stroke(), a.restore()) } function n(s, u) { s = Math.round(s), u = Math.round(u); for (let l = s - v, d = s + v; l <= d; l++)if (l === u) return !0; return !1 } const o = [], i = []; t.on("mouse:down", () => { b = t.viewportTransform, f = t.getZoom() }), t.on("object:moving", s => { if (b === void 0 || s.target === void 0) return; const u = s.target, l = t.getObjects(), d = u.getCenterPoint(), g = d.x, m = d.y, y = u.getBoundingRect(), w = y.height / b[3], C = y.width / b[0]; let T = !1, A = !1; if (t._currentTransform) { for (let R = l.length; R--;) { if (l[R] === u || u instanceof Q.fabric.GuideLine && l[R] instanceof Q.fabric.GuideLine) continue; const $ = l[R].getCenterPoint(), L = $.x, B = $.y, N = l[R].getBoundingRect(), K = N.height / b[3], st = N.width / b[0]; n(L, g) && (A = !0, o.push({ x: L, y1: B < m ? B - K / 2 - p : B + K / 2 + p, y2: m > B ? m + w / 2 + p : m - w / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(L, m), "center", "center")), n(L - st / 2, g - C / 2) && (A = !0, o.push({ x: L - st / 2, y1: B < m ? B - K / 2 - p : B + K / 2 + p, y2: m > B ? m + w / 2 + p : m - w / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(L - st / 2 + C / 2, m), "center", "center")), n(L + st / 2, g + C / 2) && (A = !0, o.push({ x: L + st / 2, y1: B < m ? B - K / 2 - p : B + K / 2 + p, y2: m > B ? m + w / 2 + p : m - w / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(L + st / 2 - C / 2, m), "center", "center")), n(B, m) && (T = !0, i.push({ y: B, x1: L < g ? L - st / 2 - p : L + st / 2 + p, x2: g > L ? g + C / 2 + p : g - C / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(g, B), "center", "center")), n(B - K / 2, m - w / 2) && (T = !0, i.push({ y: B - K / 2, x1: L < g ? L - st / 2 - p : L + st / 2 + p, x2: g > L ? g + C / 2 + p : g - C / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(g, B - K / 2 + w / 2), "center", "center")), n(B + K / 2, m + w / 2) && (T = !0, i.push({ y: B + K / 2, x1: L < g ? L - st / 2 - p : L + st / 2 + p, x2: g > L ? g + C / 2 + p : g - C / 2 - p }), u.setPositionByOrigin(new Q.fabric.Point(g, B + K / 2 - w / 2), "center", "center")) } T || (i.length = 0), A || (o.length = 0) } }), t.on("before:render", () => { try { t.clearContext(t.contextTop) } catch (s) { console.log(s) } }), t.on("after:render", () => { for (let s = o.length; s--;)r(o[s]); for (let s = i.length; s--;)c(i[s]); o.length = 0, i.length = 0 }), t.on("mouse:up", () => { o.length = 0, i.length = 0, t.renderAll() }) } destroy() { console.log("pluginDestroy") } } Z(ri, "pluginName", "AlignGuidLinePlugin"), Z(ri, "events", ["", ""]), Z(ri, "apis", []); const dS = "/editor/assets/middlecontrol-a163c615.svg", pS = "/editor/assets/middlecontrolhoz-9b7cc4b3.svg", gS = "/editor/assets/edgecontrol-dbe38ac6.svg", mS = "/editor/assets/rotateicon-ec6729f2.svg"; Q.fabric.Object.NUM_FRACTION_DIGITS = 4; function $n(e, t, a, p, v, _, b) { b !== void 0 && (e.save(), e.translate(t, a), e.rotate(Q.fabric.util.degreesToRadians(b)), e.drawImage(p, -v / 2, -_ / 2, v, _), e.restore()) } function vS() { const e = document.createElement("img"); e.src = dS; const t = document.createElement("img"); t.src = pS; function a(v, _, b, f, r) { $n(v, _, b, e, 20, 25, r.angle) } function p(v, _, b, f, r) { $n(v, _, b, t, 25, 20, r.angle) } Q.fabric.Object.prototype.controls.ml = new Q.fabric.Control({ x: -.5, y: 0, offsetX: -1, cursorStyleHandler: Q.fabric.controlsUtils.scaleSkewCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingXOrSkewingY, getActionName: Q.fabric.controlsUtils.scaleOrSkewActionName, render: a }), Q.fabric.Object.prototype.controls.mr = new Q.fabric.Control({ x: .5, y: 0, offsetX: 1, cursorStyleHandler: Q.fabric.controlsUtils.scaleSkewCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingXOrSkewingY, getActionName: Q.fabric.controlsUtils.scaleOrSkewActionName, render: a }), Q.fabric.Object.prototype.controls.mb = new Q.fabric.Control({ x: 0, y: .5, offsetY: 1, cursorStyleHandler: Q.fabric.controlsUtils.scaleSkewCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingYOrSkewingX, getActionName: Q.fabric.controlsUtils.scaleOrSkewActionName, render: p }), Q.fabric.Object.prototype.controls.mt = new Q.fabric.Control({ x: 0, y: -.5, offsetY: -1, cursorStyleHandler: Q.fabric.controlsUtils.scaleSkewCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingYOrSkewingX, getActionName: Q.fabric.controlsUtils.scaleOrSkewActionName, render: p }) } function _S() { const e = document.createElement("img"); e.src = gS; function t(a, p, v, _, b) { $n(a, p, v, e, 25, 25, b.angle) } Q.fabric.Object.prototype.controls.tl = new Q.fabric.Control({ x: -.5, y: -.5, cursorStyleHandler: Q.fabric.controlsUtils.scaleCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingEqually, render: t }), Q.fabric.Object.prototype.controls.bl = new Q.fabric.Control({ x: -.5, y: .5, cursorStyleHandler: Q.fabric.controlsUtils.scaleCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingEqually, render: t }), Q.fabric.Object.prototype.controls.tr = new Q.fabric.Control({ x: .5, y: -.5, cursorStyleHandler: Q.fabric.controlsUtils.scaleCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingEqually, render: t }), Q.fabric.Object.prototype.controls.br = new Q.fabric.Control({ x: .5, y: .5, cursorStyleHandler: Q.fabric.controlsUtils.scaleCursorStyleHandler, actionHandler: Q.fabric.controlsUtils.scalingEqually, render: t }) } function yS(e) { const t = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E", a = document.createElement("img"); a.src = t; function p(_, b, f, r, c) { $n(_, b, f, a, 24, 24, c.angle) } function v(_, b) { if (b.action === "rotate") return !0; const f = e.getActiveObjects(); return f && (f.map(r => e.remove(r)), e.requestRenderAll(), e.discardActiveObject()), !0 } Q.fabric.Object.prototype.controls.deleteControl = new Q.fabric.Control({ x: .5, y: -.5, offsetY: -16, offsetX: 16, cursorStyle: "pointer", mouseUpHandler: v, render: p }) } function bS() { const e = document.createElement("img"); e.src = mS; function t(a, p, v, _, b) { $n(a, p, v, e, 40, 40, b.angle) } Q.fabric.Object.prototype.controls.mtr = new Q.fabric.Control({ x: 0, y: .5, cursorStyleHandler: Q.fabric.controlsUtils.rotationStyleHandler, actionHandler: Q.fabric.controlsUtils.rotationWithSnapping, offsetY: 30, actionName: "rotate", render: t }) } class Gl { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a, this.init() } init() { yS(this.canvas), _S(), vS(), bS(), Q.fabric.Object.prototype.set({ transparentCorners: !1, borderColor: "#51B9F9", cornerColor: "#FFF", borderScaleFactor: 2.5, cornerStyle: "circle", cornerStrokeColor: "#0E98FC", borderOpacityWhenMoving: 1 }) } destroy() { console.log("pluginDestroy") } } Z(Gl, "pluginName", "ControlsPlugin"); function Be(e) { return `url("data:image/svg+xml,%3Csvg height='18' width='18' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: black;'%3E%3Cg fill='none' transform='rotate(${e} 16 16)'%3E%3Cpath d='M22.4484 0L32 9.57891L22.4484 19.1478V13.1032C17.6121 13.8563 13.7935 17.6618 13.0479 22.4914H19.2141L9.60201 32.01L0 22.4813H6.54912C7.36524 14.1073 14.0453 7.44023 22.4484 6.61688V0Z' fill='white'/%3E%3Cpath d='M24.0605 3.89587L29.7229 9.57896L24.0605 15.252V11.3562C17.0479 11.4365 11.3753 17.0895 11.3048 24.0879H15.3048L9.60201 29.7308L3.90932 24.0879H8.0806C8.14106 15.3223 15.2645 8.22345 24.0605 8.14313V3.89587Z' fill='black'/%3E%3C/g%3E%3C/svg%3E ") 12 12,crosshair` } class Xl { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a, this.init() } init() { const { canvas: t } = this; Q.fabric.Object.prototype.controls.mtr = new Q.fabric.Control({ x: -.5, y: -.5, offsetY: -10, offsetX: -10, rotate: 20, actionName: "rotate", actionHandler: Q.fabric.controlsUtils.rotationWithSnapping, render: () => "" }), Q.fabric.Object.prototype.controls.mtr2 = new Q.fabric.Control({ x: .5, y: -.5, offsetY: -10, offsetX: 10, rotate: 20, actionName: "rotate", actionHandler: Q.fabric.controlsUtils.rotationWithSnapping, render: () => "" }), Q.fabric.Object.prototype.controls.mtr3 = new Q.fabric.Control({ x: .5, y: .5, offsetY: 10, offsetX: 10, rotate: 20, actionName: "rotate", actionHandler: Q.fabric.controlsUtils.rotationWithSnapping, render: () => "" }), Q.fabric.Object.prototype.controls.mtr4 = new Q.fabric.Control({ x: -.5, y: .5, offsetY: 10, offsetX: -10, rotate: 20, actionName: "rotate", actionHandler: Q.fabric.controlsUtils.rotationWithSnapping, render: () => "" }), t.on("after:render", () => { var v; const a = t.getActiveObject(), p = (v = a == null ? void 0 : a.angle) == null ? void 0 : v.toFixed(2); p !== void 0 && (Q.fabric.Object.prototype.controls.mtr.cursorStyle = Be(Number(p)), Q.fabric.Object.prototype.controls.mtr2.cursorStyle = Be(Number(p) + 90), Q.fabric.Object.prototype.controls.mtr3.cursorStyle = Be(Number(p) + 180), Q.fabric.Object.prototype.controls.mtr4.cursorStyle = Be(Number(p) + 270)) }), t.on("object:rotating", a => { var _, b, f; const p = t.lowerCanvasEl.nextSibling, v = (b = (_ = t.getActiveObject()) == null ? void 0 : _.angle) == null ? void 0 : b.toFixed(2); if (v !== void 0) switch ((f = a.transform) == null ? void 0 : f.corner) { case "mtr": p.style.cursor = Be(Number(v)); break; case "mtr2": p.style.cursor = Be(Number(v) + 90); break; case "mtr3": p.style.cursor = Be(Number(v) + 180); break; case "mtr4": p.style.cursor = Be(Number(v) + 270); break } }) } destroy() { console.log("pluginDestroy") } } Z(Xl, "pluginName", "ControlsRotatePlugin"); class gr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a } center(t, a) { const p = t.getCenterPoint(); return this.canvas._centerObject(a, p) } centerV(t, a) { return this.canvas._centerObject(a, new Q.fabric.Point(a.getCenterPoint().x, t.getCenterPoint().y)) } centerH(t, a) { return this.canvas._centerObject(a, new Q.fabric.Point(t.getCenterPoint().x, a.getCenterPoint().y)) } position(t) { const a = ["centerH", "center", "centerV"], p = this.canvas.getActiveObject(); if (a.includes(t) && p) { const v = this.canvas.getObjects().find(_ => _.id === "workspace"); v && (console.log(this[t]), this[t](v, p)), this.canvas.renderAll() } } contextMenu() { if (this.canvas.getActiveObject()) return [{ text: "Center horizontally and vertically", hotkey: "Ctrl+V", disabled: !1, onclick: () => this.position("center") }] } destroy() { console.log("pluginDestroy") } } Z(gr, "pluginName", "CenterAlignPlugin"), Z(gr, "apis", ["centerH", "center", "position", "centerV"]); class mr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a } _getWorkspace() { return this.canvas.getObjects().find(t => t.id === "workspace") } _workspaceSendToBack() { const t = this._getWorkspace(); t && t.sendToBack() } up() { const t = this.canvas.getActiveObjects(); if (t && t.length === 1) { const a = this.canvas.getActiveObjects()[0]; a && a.bringForward(), this.canvas.renderAll(), this._workspaceSendToBack() } } upTop() { const t = this.canvas.getActiveObjects(); if (t && t.length === 1) { const a = this.canvas.getActiveObjects()[0]; a && a.bringToFront(), this.canvas.renderAll(), console.log(this), this._workspaceSendToBack() } } down() { const t = this.canvas.getActiveObjects(); if (t && t.length === 1) { const a = this.canvas.getActiveObjects()[0]; a && a.sendBackwards(), this.canvas.renderAll(), this._workspaceSendToBack() } } downTop() { const t = this.canvas.getActiveObjects(); if (t && t.length === 1) { const a = this.canvas.getActiveObjects()[0]; a && a.sendToBack(), this.canvas.renderAll(), this._workspaceSendToBack() } } contextMenu() { if (this.canvas.getActiveObject()) return [{ text: "Layer management", hotkey: "❯", subitems: [{ text: "Move back", hotkey: "key", onclick: () => this.up() }, { text: "Move up", hotkey: "key", onclick: () => this.down() }, { text: "Front", hotkey: "key", onclick: () => this.upTop() }, { text: "Back", hotkey: "key", onclick: () => this.downTop() }] }] } destroy() { console.log("pluginDestroy") } } Z(mr, "pluginName", "LayerPlugin"), Z(mr, "apis", ["up", "upTop", "down", "downTop"]); class vr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "hotkeys", ["ctrl+v", "ctrl+c"]); Z(this, "cache"); this.canvas = t, this.editor = a, this.cache = null } _copyActiveSelection(t) { const p = this.canvas; t == null || t.clone(v => { v.clone(_ => { p.discardActiveObject(), !(_.left === void 0 || _.top === void 0) && (_.canvas = p, _.set({ left: _.left + 10, top: _.top + 10, evented: !0, id: Jt() }), _.forEachObject(b => { b.id = Jt(), p.add(b) }), _.setCoords(), p.setActiveObject(_), p.requestRenderAll()) }) }) } _copyObject(t) { const p = this.canvas; t == null || t.clone(v => { v.left === void 0 || v.top === void 0 || (p.discardActiveObject(), v.set({ left: v.left + 10, top: v.top + 10, evented: !0, id: Jt() }), p.add(v), p.setActiveObject(v), p.requestRenderAll()) }) } clone(t) { const a = t || this.canvas.getActiveObject(); a && ((a == null ? void 0 : a.type) === "activeSelection" ? this._copyActiveSelection(a) : this._copyObject(a)) } hotkeyEvent(t, a) { if (t === "ctrl+c" && a.type === "keydown") { const p = this.canvas.getActiveObject(); this.cache = p } t === "ctrl+v" && a.type === "keydown" && this.cache && this.clone(this.cache) } contextMenu() { if (this.canvas.getActiveObject()) return [{ text: "Copy", hotkey: "Ctrl+c", disabled: !1, onclick: () => this.clone() }] } destroy() { console.log("pluginDestroy") } } Z(vr, "pluginName", "CopyPlugin"), Z(vr, "apis", ["clone"]); class Kl { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "hotkeys", ["left", "right", "down", "up"]); this.canvas = t, this.editor = a } hotkeyEvent(t, a) { if (a.type === "keydown") { const { canvas: p } = this, v = p.getActiveObject(); if (!v) return; switch (t) { case "left": if (v.left === void 0) return; v.set("left", v.left - 1); break; case "right": if (v.left === void 0) return; v.set("left", v.left + 1); break; case "down": if (v.top === void 0) return; v.set("top", v.top + 1); break; case "up": if (v.top === void 0) return; v.set("top", v.top - 1); break }p.renderAll() } } destroy() { console.log("pluginDestroy") } } Z(Kl, "pluginName", "MoveHotKeyPlugin"); class _r { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "hotkeys", ["backspace"]); this.canvas = t, this.editor = a } hotkeyEvent(t, a) { a.type === "keydown" && t === "backspace" && this.del() } del() { const { canvas: t } = this, a = t.getActiveObjects(); a && (a.map(p => t.remove(p)), t.requestRenderAll(), t.discardActiveObject()) } contextMenu() { if (this.canvas.getActiveObject()) return [null, { text: "Delete", hotkey: "Ctrl+V", disabled: !1, onclick: () => this.del() }] } destroy() { console.log("pluginDestroy") } } Z(_r, "pluginName", "DeleteHotKeyPlugin"), Z(_r, "apis", ["del"]); class yr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a } unGroup() { const t = this.canvas.getActiveObject(); t && (t.toActiveSelection(), t.getObjects().forEach(a => { a.set("id", Jt()) }), this.canvas.discardActiveObject().renderAll()) } group() { const t = this.canvas.getActiveObject(); if (!t) return; const a = t.toGroup(), p = a.getObjects(); a.clone(v => { v.set("id", Jt()), this.canvas.remove(a), p.forEach(_ => { this.canvas.remove(_) }), this.canvas.add(v), this.canvas.setActiveObject(v) }) } contextMenu() { const t = this.canvas.getActiveObject(); if (console.log(t, "111"), t && t.type === "group") return [{ text: "Split combination", hotkey: "Ctrl+V", disabled: !1, onclick: () => this.unGroup() }]; if (this.canvas.getActiveObjects().length > 1) return [{ text: "Combination", hotkey: "Ctrl+V", disabled: !1, onclick: () => this.group() }] } destroy() { console.log("pluginDestroy") } } Z(yr, "pluginName", "GroupPlugin"), Z(yr, "apis", ["unGroup", "group"]); Q.fabric.Arrow = Q.fabric.util.createClass(Q.fabric.Line, { type: "arrow", superType: "drawing", initialize(e, t) { if (!e) { const { x1: a, x2: p, y1: v, y2: _ } = t; e = [a, v, p, _] } t = t || {}, this.callSuper("initialize", e, t) }, _render(e) { this.callSuper("_render", e), e.save(); const t = this.x2 - this.x1, a = this.y2 - this.y1, p = Math.atan2(a, t); e.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2), e.rotate(p), e.beginPath(), e.moveTo(5, 0), e.lineTo(-5, 5), e.lineTo(-5, -5), e.closePath(), e.fillStyle = this.stroke, e.fill(), e.restore() } }); Q.fabric.Arrow.fromObject = (e, t) => { const { x1: a, x2: p, y1: v, y2: _ } = e; return t(new Q.fabric.Arrow([a, v, p, _], e)) }; const wS = Q.fabric.Arrow; class br { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "isDrawingLineMode"); Z(this, "isArrow"); Z(this, "lineToDraw"); Z(this, "pointer"); Z(this, "pointerPoints"); Z(this, "isDrawingLine"); this.canvas = t, this.editor = a, this.isDrawingLine = !1, this.isDrawingLineMode = !1, this.isArrow = !1, this.lineToDraw = null, this.pointer = null, this.pointerPoints = null, this.init() } init() { const { canvas: t } = this; t.on("mouse:down", a => { if (!this.isDrawingLineMode) return; t.discardActiveObject(), t.getObjects().forEach(v => { v.selectable = !1, v.hasControls = !1 }), t.requestRenderAll(), this.isDrawingLine = !0, this.pointer = t.getPointer(a.e), this.pointerPoints = [this.pointer.x, this.pointer.y, this.pointer.x, this.pointer.y]; const p = this.isArrow ? wS : Q.fabric.Line; this.lineToDraw = new p(this.pointerPoints, { strokeWidth: 2, stroke: "#000000", id: Jt() }), this.lineToDraw.selectable = !1, this.lineToDraw.evented = !1, this.lineToDraw.strokeUniform = !0, t.add(this.lineToDraw) }), t.on("mouse:move", a => { if (!(!this.isDrawingLine || (t.discardActiveObject(), t.getActiveObject()))) { if (this.pointer = t.getPointer(a.e), a.e.shiftKey) { const v = this.pointerPoints[0], _ = this.pointerPoints[1], b = this.pointer.x - v, f = this.pointer.y - _, r = Math.sqrt(b * b + f * f); let c = Math.atan2(f, b) / Math.PI * 180; c = parseInt((c + 7.5) % 360 / 15) * 15; const h = r * Math.cos(c * Math.PI / 180), n = r * Math.sin(c * Math.PI / 180); this.lineToDraw.set({ x2: h + v, y2: n + _ }) } else this.lineToDraw.set({ x2: this.pointer.x, y2: this.pointer.y }); t.renderAll() } }), t.on("mouse:up", () => { this.isDrawingLine && (this.lineToDraw.setCoords(), this.isDrawingLine = !1, t.discardActiveObject()) }) } setArrow(t) { this.isArrow = t } setMode(t) { this.isDrawingLineMode = t, this.isDrawingLineMode || this.endRest() } endRest() { this.canvas.getObjects().forEach(t => { t.id !== "workspace" && (t.selectable = !0, t.hasControls = !0) }) } destroy() { console.log("pluginDestroy") } } Z(br, "pluginName", "DrawLinePlugin"), Z(br, "apis", ["setArrow", "setMode"]); class ql { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "isDown", !1); this.canvas = t, this.editor = a, this._init() } _init() { this.canvas.on("mouse:down", t => { this.isDown = !0, t.target && !t.target.lockMovementX && !t.target.lockMovementY && !t.target.lockRotation && !t.target.lockScalingX && !t.target.lockScalingY && (t.target.type === "i-text" && (t.target.hasControls = !0, t.target.lockScalingY = !0, t.target.lockScalingX = !1, t.target.hasBorders = !1), t.target.hasControls = !0) }), this.canvas.on("mouse:up", () => { this.isDown = !1 }), this.canvas.on("mouse:dblclick", t => { if (t.target && t.target.type === "group") { const a = this._getGroupObj(t); if (!a) return; if (a.selectable = !0, a.hasControls && (a.hasControls = !1), this.isText(a)) { this._bedingTextEditingEvent(a, t); return } this.canvas.setActiveObject(a), this.canvas.renderAll() } }) } _getGroupTextObj(t) { var v; const a = this.canvas.getPointer(t.e, !0), p = this.canvas._searchPossibleTargets((v = t.target) == null ? void 0 : v._objects, a); return p && this.isText(p) ? p : !1 } _getGroupObj(t) { var v; const a = this.canvas.getPointer(t.e, !0); return this.canvas._searchPossibleTargets((v = t.target) == null ? void 0 : v._objects, a) } _bedingTextEditingEvent(t, a) { if (!a.target) return; const p = t.toObject(), v = a.target, b = { "i-text": "IText", text: "Text", textbox: "Textbox" }[p.type], f = v.calcTransformMatrix(), r = f[0], c = f[1], h = f[2], n = f[3], o = f[4], i = f[5], s = r * t.left + h * t.top + o, u = c * t.left + n * t.top + i, l = new Q.fabric[b](t.text, Ut(Et({}, p), { textAlign: t.textAlign, left: s, top: u, styles: t.styles, groupCopyed: t.group })); l.id = Jt(), t.visible = !1, a.target.addWithUpdate(), l.visible = !0, l.selectable = !0, l.hasConstrols = !1, l.editable = !0, this.canvas.add(l), this.canvas.setActiveObject(l), l.enterEditing(), l.selectAll(), l.on("editing:exited", () => { t.set({ text: l.text, visible: !0 }), a.target.addWithUpdate(), l.visible = !1, this.canvas.remove(l), this.canvas.setActiveObject(a.target) }) } _bedingEditingEvent(t, a) { if (!a.target) return; const p = a.target.left, v = a.target.top, _ = this._unGroup() || [], b = () => { const f = this.canvas.getObjects().filter(c => c.id && _.includes(c.id)); f.forEach(c => this.canvas.remove(c)); const r = new Q.fabric.Group([...f]); r.set("left", p), r.set("top", v), r.set("id", Jt()), t.off("editing:exited", b), this.canvas.add(r), this.canvas.discardActiveObject().renderAll() }; t.on("editing:exited", b) } _unGroup() { const t = [], a = this.canvas.getActiveObject(); if (a) return a.getObjects().forEach(p => { const v = Jt(); t.push(v), p.set("id", v) }), a.toActiveSelection(), t } isText(t) { return t.type && ["i-text", "text", "textbox"].includes(t.type) } destroy() { console.log("pluginDestroy") } } Z(ql, "pluginName", "GroupTextEditorPlugin"); class wr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a } left() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { left: v } = a; t.discardActiveObject(), p.forEach(b => { const f = b.getBoundingRect(!0); b.set({ left: v - f.left + b.left }), b.setCoords() }); const _ = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(_), t.requestRenderAll() } right() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { left: v, width: _ } = a; t.discardActiveObject(), p.forEach(f => { const r = f.getBoundingRect(!0); f.set({ left: v + _ - (r.left + r.width) + f.left }) }); const b = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(b), t.requestRenderAll() } xcenter() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { left: v, width: _ } = a; t.discardActiveObject(), p.forEach(f => { const r = f.getBoundingRect(!0); f.set({ left: v + _ / 2 - (r.left + r.width / 2) + f.left }) }); const b = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(b), t.requestRenderAll() } ycenter() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { top: v, height: _ } = a; t.discardActiveObject(), p.forEach(f => { const r = f.getBoundingRect(!0); f.set({ top: v + _ / 2 - (r.top + r.height / 2) + f.top }) }); const b = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(b), t.requestRenderAll() } top() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { top: v } = a; t.discardActiveObject(), p.forEach(b => { const f = b.getBoundingRect(!0); b.set({ top: v - f.top + b.top }) }); const _ = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(_), t.requestRenderAll() } bottom() { const { canvas: t } = this, a = t.getActiveObject(), p = t.getActiveObjects(), { top: v, height: _ } = a; t.discardActiveObject(), p.forEach(f => { const r = f.getBoundingRect(!0); f.set({ top: v + _ - (r.top + r.height) + f.top }) }); const b = new Q.fabric.ActiveSelection(p, { canvas: t }); t.setActiveObject(b), t.requestRenderAll() } xequation() { const { canvas: t } = this, a = t.getActiveObject(); function p(f) { return f.aCoords.tr.x - f.aCoords.tl.x } function v() { let f = 0; return a.forEachObject(r => { f += p(r) }), f } function _() { const f = v(); return (a.width - f) / (a._objects.length - 1) } function b(f) { if (f === 0) return 0; let r = 0; for (let c = 0; c < f; c++)r += p(a._objects[c]); return r } if (a && a.type === "activeSelection") { a._objects.sort((h, n) => h.left - n.left); const r = _(), c = a.width / 2; a.forEachObject((h, n) => { const o = b(n), i = r * n + o - c; h.set("left", i) }), t.renderAll() } } yequation() { const { canvas: t } = this, a = t.getActiveObject(); function p(f) { return f.aCoords.bl.y - f.aCoords.tl.y } function v() { let f = 0; return a.forEachObject(r => { f += p(r) }), f } function _() { const f = v(); return (a.height - f) / (a._objects.length - 1) } function b(f) { if (f === 0) return 0; let r = 0; for (let c = 0; c < f; c++)r += p(a._objects[c]); return r } if (a && a.type === "activeSelection") { a._objects.sort((h, n) => h.top - n.top); const r = _(), c = a.height / 2; a.forEachObject((h, n) => { const o = b(n), i = r * n + o - c; h.set("top", i) }), t.renderAll() } } destroy() { console.log("pluginDestroy") } } Z(wr, "pluginName", "GroupAlignPlugin"), Z(wr, "apis", ["left", "right", "xcenter", "ycenter", "top", "bottom", "xequation", "yequation"]); class si { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "workspaceEl"); Z(this, "workspace"); Z(this, "option"); this.canvas = t, this.editor = a, this.init({ width: 900, height: 2e3 }) } init(t) { const a = document.querySelector("#workspace"); if (!a) throw new Error("element #workspace is missing, plz check!"); this.workspaceEl = a, this.workspace = null, this.option = t, this._initBackground(), this._initWorkspace(), this._initResizeObserve(), this._bindWheel() } hookImportAfter() { return new Promise(t => { const a = this.canvas.getObjects().find(p => p.id === "workspace"); a && (a.set("selectable", !1), a.set("hasControls", !1), this.setSize(a.width, a.height), this.editor.emit("sizeChange", a.width, a.height)), t() }) } hookSaveAfter() { return new Promise(t => { this.auto(), t(!0) }) } _initBackground() { this.canvas.backgroundImage = "", this.canvas.setWidth(this.workspaceEl.offsetWidth), this.canvas.setHeight(this.workspaceEl.offsetHeight) } _initWorkspace() { const { width: t, height: a } = this.option, p = new Q.fabric.Rect({ fill: "rgba(255,255,255,1)", width: t, height: a, id: "workspace", strokeWidth: 0 }); p.set("selectable", !1), p.set("hasControls", !1), p.hoverCursor = "default", this.canvas.add(p), this.canvas.renderAll(), this.workspace = p, this.auto() } setCenterFromObject(t) { const { canvas: a } = this, p = t.getCenterPoint(), v = a.viewportTransform; a.width === void 0 || a.height === void 0 || !v || (v[4] = a.width / 2 - p.x * v[0], v[5] = a.height / 2 - p.y * v[3], a.setViewportTransform(v), a.renderAll()) } _initResizeObserve() { new ResizeObserver(ar(() => { this.auto() }, 50)).observe(this.workspaceEl) } setSize(t, a) { this._initBackground(), this.option.width = t, this.option.height = a, this.workspace = this.canvas.getObjects().find(p => p.id === "workspace"), this.workspace.set("width", t), this.workspace.set("height", a), this.auto() } setZoomAuto(t, a) { const { workspaceEl: p } = this, v = p.offsetWidth, _ = p.offsetHeight; this.canvas.setWidth(v), this.canvas.setHeight(_); const b = this.canvas.getCenter(); this.canvas.setViewportTransform(Q.fabric.iMatrix.concat()), this.canvas.zoomToPoint(new Q.fabric.Point(b.left, b.top), t), this.workspace && (this.setCenterFromObject(this.workspace), this.workspace.clone(f => { this.canvas.clipPath = f, this.canvas.requestRenderAll() }), a && a(this.workspace.left, this.workspace.top)) } _getScale() { const t = this.workspaceEl.offsetWidth, a = this.workspaceEl.offsetHeight; return t / a < this.option.width / this.option.height ? t / this.option.width : a / this.option.height } big() { let t = this.canvas.getZoom(); t += .05; const a = this.canvas.getCenter(); this.canvas.zoomToPoint(new Q.fabric.Point(a.left, a.top), t) } small() { let t = this.canvas.getZoom(); t -= .05; const a = this.canvas.getCenter(); this.canvas.zoomToPoint(new Q.fabric.Point(a.left, a.top), t < 0 ? .01 : t) } auto() { const t = this._getScale(); this.setZoomAuto(t - .08) } one() { this.setZoomAuto(.8 - .08), this.canvas.requestRenderAll() } _bindWheel() { this.canvas.on("mouse:wheel", function (t) { const a = t.e.deltaY; let p = this.getZoom(); p *= ss(.999, a), p > 20 && (p = 20), p < .01 && (p = .01); const v = this.getCenter(); this.zoomToPoint(new Q.fabric.Point(v.left, v.top), p), t.e.preventDefault(), t.e.stopPropagation() }) } destroy() { console.log("pluginDestroy") } } Z(si, "pluginName", "WorkspacePlugin"), Z(si, "events", ["sizeChange"]), Z(si, "apis", ["big", "small", "auto", "one", "setSize"]); class Jl { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); this.canvas = t, this.editor = a } hookImportBefore(t) { return Xc(t) } destroy() { console.log("pluginDestroy") } } Z(Jl, "pluginName", "DownFontPlugin"); class oi { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "hotkeys", ["ctrl+z"]); Z(this, "history"); Z(this, "renderCanvas", () => { this.history.pause(), this.canvas.clear(), this.canvas.loadFromJSON(this.history.source.value, () => { this.canvas.renderAll(), this.history.resume() }) }); this.canvas = t, this.editor = a, this._init() } _init() { this.history = Nc(dt(), { capacity: 50 }), this.canvas.on({ "object:added": t => this._save(t), "object:modified": t => this._save(t), "selection:updated": t => this._save(t) }) } getHistory() { return this.history } _save(t) { t.action === void 0 && t.e || !this.canvas || !this.canvas.getObjects().find(v => v.id === "workspace") || this.history.isTracking.value && (this.history.source.value = this.editor.getJson()) } undo() { this.history.canUndo.value && (this.renderCanvas(), this.history.undo()) } redo() { this.history.redo(), this.renderCanvas() } hotkeyEvent(t, a) { t === "ctrl+z" && a.type === "keydown" && this.undo() } destroy() { console.log("pluginDestroy") } } Z(oi, "pluginName", "HistoryPlugin"), Z(oi, "apis", ["undo", "redo", "getHistory"]), Z(oi, "events", ["historyInitSuccess"]); class Cr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "selectedMode"); this.canvas = t, this.editor = a, this.selectedMode = dt(Se.EMPTY), this.init() } init() { Hi.on(fe.ONE, () => this.selectedMode.value = Se.ONE), Hi.on(fe.MULTI, () => this.selectedMode.value = Se.MULTI), Hi.on(fe.CANCEL, () => this.selectedMode.value = Se.EMPTY) } flip(t) { const a = this.canvas.getActiveObject(); a && (a.set(`flip${t}`, !a[`flip${t}`]).setCoords(), this.canvas.requestRenderAll()) } contextMenu() { if (this.selectedMode.value === Se.ONE) return [{ text: "flip", hotkey: "❯", subitems: [{ text: us("flip.x"), hotkey: "|", onclick: () => this.flip("X") }, { text: us("flip.y"), hotkey: "-", onclick: () => this.flip("Y") }] }] } destroy() { console.log("pluginDestroy") } } Z(Cr, "pluginName", "FlipPlugin"), Z(Cr, "apis", ["flip"]); const CS = e => { const t = [.02, .03, .05, .1, .2, .5], a = [4992, 2496, 960, 480, 240, 96]; let p = 0; for (; p < t.length && t[p] < e;)p++; return a[p - 1] || 5e3 }, Ho = (e, t) => { const a = t ? "left" : "top", p = t ? "width" : "height"; e.sort((b, f) => b[a] - f[a]); const v = []; let _ = Object.assign({}, e[0]); for (const b of e) { const f = Object.assign({}, b); _[a] + _[p] >= f[a] ? _[p] = Math.max(_[a] + _[p], f[a] + f[p]) - _[a] : (v.push(_), _ = Object.assign({}, f)) } return v.push(_), v }, Ki = (e, t) => { e.save(); const { left: a, top: p, width: v, height: _, stroke: b, lineWidth: f } = t; e.beginPath(), b && (e.strokeStyle = b), e.lineWidth = f != null ? f : 1, e.moveTo(a, p), e.lineTo(a + v, p + _), e.stroke(), e.restore() }, qi = (e, t) => { e.save(); const { left: a, top: p, text: v, fill: _, align: b, angle: f, fontSize: r } = t; _ && (e.fillStyle = _), e.textAlign = b != null ? b : "left", e.textBaseline = "top", e.font = `${r != null ? r : 10}px sans-serif`, f && (e.translate(a, p), e.rotate(Math.PI / 180 * f), e.translate(-a, -p)), e.fillText(v, a, p), e.restore() }, Sr = (e, t) => { e.save(); const { left: a, top: p, width: v, height: _, fill: b, stroke: f, strokeWidth: r } = t; e.beginPath(), b && (e.fillStyle = b), e.rect(a, p, v, _), e.fill(), f && (e.strokeStyle = f, e.lineWidth = r != null ? r : 1, e.stroke()), e.restore() }, qn = (e, t) => { e.save(); const { isHorizontal: a, left: p, top: v, width: _, height: b, backgroundColor: f } = t, r = a ? e.createLinearGradient(p, b / 2, p + _, b / 2) : e.createLinearGradient(_ / 2, v, _ / 2, b + v), c = new Q.fabric.Color(f); c.setAlpha(0), r.addColorStop(0, c.toRgba()), r.addColorStop(.33, f), r.addColorStop(.67, f), r.addColorStop(1, c.toRgba()), Sr(e, { left: p, top: v, width: _, height: b, fill: r }), e.restore() }; function SS() { Q.fabric.GuideLine || (Q.fabric.GuideLine = Q.fabric.util.createClass(Q.fabric.Line, { type: "GuideLine", selectable: !1, hasControls: !1, hasBorders: !1, stroke: "#4bec13", originX: "center", originY: "center", padding: 4, globalCompositeOperation: "difference", axis: "horizontal", initialize(e, t) { const a = t.axis === "horizontal"; this.hoverCursor = a ? "ns-resize" : "ew-resize"; const p = a ? [-999999, e, 999999, e] : [e, -999999, e, 999999]; t[a ? "lockMovementX" : "lockMovementY"] = !0, this.callSuper("initialize", p, t), this.on("mousedown:before", v => { this.activeOn === "down" && this.canvas.setActiveObject(this, v.e) }), this.on("moving", v => { this.canvas.ruler.options.enabled && this.isPointOnRuler(v.e) ? this.moveCursor = "not-allowed" : this.moveCursor = this.isHorizontal() ? "ns-resize" : "ew-resize", this.canvas.fire("guideline:moving", { target: this, e: v.e }) }), this.on("mouseup", v => { if (this.canvas.ruler.options.enabled && this.isPointOnRuler(v.e)) { this.canvas.remove(this); return } this.moveCursor = this.isHorizontal() ? "ns-resize" : "ew-resize", this.canvas.fire("guideline:mouseup", { target: this, e: v.e }) }), this.on("removed", () => { this.off("removed"), this.off("mousedown:before"), this.off("moving"), this.off("mouseup") }) }, getBoundingRect(e, t) { this.bringToFront(); const a = this.isHorizontal(), p = this.callSuper("getBoundingRect", e, t); return p[a ? "top" : "left"] += p[a ? "height" : "width"] / 2, p[a ? "height" : "width"] = 0, p }, isPointOnRuler(e) { const t = this.isHorizontal(), a = this.canvas.ruler.isPointOnRuler(new Q.fabric.Point(e.offsetX, e.offsetY)); return t && a === "horizontal" || !t && a === "vertical" ? a : !1 }, isHorizontal() { return this.height === 0 } }), Q.fabric.GuideLine.fromObject = function (e, t) { const a = Q.fabric.util.object.clone; function p(b) { delete b.xy, t && t(b) } const v = a(e, !0), _ = v.height === 0; v.xy = _ ? v.y1 : v.x1, v.axis = _ ? "horizontal" : "vertical", Q.fabric.Object._fromObject(v.type, v, p, "xy") }) } Q.fabric.GuideLine; class xS { constructor(t) { Z(this, "ctx"); Z(this, "options"); Z(this, "startCalibration"); Z(this, "activeOn", "up"); Z(this, "objectRect"); Z(this, "eventHandler", { calcObjectRect: ar(this.calcObjectRect.bind(this), 15), clearStatus: this.clearStatus.bind(this), canvasMouseDown: this.canvasMouseDown.bind(this), canvasMouseMove: ar(this.canvasMouseMove.bind(this), 15), canvasMouseUp: this.canvasMouseUp.bind(this), render: t => { t.ctx && this.render() } }); Z(this, "lastAttr", { status: "out", cursor: void 0, selection: void 0 }); Z(this, "tempGuidelLine"); Z(this, "getCommonEventInfo", t => { if (!(!this.tempGuidelLine || !t.absolutePointer)) return { e: t.e, transform: this.tempGuidelLine.get("transform"), pointer: { x: t.absolutePointer.x, y: t.absolutePointer.y }, target: this.tempGuidelLine } }); this.options = Object.assign({ ruleSize: 20, fontSize: 10, enabled: !1, backgroundColor: "#fff", borderColor: "#ddd", highlightColor: "#007fff", textColor: "#888" }, t), this.ctx = this.options.canvas.getContext(), Q.fabric.util.object.extend(this.options.canvas, { ruler: this }), SS(), this.options.enabled && this.enable() } destroy() { this.disable() } clearGuideline() { this.options.canvas.remove(...this.options.canvas.getObjects(Q.fabric.GuideLine.prototype.type)) } showGuideline() { this.options.canvas.getObjects(Q.fabric.GuideLine.prototype.type).forEach(t => { t.set("visible", !0) }), this.options.canvas.renderAll() } hideGuideline() { this.options.canvas.getObjects(Q.fabric.GuideLine.prototype.type).forEach(t => { t.set("visible", !1) }), this.options.canvas.renderAll() } enable() { this.options.enabled = !0, this.options.canvas.on("after:render", this.eventHandler.calcObjectRect), this.options.canvas.on("after:render", this.eventHandler.render), this.options.canvas.on("mouse:down", this.eventHandler.canvasMouseDown), this.options.canvas.on("mouse:move", this.eventHandler.canvasMouseMove), this.options.canvas.on("mouse:up", this.eventHandler.canvasMouseUp), this.options.canvas.on("selection:cleared", this.eventHandler.clearStatus), this.showGuideline(), this.render() } disable() { this.options.canvas.off("after:render", this.eventHandler.calcObjectRect), this.options.canvas.off("after:render", this.eventHandler.render), this.options.canvas.off("mouse:down", this.eventHandler.canvasMouseDown), this.options.canvas.off("mouse:move", this.eventHandler.canvasMouseMove), this.options.canvas.off("mouse:up", this.eventHandler.canvasMouseUp), this.options.canvas.off("selection:cleared", this.eventHandler.clearStatus), this.hideGuideline(), this.options.enabled = !1 } render() { var a, p; const t = this.options.canvas.viewportTransform; t && (this.draw({ isHorizontal: !0, rulerLength: this.getSize().width, startCalibration: (a = this.startCalibration) != null && a.x ? this.startCalibration.x : -(t[4] / t[0]) }), this.draw({ isHorizontal: !1, rulerLength: this.getSize().height, startCalibration: (p = this.startCalibration) != null && p.y ? this.startCalibration.y : -(t[5] / t[3]) }), qn(this.ctx, { isHorizontal: !0, left: -10, top: -10, width: this.options.ruleSize * 2 + 10, height: this.options.ruleSize + 10, backgroundColor: this.options.backgroundColor }), qn(this.ctx, { isHorizontal: !1, left: -10, top: -10, width: this.options.ruleSize + 10, height: this.options.ruleSize * 2 + 10, backgroundColor: this.options.backgroundColor })) } getSize() { var t, a; return { width: (t = this.options.canvas.width) != null ? t : 0, height: (a = this.options.canvas.height) != null ? a : 0 } } getZoom() { return this.options.canvas.getZoom() } draw(t) { const { isHorizontal: a, rulerLength: p, startCalibration: v } = t, _ = this.getZoom(), b = CS(_), f = p / _, r = Math[v > 0, "floor"](v / b) * b, c = r - v, h = this.getSize(); Sr(this.ctx, { left: 0, top: 0, width: a ? h.width : this.options.ruleSize, height: a ? this.options.ruleSize : h.height, fill: this.options.backgroundColor, stroke: this.options.borderColor }); const n = new Q.fabric.Color(this.options.textColor); for (let o = 0; o + c <= Math.floor(f); o += b) { const i = (c + o) * _, s = Math.floor(r / 96 + o / 96) + "", u = Math.floor(10 * s.length / 4 / 96), l = a ? i - u - 1 / 96 : this.options.ruleSize / 2 - this.options.fontSize / 2 - 4, d = a ? this.options.ruleSize / 2 - this.options.fontSize / 2 - 4 : i + u; qi(this.ctx, { text: s, left: l, top: d, fill: n.toRgb(), angle: a ? 0 : -90 }) } for (let o = 0; o + c <= Math.floor(f); o += b) { const i = Math.floor((c + o) * _), s = a ? i : this.options.ruleSize - 8, u = a ? this.options.ruleSize - 8 : i, l = a ? 0 : 8, d = a ? 8 : 0; Ki(this.ctx, { left: s, top: u, width: l, height: d, stroke: n.toRgb() }) } if (this.objectRect) { const o = a ? "x" : "y"; this.objectRect[o].forEach(i => { if (i.skip === o) return; const s = A => ((A / _ + v / 96) * 10 / 10).toFixed(1), u = s(a ? i.left / 96 : i.top / 96), l = s(a ? i.left / 96 + i.width / 96 : i.top / 96 + i.height / 96), d = u === l, g = { isHorizontal: a, width: a ? 160 : this.options.ruleSize - 8, height: a ? this.options.ruleSize - 8 : 160, backgroundColor: this.options.backgroundColor }; qn(this.ctx, Ut(Et({}, g), { left: a ? i.left - 80 : 0, top: a ? 0 : i.top - 80 })), d || qn(this.ctx, Ut(Et({}, g), { left: a ? i.width + i.left - 80 : 0, top: a ? 0 : i.height + i.top - 80 })); const m = new Q.fabric.Color(this.options.highlightColor); m.setAlpha(.5), Sr(this.ctx, { left: a ? i.left : this.options.ruleSize - 8, top: a ? this.options.ruleSize - 8 : i.top, width: a ? i.width : 8, height: a ? 8 : i.height, fill: m.toRgba() }); const y = this.options.ruleSize / 2 - this.options.fontSize / 2 - 4, w = { fill: m.toRgba(), angle: a ? 0 : -90 }; qi(this.ctx, Ut(Et({}, w), { text: u, left: a ? i.left - 2 : y, top: a ? y : i.top - 2, align: d ? "center" : a ? "right" : "left" })), d || qi(this.ctx, Ut(Et({}, w), { text: l, left: a ? i.left + i.width + 2 : y, top: a ? y : i.top + i.height + 2, align: a ? "left" : "right" })); const C = d ? 8 : 14; m.setAlpha(1); const T = { width: a ? 0 : C, height: a ? C : 0, stroke: m.toRgba() }; Ki(this.ctx, Ut(Et({}, T), { left: a ? i.left : this.options.ruleSize - C, top: a ? this.options.ruleSize - C : i.top })), d || Ki(this.ctx, Ut(Et({}, T), { left: a ? i.left + i.width : this.options.ruleSize - C, top: a ? this.options.ruleSize - C : i.top + i.height })) }) } } calcObjectRect() { const t = this.options.canvas.getActiveObjects(); if (t.length === 0) return; const a = t.reduce((p, v) => { var b, f; const _ = v.getBoundingRect(!1, !0); if (v.group) { const r = Et({ top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1 }, v.group); _.width *= r.scaleX, _.height *= r.scaleY; const c = r.width / 2 + r.left, h = (r.width / 2 + ((b = v.left) != null ? b : 0)) * (1 - r.scaleX); _.left += (c - h) * this.getZoom(); const n = r.height / 2 + r.top, o = (r.height / 2 + ((f = v.top) != null ? f : 0)) * (1 - r.scaleY); _.top += (n - o) * this.getZoom() } return v instanceof Q.fabric.GuideLine && (_.skip = v.isHorizontal() ? "x" : "y"), p.push(_), p }, []); a.length !== 0 && (this.objectRect = { x: Ho(a, !0), y: Ho(a, !1) }) } clearStatus() { this.objectRect = void 0 } isPointOnRuler(t) { return new Q.fabric.Rect({ left: 0, top: 0, width: this.options.ruleSize, height: this.options.canvas.height }).containsPoint(t) ? "vertical" : new Q.fabric.Rect({ left: 0, top: 0, width: this.options.canvas.width, height: this.options.ruleSize }).containsPoint(t) ? "horizontal" : !1 } canvasMouseDown(t) { if (!t.pointer || !t.absolutePointer) return; const a = this.isPointOnRuler(t.pointer); a && this.activeOn === "up" && (this.lastAttr.selection = this.options.canvas.selection, this.options.canvas.selection = !1, this.activeOn = "down", this.tempGuidelLine = new Q.fabric.GuideLine(a === "horizontal" ? t.absolutePointer.y : t.absolutePointer.x, { axis: a, visible: !1 }), this.options.canvas.add(this.tempGuidelLine), this.options.canvas.setActiveObject(this.tempGuidelLine), this.options.canvas._setupCurrentTransform(t.e, this.tempGuidelLine, !0), this.tempGuidelLine.fire("down", this.getCommonEventInfo(t))) } canvasMouseMove(t) { if (!t.pointer) return; if (this.tempGuidelLine && t.absolutePointer) { const p = {}; this.tempGuidelLine.axis === "horizontal" ? p.top = t.absolutePointer.y : p.left = t.absolutePointer.x, this.tempGuidelLine.set(Ut(Et({}, p), { visible: !0 })), this.options.canvas.requestRenderAll(); const v = this.getCommonEventInfo(t); this.options.canvas.fire("object:moving", v), this.tempGuidelLine.fire("moving", v) } const a = this.isPointOnRuler(t.pointer); if (!a) { this.lastAttr.status !== "out" && (this.options.canvas.defaultCursor = this.lastAttr.cursor, this.lastAttr.status = "out"); return } (this.lastAttr.status === "out" || a !== this.lastAttr.status) && (this.lastAttr.cursor = this.options.canvas.defaultCursor, this.options.canvas.defaultCursor = a === "horizontal" ? "ns-resize" : "ew-resize", this.lastAttr.status = a) } canvasMouseUp(t) { var a; this.activeOn === "down" && (this.options.canvas.selection = this.lastAttr.selection, this.activeOn = "up", (a = this.tempGuidelLine) == null || a.fire("up", this.getCommonEventInfo(t)), this.tempGuidelLine = void 0) } } function TS(e, t) { const a = new xS(Et({ canvas: e }, t)); let p; const v = () => { p = e.getObjects().find(b => b.id === "workspace") }, _ = (b, f) => { const { top: r, height: c, left: h, width: n } = b; if (r === void 0 || c === void 0 || h === void 0 || n === void 0) return !1; const o = f.getBoundingRect(!0, !0), { top: i, height: s, left: u, width: l } = o; return f.isHorizontal() && (r > i + 1 || r + c < i + s - 1) ? !0 : !f.isHorizontal() && (h > u + 1 || h + n < u + l - 1) }; return e.on("guideline:moving", b => { if (!p) { v(); return } const { target: f } = b; _(p, f) && (f.moveCursor = "not-allowed") }), e.on("guideline:mouseup", b => { var r; if (!p) { v(); return } const { target: f } = b; _(p, f) && (e.remove(f), e.setCursor((r = e.defaultCursor) != null ? r : "")) }), a } class xr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "ruler"); this.canvas = t, this.editor = a, this.init() } hookSaveBefore() { return new Promise(t => { this.hideGuideline(), t(!0) }) } hookSaveAfter() { return new Promise(t => { this.showGuideline(), t(!0) }) } init() { this.ruler = TS(this.canvas) } hideGuideline() { this.ruler.hideGuideline() } showGuideline() { this.ruler.showGuideline() } rulerEnable() { this.ruler.enable() } rulerDisable() { this.ruler.disable() } destroy() { console.log("pluginDestroy") } } Z(xr, "pluginName", "RulerPlugin"), Z(xr, "apis", ["hideGuideline", "showGuideline", "rulerEnable", "rulerDisable"]); class Tr { constructor(t, a) { Z(this, "canvas"); Z(this, "editor"); Z(this, "apiMapUrl"); this.canvas = t, this.editor = a, this.apiMapUrl = { template: "https://vista.simboz.website/api/template", svg: "https://nihaojob.github.io/vue-fabric-editor-static/svg/type.json" } } getMaterialType(t) { return ie(this, null, function* () { const a = this.apiMapUrl[t]; return (yield Te.get(a)).data.data }) } getMaterialInfo(t) { return ie(this, null, function* () { const a = this.apiMapUrl[t]; return (yield Te.get(a, { params: { typeId: t } })).data.data }) } } Z(Tr, "pluginName", "MaterialPlugin"), Z(Tr, "apis", ["getMaterialType", "getMaterialList"]); const Zl = e => (me("data-v-8cc0fd62"), e = e(), ve(), e), OS = { class: "home" }, kS = Zl(() => S("span", { class: "logo" }, [S("a", { href: "#", target: "_blank" })], -1)), AS = { style: { float: "right" } }, ES = { class: "content" }, PS = { class: "left-panel" }, MS = { class: "left-panel" }, jS = { class: "left-panel" }, DS = { class: "left-panel" }, LS = { class: "left-panel" }, FS = { id: "workspace" }, $S = { class: "canvas-box" }, IS = Zl(() => S("div", { class: "inside-shadow" }, null, -1)), RS = { class: "right-bar" }, BS = { key: 1, style: { "padding-top": "10px" } }, zS = { class: "attr-item" }, US = Dt({ name: "Home" }), HS = Object.assign(US, { setup(e) { const t = Or(), a = Wt(() => t.state.userId), p = Wt(() => t.state.productId), v = Wt(() => t.state.templateHeight), _ = Wt(() => t.state.templateWidth), b = Wt(() => t.state.backExsist), f = Wt(() => t.state.role); ue(() => ie(this, null, function* () { try { yield t.dispatch("fetchDataFromLaravel"), Ot.userId = a.value, Ot.productId = p.value, Ot.templateHeight = v.value, Ot.templateWidth = _.value, Ot.backExsist = b.value, Ot.role = f.value, u.role = f.value, u.back = b.value } catch (w) { console.error("Error fetching data from Laravel:", w) } })); const c = dt(0), h = dt(0), n = () => { setTimeout(() => { c.value += 1 }, 2e3) }, o = () => { setTimeout(() => { h.value += 1 }, 2e3) }, i = new fS, s = new Pl, u = ee({ menuActive: 1, show: !1, toolsBarShow: !0, attrBarShow: !0, select: null, ruler: !1, role: !1, back: !1 }); ue(() => { const w = new Q.fabric.Canvas("canvas", { fireRightClick: !0, stopContextMenu: !0, controlsAboveOverlay: !0 }); i.init(w), i.use(ii), i.use(ri), i.use(Gl), i.use(Xl), i.use(gr), i.use(mr), i.use(vr), i.use(Kl), i.use(_r), i.use(yr), i.use(br), i.use(ql), i.use(wr), i.use(si), i.use(Jl), i.use(oi), i.use(Cr), i.use(xr), i.use(Tr), s.init(w), u.show = !0 }); const l = w => { w ? i.rulerEnable() : i.rulerDisable() }, d = () => { u.menuActive = 100, u.toolsBarShow = !1 }, g = w => { u.menuActive = w, u.toolsBarShow = !0 }, m = () => { u.attrBarShow = !u.attrBarShow }; de(() => [hi.reloadImportTmpl.value, hi.reloadUserUpoload.value], ([w, C]) => { w > 0 && Ot.role && (console.log("reloadImportTmpl changed"), n()), C > 0 && o() }); const y = () => { Ot.front && i.insertSvgString(Ot.front) }; return de(Ot, w => { y() }), Sn("fabric", Q.fabric), Sn("event", s), Sn("canvasEditor", i), (w, C) => { const T = ut("Divider"), A = ut("iSwitch"), U = ut("Tooltip"), R = ut("Header"), $ = ut("Icon"), L = ut("MenuItem"), B = ut("Menu"), N = ut("Content"), K = ut("Layout"); return lt(), mt("div", OS, [I(K, null, { default: G(() => [j(u).show ? (lt(), Rt(R, { key: 0 }, { default: G(() => [kS, j(u).role ? (lt(), Rt(dc, { key: 0 })) : At("", !0), j(u).role ? (lt(), Rt(T, { key: 1, type: "vertical" })) : At("", !0), j(u).role ? (lt(), Rt(ou, { key: 2 })) : At("", !0), I(T, { type: "vertical" }), I(U, { content: w.$t("grid") }, { default: G(() => [I(A, { modelValue: j(u).ruler, "onUpdate:modelValue": C[0] || (C[0] = st => j(u).ruler = st), onOnChange: l, size: "small", class: "switch" }, null, 8, ["modelValue"])]), _: 1 }, 8, ["content"]), I(T, { type: "vertical" }), I(X1), S("div", AS, [I(j(cf)), j(u).role ? (lt(), Rt(j(gv), { key: 0 })) : At("", !0), j(u).role ? (lt(), Rt(Em, { key: 1 })) : At("", !0), j(u).role ? At("", !0) : (lt(), Rt(Dm, { key: 2 }))])]), _: 1 })) : At("", !0), I(N, { style: { display: "flex", height: "calc(100vh - 64px)" } }, { default: G(() => [j(u).show ? (lt(), mt("div", { key: 0, class: he(`left-bar ${j(u).toolsBarShow && "show-tools-bar"}`) }, [I(B, { "active-name": j(u).menuActive, accordion: "", onOnSelect: g, width: "65px" }, { default: G(() => [I(L, { name: 1, class: "menu-item" }, { default: G(() => [I($, { type: "md-book", size: "24" }), S("div", null, yt(w.$t("templates")), 1)]), _: 1 }), I(L, { name: 2, class: "menu-item" }, { default: G(() => [I($, { type: "md-images", size: "24" }), S("div", null, yt(w.$t("elements")), 1)]), _: 1 }), I(L, { name: 3, class: "menu-item" }, { default: G(() => [I($, { type: "ios-leaf-outline", size: "24" }), S("div", null, yt(w.$t("material.cartoon")), 1)]), _: 1 }), I(L, { name: 4, class: "menu-item" }, { default: G(() => [I($, { type: "md-reorder", size: "24" }), S("div", null, yt(w.$t("layers")), 1)]), _: 1 }), I(L, { name: 5, class: "menu-item" }, { default: G(() => [I($, { type: "md-images", size: "24" }), S("div", null, yt(w.$t("images")), 1)]), _: 1 })]), _: 1 }, 8, ["active-name"]), Ct(S("div", ES, [Ct(S("div", PS, [(lt(), Rt(bv, { ref: "importTmplRef", key: j(c) }))], 512), [[pe, j(u).menuActive === 1]]), Ct(S("div", MS, [I(Bv), I(kh)], 512), [[pe, j(u).menuActive === 2]]), Ct(S("div", jS, [I(Nv)], 512), [[pe, j(u).menuActive === 3]]), Ct(S("div", DS, [I(l0)], 512), [[pe, j(u).menuActive === 4]]), Ct(S("div", LS, [(lt(), Rt(Nh, { key: j(h) }))], 512), [[pe, j(u).menuActive === 5]])], 512), [[pe, j(u).toolsBarShow]]), Ct(S("div", { class: "close-btn", onClick: d }, null, 512), [[pe, j(u).toolsBarShow]])], 2)) : At("", !0), S("div", FS, [S("div", $S, [IS, S("canvas", { id: "canvas", class: he(j(u).ruler ? "design-stage-grid" : "") }, null, 2), j(u).show ? (lt(), Rt(Qm, { key: 0 })) : At("", !0), I(Gm)])]), Ct(S("div", RS, [j(u).back ? (lt(), Rt(Ih, { key: 0 })) : At("", !0), j(u).show ? (lt(), mt("div", BS, [I(C1), I(v1), I(Um), I(T1), I(V1), S("div", zS, [I(nv), I(rv), I(Fm)]), I(Xh), I(ef), I(lf)])) : At("", !0), j(u).show ? (lt(), Rt(NC, { key: 2 })) : At("", !0)], 512), [[pe, j(u).attrBarShow]]), S("div", { class: he(`close-btn right-btn ${j(u).attrBarShow && "right-btn-open"}`), onClick: m }, null, 2)]), _: 1 })]), _: 1 })]) } } }), VS = Yt(HS, [["__scopeId", "data-v-8cc0fd62"]]), KS = Object.freeze(Object.defineProperty({ __proto__: null, default: VS }, Symbol.toStringTag, { value: "Module" })); export { $2 as a, A2 as c, I2 as g, KS as i, YS as r, So as v };
